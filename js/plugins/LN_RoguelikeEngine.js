//=============================================================================
// LN_RoguelikeEngine.js
// ----------------------------------------------------------------------------
// Copyright (c) 2020 lriki
// This software is released under the MIT License.
// http://opensource.org/licenses/mit-license.php
// ----------------------------------------------------------------------------
// [GitHub] : https://github.com/lriki/LN_RoguelikeEngine
// [Twitter]: https://twitter.com/lriki8
//=============================================================================

/*:ja
 * @plugindesc LN_RoguelikeEngine v0.0.1
 * @author lriki
 *
 * @help test.
 *
 * MIT License
 */
 

 
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./ts/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./ts/Common.ts":
/*!**********************!*\
  !*** ./ts/Common.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Log = exports.assert = void 0;\r\nfunction assert(condition, msg) {\r\n    if (!condition) {\r\n        throw new Error(msg);\r\n    }\r\n}\r\nexports.assert = assert;\r\nvar Log = /** @class */ (function () {\r\n    function Log() {\r\n    }\r\n    Log.d = function (text) {\r\n        //console.log(\"%c\" + text, \"color: blue; font-weight: bold\");\r\n    };\r\n    Log.postCommand = function (text) {\r\n        //console.log(`%c[Post: ${text}]`, \"color: maroon\");\r\n    };\r\n    Log.doCommand = function (text) {\r\n        console.log(\"%c[Do: \" + text + \"]\", \"color: fuchsia\");\r\n    };\r\n    return Log;\r\n}());\r\nexports.Log = Log;\r\n\n\n//# sourceURL=webpack:///./ts/Common.ts?");

/***/ }),

/***/ "./ts/DataManager.ts":
/*!***************************!*\
  !*** ./ts/DataManager.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar REDataManager_1 = __webpack_require__(/*! ./data/REDataManager */ \"./ts/data/REDataManager.ts\");\r\nvar REGame_1 = __webpack_require__(/*! ./RE/REGame */ \"./ts/RE/REGame.ts\");\r\nvar REGameManager_1 = __webpack_require__(/*! ./system/REGameManager */ \"./ts/system/REGameManager.ts\");\r\nvar RMMZIntegration_1 = __webpack_require__(/*! ./RMMZIntegration */ \"./ts/RMMZIntegration.ts\");\r\nvar REData_1 = __webpack_require__(/*! ./data/REData */ \"./ts/data/REData.ts\");\r\nvar Common_1 = __webpack_require__(/*! ./Common */ \"./ts/Common.ts\");\r\nvar REVisual_1 = __webpack_require__(/*! ./visual/REVisual */ \"./ts/visual/REVisual.ts\");\r\nvar RESystem_1 = __webpack_require__(/*! ./system/RESystem */ \"./ts/system/RESystem.ts\");\r\n/*\r\n [2020/11/2] マップ読み込みメモ\r\n ----------\r\n 制約: RMMZ は Scene_Map に遷移するたびに、マップデータのロードが行われる。\r\n       goto, call 関係なしで、メニューや先頭から戻ってきたときもロードされる。\r\n\r\n ### 固定マップ\r\n 倉庫・訓練場・ボス部屋・チュートリアルマップなどが該当する。\r\n 当初は Land から独立したマップとして考えていたが、ひとまず他とローディングのフローを合わせるため、\r\n Land に属することを必須としてみる。\r\n\r\n 例えば通常の RMMZ のマップから倉庫マップに移動したいときは、通常のマップ移動とは異なる。\r\n 「倉庫LandのF1を倉庫マップとする」といった設定を Land マップで行い、\r\n イベントからはスクリプトコマンドなどで「倉庫LandのF1へ移動する」\r\n\r\n ### シャッフルダンジョンマップ\r\n\r\n ### ランダムマップ\r\n イベントや階段などのマップ遷移は、[Land 情報マップID, フロア番号] を与えて遷移する。\r\n その後、対応するテンプレートマップへ遷移する。\r\n 実際に表示される RMMZ のマップは、このテンプレートマップとなる。\r\n\r\n > このようにして、RE システムがアクティブな時のマップは、どんなパターンであれ\r\n > 必ず \"Floor\" 扱いされたマップがロードされた状態となる。\r\n > こうしておかないとマップロード処理が非常に煩雑になる。\r\n\r\n\r\n ### 固定及びシャッフルマップのイベントについて\r\n これらのマップには RMMZ のイベントを配置することができる。\r\n 特にボス部屋で演出のためにイベントを起動する要求は非常に多い。\r\n またボスの初期位置を決めるためにも使う。\r\n\r\n これらのイベントはマップへ遷移したあと、そのマップのイベントから Entity を作ることになるが、\r\n RMMZ の頻繁なマップロードのタイミングに対応するため対策が必要となる。\r\n - REMap の生成元となった MapId を覚えておく。\r\n - マップ遷移が行われたとき、↑で覚えている ID と同じマップであれば Entity を生成しない。（以前のをそのまま使う）\r\n - イベントから生成した Entity はすべて AdhocEntity とする。\r\n\r\n これらの制約のため、REVisual 等は Game_Event のインスタンスを直接参照してはならない。\r\n eventId で参照すること。\r\n\r\n\r\n*/\r\nvar _DataManager_loadMapData = DataManager.loadMapData;\r\nDataManager.loadMapData = function (mapId) {\r\n    var floor = REDataManager_1.REDataManager.floor(mapId);\r\n    if (floor.landId > 0) {\r\n        var land = REData_1.REData.lands[floor.landId];\r\n        Common_1.assert(land);\r\n        // ダンジョンフロアである場合、関係するマップデータをすべて読み込む\r\n        REDataManager_1.REDataManager.landMapDataLoading = true; // DataManager.isMapLoaded で追加データの読み込みもチェックするようにする\r\n        REDataManager_1.REDataManager.loadingMapId = mapId;\r\n        // 今いる Land 以外へ遷移したときは、データテーブルをロードする\r\n        if (REDataManager_1.REDataManager.loadedLandId != land.id) {\r\n            var land_filename = \"Map\" + land.mapId.padZero(3) + \".json\";\r\n            var eventTable_filename = \"Map\" + land.eventTableMapId.padZero(3) + \".json\";\r\n            var itemTable_filename = \"Map\" + land.itemTableMapId.padZero(3) + \".json\";\r\n            var enemyTable_filename = \"Map\" + land.enemyTableMapId.padZero(3) + \".json\";\r\n            var trapTable_filename = \"Map\" + land.trapTableMapId.padZero(3) + \".json\";\r\n            this.loadDataFile(\"RE_dataLandMap\", land_filename);\r\n            this.loadDataFile(\"RE_dataEventTableMap\", eventTable_filename);\r\n            this.loadDataFile(\"RE_dataItemTableMap\", itemTable_filename);\r\n            this.loadDataFile(\"RE_dataEnemyTableMap\", enemyTable_filename);\r\n            this.loadDataFile(\"RE_dataTrapTableMap\", trapTable_filename);\r\n            REDataManager_1.REDataManager.loadedLandId = land.id;\r\n        }\r\n        else {\r\n            // 同じ Land 内の Floor 間遷移。Land 情報をロードする必要はない。\r\n        }\r\n        if (floor.mapKind == REData_1.REFloorMapKind.FixedMap) {\r\n            // 固定マップへの直接遷移。\r\n            // この場合は通常のマップ読み込みを行う。\r\n            _DataManager_loadMapData.call(DataManager, mapId);\r\n        }\r\n        else {\r\n            // ランダム・シャッフルマップへの遷移は、現在のフロアに応じてロードするマップがかわるため、\r\n            // Land 情報のロードが終わったあとに行う。(=> Scene_Map.prototype.isReady)\r\n        }\r\n    }\r\n    else {\r\n        // 普通のマップ\r\n        REGame_1.REGame.map.releaseMap();\r\n        REDataManager_1.REDataManager.landMapDataLoading = false;\r\n        _DataManager_loadMapData.call(DataManager, mapId);\r\n    }\r\n};\r\n// Scene_Map.isReady() から呼ばれる\r\nvar _DataManager_isMapLoaded = DataManager.isMapLoaded;\r\nDataManager.isMapLoaded = function () {\r\n    var result = _DataManager_isMapLoaded.call(DataManager);\r\n    if (result) {\r\n        if (REDataManager_1.REDataManager.landMapDataLoading) {\r\n            return !!window[\"RE_dataLandMap\"] &&\r\n                !!window[\"RE_dataEventTableMap\"] &&\r\n                !!window[\"RE_dataItemTableMap\"] &&\r\n                !!window[\"RE_dataEnemyTableMap\"] &&\r\n                !!window[\"RE_dataTrapTableMap\"];\r\n            // 続いて Scene_Map.isReady() で、固定マップなどのロードを行う\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n};\r\nvar _DataManager_createGameObjects = DataManager.createGameObjects;\r\nDataManager.createGameObjects = function () {\r\n    _DataManager_createGameObjects.call(DataManager);\r\n    REVisual_1.REVisual.initialize();\r\n    RESystem_1.RESystem.integration = new RMMZIntegration_1.RMMZIntegration();\r\n    REGameManager_1.REGameManager.createGameObjects();\r\n};\r\n\n\n//# sourceURL=webpack:///./ts/DataManager.ts?");

/***/ }),

/***/ "./ts/Game_Event.ts":
/*!**************************!*\
  !*** ./ts/Game_Event.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar RMMZHelper_1 = __webpack_require__(/*! ./rmmz/RMMZHelper */ \"./ts/rmmz/RMMZHelper.ts\");\r\nvar _Game_Event_initMembers = Game_Event.prototype.initMembers;\r\nGame_Event.prototype.initMembers = function () {\r\n    _Game_Event_initMembers.call(this);\r\n};\r\nvar _Game_Event_isTriggerIn = Game_Event.prototype.isTriggerIn;\r\nGame_Event.prototype.isTriggerIn = function (triggers) {\r\n    if (this.isREEntity())\r\n        return false; // イベント実行タイミングはすべて RE システム無いから決められる\r\n    else\r\n        return triggers.includes(this._trigger);\r\n};\r\nvar _Game_Event_setupPageSettings = Game_Event.prototype.setupPageSettings;\r\nGame_Event.prototype.setupPageSettings = function () {\r\n    _Game_Event_setupPageSettings.call(this);\r\n    this._entityMetadata = RMMZHelper_1.RMMZHelper.readEntityMetadata(this);\r\n};\r\nGame_Event.prototype.isREEntity = function () {\r\n    return !!this._entityMetadata;\r\n};\r\n\n\n//# sourceURL=webpack:///./ts/Game_Event.ts?");

/***/ }),

/***/ "./ts/Game_Map.ts":
/*!************************!*\
  !*** ./ts/Game_Map.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar REDataManager_1 = __webpack_require__(/*! ./data/REDataManager */ \"./ts/data/REDataManager.ts\");\r\nvar REGame_1 = __webpack_require__(/*! ./RE/REGame */ \"./ts/RE/REGame.ts\");\r\nvar REGameManager_1 = __webpack_require__(/*! ./system/REGameManager */ \"./ts/system/REGameManager.ts\");\r\nvar _Game_Map_setup = Game_Map.prototype.setup;\r\nGame_Map.prototype.setup = function (mapId) {\r\n    // 先に REMap をクリーンアップしておく。\r\n    // 内部から onEntityLeavedMap() が呼び出され、ここで Game_Event の erase が走るため、\r\n    // Game_Map 構築後にクリーンアップしてしまうと、新しく作成された Event が消えてしまう。\r\n    REGame_1.REGame.map.releaseMap();\r\n    _Game_Map_setup.call(this, mapId);\r\n    // この時点ではまだ Player は locate() されていないので、\r\n    // 位置をとりたければ _newX, _newY を見る必要がある。\r\n    //console.log(\"Game_Map initialized.\", $gamePlayer._newX);\r\n    //console.log($gamePlayer);\r\n    if (REDataManager_1.REDataManager.isRESystemMap(mapId)) {\r\n        if (1) // TODO: 固定マップの場合\r\n         {\r\n            REGame_1.REGame.map.setup(mapId);\r\n        }\r\n        $gamePlayer.hideFollowers();\r\n    }\r\n    /*\r\n    console.log(\"OK\");\r\n    console.log($dataMap.data?.length);\r\n    this.setTileData(0, 0, 0, 1);\r\n    this.setTileData(0, 0, 1, 1);\r\n    this.setTileData(0, 0, 2, 1);\r\n    this.setTileData(0, 0, 3, 1);\r\n    this.setTileData(0, 0, 4, 1);\r\n    this.setTileData(0, 0, 5, 1);\r\n    */\r\n};\r\n/*\r\nGame_Map.prototype.setTileData = function(x: number, y: number, z: number, value: number) : void {\r\nconst width = this.width();\r\nconst height = this.height();\r\nassert(0 <= x && x < width && 0 <= y && y < height);\r\n\r\nconst data = $dataMap.data;\r\nif (data) {\r\n    data[(z * height + y) * width + x] = value;\r\n}\r\n}\r\n*/\r\nvar _Game_Map_update = Game_Map.prototype.update;\r\nGame_Map.prototype.update = function (sceneActive) {\r\n    _Game_Map_update.call(this, sceneActive);\r\n    if (this.isRESystemMap() &&\r\n        !this.isEventRunning()) { // イベント実行中はシミュレーションを行わない\r\n        REGameManager_1.REGameManager.update();\r\n    }\r\n};\r\nGame_Map.prototype.isRESystemMap = function () {\r\n    return REGame_1.REGame.map.isValid();\r\n};\r\n\n\n//# sourceURL=webpack:///./ts/Game_Map.ts?");

/***/ }),

/***/ "./ts/Game_Player.ts":
/*!***************************!*\
  !*** ./ts/Game_Player.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar REGame_1 = __webpack_require__(/*! ./RE/REGame */ \"./ts/RE/REGame.ts\");\r\nvar _Game_Player_initMembers = Game_Player.prototype.initMembers;\r\nGame_Player.prototype.initMembers = function () {\r\n    _Game_Player_initMembers.call(this);\r\n};\r\nvar _Game_Player_isTransparent = Game_Player.prototype.isTransparent;\r\nGame_Player.prototype.isTransparent = function () {\r\n    if ($gameMap.isRESystemMap())\r\n        return true; // RE マップ中は常に非表示\r\n    else\r\n        return _Game_Player_isTransparent.call(this);\r\n};\r\nvar _Game_Player_performTransfer = Game_Player.prototype.performTransfer;\r\nGame_Player.prototype.performTransfer = function () {\r\n    var oldIsTransferring = this.isTransferring();\r\n    // $gameMap.setup() などはオリジナルの処理の中で行われる\r\n    _Game_Player_performTransfer.call(this);\r\n    // performTransfer() が呼ばれる時点では、RMMZ のマップ情報はロード済み。\r\n    // transfarEntity で Player 操作中の Entity も別マップへ移動する。\r\n    // この中で、Camera が Player を注視していれば Camera も Floor を移動することで、\r\n    // REシステムとしてのマップ遷移も行われる。\r\n    if (oldIsTransferring && REGame_1.REGame.map.isValid()) {\r\n        var playerEntity = REGame_1.REGame.world.entity(REGame_1.REGame.core.mainPlayerEntiyId);\r\n        if (playerEntity) {\r\n            REGame_1.REGame.world._transfarEntity(playerEntity, REGame_1.REGame.map.floorId(), this.x, this.y);\r\n        }\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack:///./ts/Game_Player.ts?");

/***/ }),

/***/ "./ts/PrefabEvent.ts":
/*!***************************!*\
  !*** ./ts/PrefabEvent.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Common_1 = __webpack_require__(/*! ./Common */ \"./ts/Common.ts\");\r\nvar REDataManager_1 = __webpack_require__(/*! ./data/REDataManager */ \"./ts/data/REDataManager.ts\");\r\nvar REVisual_1 = __webpack_require__(/*! ./visual/REVisual */ \"./ts/visual/REVisual.ts\");\r\nvar Game_REPrefabEvent = /** @class */ (function (_super) {\r\n    __extends(Game_REPrefabEvent, _super);\r\n    function Game_REPrefabEvent(mapId, dataMapId, eventId) {\r\n        var _this = this;\r\n        console.log(\"Game_REPrefabEvent\", eventId);\r\n        // \"REDatabase\" のマップのイベントとして扱う。\r\n        // セルフスイッチをコントロールするときに参照される。\r\n        _this = _super.call(this, dataMapId, eventId) || this;\r\n        _this._databaseMapEventId = 1;\r\n        _this._spritePrepared = false;\r\n        console.log(\"Game_REPrefabEvent\", _this);\r\n        return _this;\r\n    }\r\n    Game_REPrefabEvent.prototype.databaseMapEventId = function () {\r\n        return this._databaseMapEventId;\r\n    };\r\n    Game_REPrefabEvent.prototype.isREPrefab = function () {\r\n        return true;\r\n    };\r\n    Game_REPrefabEvent.prototype.isREExtinct = function () {\r\n        return this._erased;\r\n    };\r\n    Game_REPrefabEvent.prototype.isRESpritePrepared = function () {\r\n        return this._spritePrepared;\r\n    };\r\n    Game_REPrefabEvent.prototype.setSpritePrepared = function (value) {\r\n        this._spritePrepared = true;\r\n    };\r\n    return Game_REPrefabEvent;\r\n}(Game_Event));\r\nGame_CharacterBase.prototype.isREPrefab = function () {\r\n    return false;\r\n};\r\nGame_CharacterBase.prototype.isRESpritePrepared = function () {\r\n    return false;\r\n};\r\nGame_CharacterBase.prototype.isREExtinct = function () {\r\n    return false;\r\n};\r\nGame_Map.prototype.spawnREEvent = function (eventData) {\r\n    if (!$dataMap.events) {\r\n        throw new Error();\r\n    }\r\n    // 新しい Game_Event ID を発行\r\n    var eventId = this._events.length;\r\n    // 新しい Game_Event に対応する IDataMapEvent を登録する。\r\n    // こうしておかないと、Game_Event のコンストラクタの locate で例外する。\r\n    $dataMap.events[eventId] = eventData;\r\n    var event = new Game_REPrefabEvent(this._mapId, REDataManager_1.REDataManager.databaseMapId, eventId);\r\n    this._events[eventId] = event;\r\n    return event;\r\n};\r\n/*\r\nGame_Map.prototype.spawnREEventFromCurrentMapEvent = function(eventId: number): Game_REPrefabEvent {\r\n    var event = new Game_REPrefabEvent(this._mapId, this._mapId, eventId);\r\n    this._events[eventId] = event;\r\n    return event;\r\n}\r\n*/\r\nGame_Map.prototype.getREPrefabEvents = function () {\r\n    return this.events().filter(function (event) {\r\n        return event.isREPrefab();\r\n    });\r\n};\r\nSprite_Character.prototype.isRECharacterExtinct = function () {\r\n    return this._character.isREExtinct();\r\n};\r\nSprite_Character.prototype.endAllEffect = function () {\r\n    // TODO: https://raw.githubusercontent.com/triacontane/RPGMakerMV/master/EventReSpawn.js\r\n};\r\nvar _Spriteset_Map_createCharacters = Spriteset_Map.prototype.createCharacters;\r\nSpriteset_Map.prototype.createCharacters = function () {\r\n    this._prefabSpriteIdRE = Sprite._counter + 1;\r\n    _Spriteset_Map_createCharacters.call(this);\r\n};\r\nvar _Spriteset_Map_update = Spriteset_Map.prototype.update;\r\nSpriteset_Map.prototype.update = function () {\r\n    _Spriteset_Map_update.call(this);\r\n    this.updateREPrefabEvent();\r\n};\r\nSpriteset_Map.prototype.updateREPrefabEvent = function () {\r\n    var _this = this;\r\n    $gameMap.getREPrefabEvents().forEach(function (event) {\r\n        if (!event.isRESpritePrepared()) {\r\n            _this.makeREPrefabEventSprite(event);\r\n        }\r\n    });\r\n    for (var i = 0, n = this._characterSprites.length; i < n; i++) {\r\n        if (this._characterSprites[i].isRECharacterExtinct()) {\r\n            this.removeREPrefabEventSprite(i--);\r\n            n--;\r\n        }\r\n    }\r\n};\r\nSpriteset_Map.prototype.makeREPrefabEventSprite = function (event) {\r\n    Common_1.assert(REVisual_1.REVisual.manager);\r\n    event.setSpritePrepared(true);\r\n    var sprite = new Sprite_Character(event);\r\n    var spriteIndex = this._characterSprites.length;\r\n    this._characterSprites.push(sprite);\r\n    var t = this._tilemap;\r\n    t.addChild(sprite);\r\n    // Visual と Sprite を関連付ける\r\n    if (REVisual_1.REVisual.entityVisualSet) {\r\n        var visual = REVisual_1.REVisual.entityVisualSet.findEntityVisualByRMMZEventId(event.eventId());\r\n        visual === null || visual === void 0 ? void 0 : visual._setSpriteIndex(spriteIndex);\r\n    }\r\n};\r\nSpriteset_Map.prototype.removeREPrefabEventSprite = function (index) {\r\n    var sprite = this._characterSprites[index];\r\n    this._characterSprites.splice(index, 1);\r\n    sprite.endAllEffect();\r\n    var t = this._tilemap;\r\n    t.removeChild(sprite);\r\n};\r\n\n\n//# sourceURL=webpack:///./ts/PrefabEvent.ts?");

/***/ }),

/***/ "./ts/RE/MapDataProvidor.ts":
/*!**********************************!*\
  !*** ./ts/RE/MapDataProvidor.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MapDataProvidor = void 0;\r\nvar Common_1 = __webpack_require__(/*! ../Common */ \"./ts/Common.ts\");\r\nvar REGame_1 = __webpack_require__(/*! ./REGame */ \"./ts/RE/REGame.ts\");\r\n/**\r\n * Data_Map をラップして、RE モジュールへ Data_Map への書き込み手段を提供する。\r\n *\r\n * RE モジュールからは、壁を壊した時など Block(Tile) 情報が変わった時に、\r\n * このクラスを通して Data_Map.data への書き込みが行われる。\r\n *\r\n * 単なる書き込みの他、ランダムダンジョンでは Block 種別から壁や床のタイル ID を求めたうえで\r\n * Data_Map.data への書き込んだり、オートタイルの解決などを行う。\r\n */\r\n// deprecated\r\nvar MapDataProvidor = /** @class */ (function () {\r\n    function MapDataProvidor() {\r\n    }\r\n    MapDataProvidor.tileId = function (x, y, z) {\r\n        var _a, _b;\r\n        var width = (_a = $dataMap.width) !== null && _a !== void 0 ? _a : 0;\r\n        var height = (_b = $dataMap.width) !== null && _b !== void 0 ? _b : 0;\r\n        Common_1.assert(0 <= x && x < width && 0 <= y && y < height);\r\n        var data = $dataMap.data;\r\n        if (data) {\r\n            return data[(z * height + y) * width + x];\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    };\r\n    MapDataProvidor.tileIds = function (x, y) {\r\n        var list = new Array(REGame_1.REGame.TILE_LAYER_COUNT);\r\n        for (var i = 0; i < REGame_1.REGame.TILE_LAYER_COUNT; i++) {\r\n            list[i] = this.tileId(x, y, i);\r\n        }\r\n        return list;\r\n    };\r\n    MapDataProvidor.setTileId = function (x, y, z, tileId) {\r\n        var _a, _b;\r\n        var width = (_a = $dataMap.width) !== null && _a !== void 0 ? _a : 0;\r\n        var height = (_b = $dataMap.width) !== null && _b !== void 0 ? _b : 0;\r\n        Common_1.assert(0 <= x && x < width && 0 <= y && y < height);\r\n        var data = $dataMap.data;\r\n        if (data) {\r\n            data[(z * height + y) * width + x] = tileId;\r\n        }\r\n    };\r\n    MapDataProvidor.setTileIds = function (x, y, tileIds) {\r\n        for (var i = 0; i < REGame_1.REGame.TILE_LAYER_COUNT; i++) {\r\n            this.setTileId(x, y, i, tileIds[i]);\r\n        }\r\n    };\r\n    MapDataProvidor.onUpdateBlock = function (block) {\r\n        var tileIds = block.tileIds();\r\n        if (tileIds) {\r\n            this.setTileIds(block.x(), block.y(), tileIds);\r\n        }\r\n    };\r\n    return MapDataProvidor;\r\n}());\r\nexports.MapDataProvidor = MapDataProvidor;\r\n\n\n//# sourceURL=webpack:///./ts/RE/MapDataProvidor.ts?");

/***/ }),

/***/ "./ts/RE/REGame.ts":
/*!*************************!*\
  !*** ./ts/RE/REGame.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REGame = void 0;\r\n/**\r\n * 各 REGame_* インスタンスを保持する。\r\n *\r\n * コアスクリプトの $game* と同じ役割。\r\n */\r\nvar REGame = /** @class */ (function () {\r\n    function REGame() {\r\n    }\r\n    REGame.TILE_LAYER_COUNT = 6;\r\n    REGame.uniqueActorUnits = [];\r\n    return REGame;\r\n}());\r\nexports.REGame = REGame;\r\n\n\n//# sourceURL=webpack:///./ts/RE/REGame.ts?");

/***/ }),

/***/ "./ts/RE/REGame_Attribute.ts":
/*!***********************************!*\
  !*** ./ts/RE/REGame_Attribute.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REGame_UnitAttribute = exports.REGame_Attribute = void 0;\r\n/**\r\n * データのみ保持する。\r\n *\r\n * @note 実装は interface ではなく class にしてみる。\r\n * interface だとシリアライズは楽だが、リフレクションが使えない。\r\n */\r\nvar REGame_Attribute = /** @class */ (function () {\r\n    function REGame_Attribute() {\r\n        this.dataId = 0;\r\n    }\r\n    REGame_Attribute.prototype.data = function () {\r\n        return {};\r\n    };\r\n    return REGame_Attribute;\r\n}());\r\nexports.REGame_Attribute = REGame_Attribute;\r\nvar REGame_UnitAttribute = /** @class */ (function (_super) {\r\n    __extends(REGame_UnitAttribute, _super);\r\n    function REGame_UnitAttribute() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this._factionId = 0;\r\n        _this._speedLevel = 1; // 1 が基本, 0は無効値。2は倍速。3は3倍速。-1は鈍足。\r\n        _this._waitTurnCount = 0; // 内部パラメータ。待ち数。次のターン、行動できるかどうか。\r\n        _this._manualMovement = false; // マニュアル操作するかどうか。\r\n        _this._actionTokenCount = 0;\r\n        _this._targetingEntityId = 0; // AIMinor Phase で、攻撃対象を確定したかどうか。以降、Run 内では iterationCount が残っていても MinorAction を行わない\r\n        return _this;\r\n    }\r\n    REGame_UnitAttribute.prototype.factionId = function () { return this._factionId; };\r\n    REGame_UnitAttribute.prototype.setFactionId = function (value) { this._factionId = value; return this; };\r\n    REGame_UnitAttribute.prototype.speedLevel = function () { return this._speedLevel; };\r\n    REGame_UnitAttribute.prototype.setSpeedLevel = function (value) { this._speedLevel = value; return this; };\r\n    REGame_UnitAttribute.prototype.waitTurnCount = function () { return this._waitTurnCount; };\r\n    REGame_UnitAttribute.prototype.setWaitTurnCount = function (value) { this._waitTurnCount = value; return this; };\r\n    REGame_UnitAttribute.prototype.manualMovement = function () { return this._manualMovement; };\r\n    REGame_UnitAttribute.prototype.setManualMovement = function (value) { this._manualMovement = value; return this; };\r\n    REGame_UnitAttribute.prototype.actionTokenCount = function () { return this._actionTokenCount; };\r\n    REGame_UnitAttribute.prototype.setActionTokenCount = function (value) { this._actionTokenCount = value; return this; };\r\n    return REGame_UnitAttribute;\r\n}(REGame_Attribute));\r\nexports.REGame_UnitAttribute = REGame_UnitAttribute;\r\n\n\n//# sourceURL=webpack:///./ts/RE/REGame_Attribute.ts?");

/***/ }),

/***/ "./ts/RE/REGame_Behavior.ts":
/*!**********************************!*\
  !*** ./ts/RE/REGame_Behavior.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/**\r\n *\r\n * [2020/9/29] Behavior の代用\r\n * レンサのワナ、吸収の壺、あくまだんしゃく系\r\n *\r\n *\r\n * @note Attribute と Behavior を分ける必要はあるのか？\r\n * やはり移動がイメージしやすいかな。\r\n * Player, Enemy 共に Position は持つが、それをキー入力で更新するのか、AI で更新するのかは異なる。\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REGame_Behavior = exports.DecisionPhase = void 0;\r\nvar RECommand_1 = __webpack_require__(/*! ../system/RECommand */ \"./ts/system/RECommand.ts\");\r\nvar DecisionPhase;\r\n(function (DecisionPhase) {\r\n    DecisionPhase[DecisionPhase[\"Manual\"] = 0] = \"Manual\";\r\n    DecisionPhase[DecisionPhase[\"AIMinor\"] = 1] = \"AIMinor\";\r\n    DecisionPhase[DecisionPhase[\"AIMajor\"] = 2] = \"AIMajor\";\r\n})(DecisionPhase = exports.DecisionPhase || (exports.DecisionPhase = {}));\r\n// see: 実装FAQ-Command-Behavior.md\r\nvar REGame_Behavior = /** @class */ (function () {\r\n    function REGame_Behavior() {\r\n        this.dataId = 0;\r\n    }\r\n    // Attach されている Behavior や Attribute の状態に依存して変化する情報を取得する。\r\n    // propertyId: see EntityProperties\r\n    // undefined を返した場合は後続の Behavior の onQueryProperty() を呼び出し続ける。\r\n    REGame_Behavior.prototype.onQueryProperty = function (propertyId) { return undefined; };\r\n    // この Behavior が Attach されている Entity に対して送信できる Action を取得する。\r\n    REGame_Behavior.prototype.onQueryActions = function () { return []; };\r\n    REGame_Behavior.prototype.onQueryReactions = function () { return []; };\r\n    // 従来ver は Command 扱いだった。\r\n    // 行動決定に関係する通知は Scheduler から同期的に送られるが、\r\n    // できればこれを RECommandContext.sendCommand みたいに公開したくないので個別定義にしている。\r\n    // また実行内容も onAction などとは少し毛色が違うので、あえて分離してみる。\r\n    REGame_Behavior.prototype.onDecisionPhase = function (entity, context, phase) { return RECommand_1.REResponse.Pass; };\r\n    REGame_Behavior.prototype.onPreAction = function (entity, context, cmd) { return RECommand_1.REResponse.Pass; };\r\n    REGame_Behavior.prototype.onPreReaction = function (entity, context, cmd) { return RECommand_1.REResponse.Pass; };\r\n    REGame_Behavior.prototype.onAction = function (entity, context, cmd) { return RECommand_1.REResponse.Pass; };\r\n    REGame_Behavior.prototype.onReaction = function (entity, context, cmd) { return RECommand_1.REResponse.Pass; };\r\n    REGame_Behavior.prototype.onApplyEffect = function (context) { return RECommand_1.REResponse.Pass; };\r\n    return REGame_Behavior;\r\n}());\r\nexports.REGame_Behavior = REGame_Behavior;\r\n/*\r\n例：聖域の巻物を拾うとき\r\n----------\r\n### player.onPreAction\r\nPlayer に Attach されている Behavior の onPreAction.\r\n自分の状態を元に行動の可否を決める。\r\nもし Player が手封じ状態であれば実行不能。メッセージを表示して Cancel。ターンを消費。\r\n\r\n### item.onPreReaction\r\nItem に Attach されている Behavior の onPreReaction.\r\nもし床に張り付いている状態であれば実行不能。メッセージを表示して Cancel。ターンを消費。\r\n拾うときにアイテムをモンスター化したいとかもここ。\r\n\r\n### player.onAction\r\nItemEntity を Map から取り除き、インベントリに追加する。\r\n持ち物が一杯だった場合はメッセージを表示して Cancel。ターンを消費。\r\n\r\n\r\n\r\n\r\n*/\r\n\n\n//# sourceURL=webpack:///./ts/RE/REGame_Behavior.ts?");

/***/ }),

/***/ "./ts/RE/REGame_Block.ts":
/*!*******************************!*\
  !*** ./ts/RE/REGame_Block.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REGame_Block = exports.TileKind = exports.BlockLayerKind = void 0;\r\nvar RETileAttribute_1 = __webpack_require__(/*! ts/objects/attributes/RETileAttribute */ \"./ts/objects/attributes/RETileAttribute.ts\");\r\nvar Common_1 = __webpack_require__(/*! ts/Common */ \"./ts/Common.ts\");\r\nvar MapDataProvidor_1 = __webpack_require__(/*! ./MapDataProvidor */ \"./ts/RE/MapDataProvidor.ts\");\r\nvar BlockLayerKind;\r\n(function (BlockLayerKind) {\r\n    /** 地形情報。壁・水路など。 */\r\n    BlockLayerKind[BlockLayerKind[\"Terrain\"] = 0] = \"Terrain\";\r\n    /** 地表に落ちているもの。アイテム・ワナ・階段など。 */\r\n    BlockLayerKind[BlockLayerKind[\"Ground\"] = 1] = \"Ground\";\r\n    /** ユニット。PC・仲間・モンスター・土偶など。 */\r\n    BlockLayerKind[BlockLayerKind[\"Unit\"] = 2] = \"Unit\";\r\n    /** 発射物。矢、魔法弾、吹き飛ばされたUnitなど。 */\r\n    BlockLayerKind[BlockLayerKind[\"Projectile\"] = 3] = \"Projectile\";\r\n    /** お店のセキュリティシステムなど、非表示だが Entity として存在するもの。 */\r\n    BlockLayerKind[BlockLayerKind[\"System\"] = 4] = \"System\";\r\n})(BlockLayerKind = exports.BlockLayerKind || (exports.BlockLayerKind = {}));\r\nvar REBlockLayer = /** @class */ (function () {\r\n    function REBlockLayer() {\r\n        // 同一レイヤーに、同時に複数の Entity は存在可能。\r\n        // 例えばシレン2のかまいたちの矢は、発射直後の状態ではすべて同一タイル内に存在する。\r\n        this._entities = [];\r\n    }\r\n    REBlockLayer.prototype.entities = function () {\r\n        return this._entities;\r\n    };\r\n    REBlockLayer.prototype.isContains = function (entity) {\r\n        return this._entities.includes(entity);\r\n    };\r\n    REBlockLayer.prototype.isOccupied = function () {\r\n        return this._entities.some(function (x) { return x.blockOccupied; });\r\n    };\r\n    REBlockLayer.prototype.addEntity = function (entity) {\r\n        this._entities.push(entity);\r\n    };\r\n    REBlockLayer.prototype.removeEntity = function (entity) {\r\n        var index = this._entities.indexOf(entity);\r\n        if (index >= 0) {\r\n            this._entities.splice(index, 1);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    REBlockLayer.prototype.removeAllEntites = function () {\r\n        this._entities.splice(0);\r\n    };\r\n    return REBlockLayer;\r\n}());\r\n/** Tile Entity の性質 */\r\nvar TileKind;\r\n(function (TileKind) {\r\n    /** 中空 */\r\n    TileKind[TileKind[\"Void\"] = 0] = \"Void\";\r\n    /** 床 */\r\n    TileKind[TileKind[\"Floor\"] = 1] = \"Floor\";\r\n    /** 壁 */\r\n    TileKind[TileKind[\"Wall\"] = 2] = \"Wall\";\r\n    /** 壊れない壁 */\r\n    TileKind[TileKind[\"HardWall\"] = 3] = \"HardWall\";\r\n    /** 水路 */\r\n    TileKind[TileKind[\"Water\"] = 4] = \"Water\";\r\n    //\t/** マップの外周の壊せない壁。配列外を示すダミー要素。 */\r\n    //\tBorderWall,\r\n})(TileKind = exports.TileKind || (exports.TileKind = {}));\r\n/**\r\n * GameBlock\r\n *\r\n * GameBlock 自体は単なる入れ物。\r\n * これは、例えば壁堀りなどで Tile への更新通知を特別扱いしないようにするための対策。\r\n * アクション発動側は、壁堀り属性の付いた「攻撃コマンド」を「GameBlock」へ送信するだけでよい。\r\n * GameBlock 内にいるエンティティに順番にコマンドを送っていき、Wall な Block がいたらそれを取り除いたりする。\r\n *\r\n * 階段、壁、Item などを Block の中へ入れていくイメージ。\r\n *\r\n * Block 内の同一レイヤーには、複数の Entity が同時に存在することがありえる。\r\n * 貫通属性を持ち、複数同時発射されれる Projectile など。（シレン2のかまいたちの矢等）\r\n *\r\n * [2020/9/28-2] 「Block から離れるAction」「Blockに入るAction」を分けて考える？\r\n * ----------\r\n * 再考。Block の Entity 化とは別件なので。\r\n *\r\n * タイガーウッホ系の投擲を考えるときは必須になりそう。これはたんなるBlock 間移動では済まない。\r\n * [Block から離れる] は他と共通でいいが、[Blockへ向かって投げる] は他のひまガッパ系と同様のルーチンを使う。\r\n * またはね返しの盾ではね返せるので、必ず先方Blockに着地できないケースも出てくる。\r\n * 一時的に、いずれの Block にも属していないような状態を考える必要がある。\r\n *\r\n * 2段階にすることのメリットは、状態異常からではなく、別 Entity から Unit へ、行動制限等がかけられる、ということ。\r\n * ステートレスなトラップ、というより拡張的なギミックを作るのに利用できる。\r\n *\r\n * 周囲の Block に存在する Unit を束縛するような土偶とかが考えられるか。\r\n * トラバサミ状態ではなく、Unit は自分から土偶を壊すこともできる。壊した瞬間解放されるが、状態異常ではないので、\r\n * Unit に Behavior を Attach/Detach する必要もない。(相手側に状態を持たせる必要がない)\r\n *\r\n * [2020/9/28] Block も Entity としてみる？\r\n * ----------\r\n * ひとまず \"しない\" 方向で行ってみる。\r\n *\r\n * もともとトラバサミの検討中に出てきたアイデアで、「Block から離れるAction」「Blockに入るAction」を分けて考えようとしていた。\r\n * Block 内の地形、アイテム、ワナEntityを Blockの関係 Entity とすることで Command の送信側としては相手が何かを考えず 「blockへpost」すればいいことにしてみたい。\r\n *\r\n * ただこれを実装するとなると、2つの Action が結果の依存関係を持って連続実行されることになるため、\r\n * 最初の Action の結果を 後続に通知する必要がある。\r\n * 今は Command 単位ではその仕組みがあるが、さらに Action 単位でも持たせる必要があり、複雑になる。\r\n *\r\n * Note:\r\n * もしこの仕組みで行く場合、Block は例えば「Block に入る Action」によって送信されてくる onPreReaction, onReaction を、\r\n * \"send\" で関係 Entity に橋渡しする必要がある。\"post\" だと Action4Command の実行順のつじつまが合わなくなるのでNG。\r\n *\r\n * ### 何か拡張 Action を作るときは、Block が Entity になっていた方が便利か？\r\n *\r\n * Unit を捕まえた後投げるような、シレン2のタイガーウッホ系を考えてみる。\r\n * 特技によって Unit を任意の Block に「落とす」Action が必要になってくるが、この時の reactor を検索する処理が、Enemyの Behavior 側に必要となる。\r\n * Behavior 側に定型的な処理がたくさん書かれることになるので、Block に対して postAction 出来ればかなり楽なのだが…。\r\n *\r\n * ただこれは、「reactor が何かは考えずにとりあえず Block に対して post したい」ケースがほとんどなので、\r\n * reactor を指定しない postActionToBlock とかを作ってもいいかもしれない。\r\n *\r\n *\r\n * [2020/9/6] Layer\r\n * ----------\r\n * - アイテムとキャラクターは同じマスの上に乗ることができる。\r\n * - キャラクターがすり抜け状態であれば、壁Entityと同じマスに乗ることができる。\r\n * - アイテム・ワナ・階段は同じマスの上に乗ることはできない。\r\n * - キャラクター・土偶は同じマスに乗ることはできない。\r\n * - アイテムや階段は壁に埋まった状態で存在できる。（埋蔵金・黄金の階段）\r\n * 単純に BlockOccupierAttribute で他 Entity を侵入できないようにするだけでは足りない。グループ化の仕組みが必要。\r\n * また攻撃 Action などは基本的に、Block 内に複数の Entity がある場合は「上」から処理していく。\r\n * 例えば、アイアンハンマーを装備して、ワナの上にいるモンスターに攻撃すると、ワナは壊れずモンスターにダメージが行く。\r\n * 単純に Entity のリストを持っているだけだと、並べ替えなどを考慮しなければならなくなる。\r\n * これらをグループ化するために、Layer という仕組みを使ってみる。\r\n *\r\n * - 主に SafetyArea においてマップ移動や通行禁止の Event を、\"すり抜け\" 属性 ON で置けるようにするため、ひとつの Layer には複数の Entity が入れる。\r\n *\r\n * [2020/9/6] 壁も Entity にしたほうがいいの？\r\n * ----------\r\n * しておいた方がいろいろ拡張しやすい。\r\n * 例えば自動修復する壁とかも作れる。\r\n * elona みたいに固定マップの壊した壁が一定時間すると復活するようなものを実装するには必要になる。\r\n *\r\n */\r\nvar REGame_Block = /** @class */ (function () {\r\n    function REGame_Block(map, x, y) {\r\n        this._x = x;\r\n        this._y = y;\r\n        this._layers = [new REBlockLayer(), new REBlockLayer(), new REBlockLayer(), new REBlockLayer(), new REBlockLayer()];\r\n    }\r\n    REGame_Block.prototype.x = function () {\r\n        return this._x;\r\n    };\r\n    REGame_Block.prototype.y = function () {\r\n        return this._y;\r\n    };\r\n    REGame_Block.prototype.tileIds = function () {\r\n        return this._tileIds;\r\n    };\r\n    REGame_Block.prototype.setTileIds = function (tileIds) {\r\n        this._tileIds = tileIds;\r\n        MapDataProvidor_1.MapDataProvidor.onUpdateBlock(this);\r\n    };\r\n    REGame_Block.prototype.tile = function () {\r\n        return this._layers[BlockLayerKind.Terrain].entities()[0];\r\n    };\r\n    REGame_Block.prototype.tileKind = function () {\r\n        var attr = this.tile().findAttribute(RETileAttribute_1.RETileAttribute);\r\n        return attr ? attr.tileKind() : TileKind.Void;\r\n    };\r\n    REGame_Block.prototype.layers = function () {\r\n        return this._layers;\r\n    };\r\n    REGame_Block.prototype.layer = function (kind) {\r\n        return this._layers[kind];\r\n    };\r\n    REGame_Block.prototype.addEntity = function (layerKind, entity) {\r\n        var layer = this._layers[layerKind];\r\n        Common_1.assert(!layer.isContains(entity)); // 複数追加禁止\r\n        Common_1.assert(!layer.isOccupied()); // 既に占有されている時は追加禁止\r\n        if (layerKind == BlockLayerKind.Terrain) {\r\n            // Tile Layer への複数追加は禁止\r\n            Common_1.assert(this._layers[layerKind].entities().length == 0);\r\n        }\r\n        layer.addEntity(entity);\r\n    };\r\n    REGame_Block.prototype.removeEntity = function (entity) {\r\n        for (var i = 0; i < this._layers.length; i++) {\r\n            if (this._layers[i].removeEntity(entity)) {\r\n                return;\r\n            }\r\n        }\r\n    };\r\n    REGame_Block.prototype.removeAllEntites = function () {\r\n        for (var i = 0; i < this._layers.length; i++) {\r\n            this._layers[i].removeAllEntites();\r\n        }\r\n    };\r\n    return REGame_Block;\r\n}());\r\nexports.REGame_Block = REGame_Block;\r\n\n\n//# sourceURL=webpack:///./ts/RE/REGame_Block.ts?");

/***/ }),

/***/ "./ts/RE/REGame_Core.ts":
/*!******************************!*\
  !*** ./ts/RE/REGame_Core.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REGame_Core = void 0;\r\nvar REGame_Core = /** @class */ (function () {\r\n    function REGame_Core() {\r\n        // experimental: \"場所移動\" 等の基準となる、メインプレイヤーの Entity.\r\n        // もし仲間がいるような場合、MainPlayerEntity がマップ移動したらついてきたりする。\r\n        this.mainPlayerEntiyId = 0;\r\n    }\r\n    return REGame_Core;\r\n}());\r\nexports.REGame_Core = REGame_Core;\r\n\n\n//# sourceURL=webpack:///./ts/RE/REGame_Core.ts?");

/***/ }),

/***/ "./ts/RE/REGame_Entity.ts":
/*!********************************!*\
  !*** ./ts/RE/REGame_Entity.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REGame_Entity = void 0;\r\nvar RECommand_1 = __webpack_require__(/*! ../system/RECommand */ \"./ts/system/RECommand.ts\");\r\nvar RESystem_1 = __webpack_require__(/*! ts/system/RESystem */ \"./ts/system/RESystem.ts\");\r\nvar BlockLayer;\r\n(function (BlockLayer) {\r\n    /** 地形情報。壁・水路など。 */\r\n    BlockLayer[BlockLayer[\"Terrain\"] = 0] = \"Terrain\";\r\n    /** 地表に落ちているもの。アイテム・ワナ・階段など。 */\r\n    BlockLayer[BlockLayer[\"Surface\"] = 1] = \"Surface\";\r\n    /** ユニット。PC・仲間・モンスター・土偶など。 */\r\n    BlockLayer[BlockLayer[\"Unit\"] = 2] = \"Unit\";\r\n    /** 発射物。矢、魔法弾、吹き飛ばされたUnitなど。 */\r\n    BlockLayer[BlockLayer[\"Projectile\"] = 3] = \"Projectile\";\r\n})(BlockLayer || (BlockLayer = {}));\r\n/**\r\n * システムを構成する最も原始的な要素。\r\n * プレイヤー、仲間、モンスター、アイテム、ワナ、地形、飛翔体（矢、魔法弾）などの、状態をもちえるすべての要素のベースクラス。\r\n *\r\n * 複数の Attribute や Behavior をアタッチすることで、動作を定義していく。\r\n *\r\n * Entity のライフサイクル\r\n * ----------\r\n * - インスタンスの作成は newEntity() で行う。\r\n *   - すべての Entity は必ず World に存在することになる。\r\n * - 破棄は destroy()。 ※直ちにインスタンスが削除されるのではなく、削除マークが付けられ、後で削除される。\r\n *\r\n * @note\r\n * BlockLayer は種別のような他の情報から求めるべきかもしれないが、Entity によっては固定されることは無い。\r\n * - アイテム変化するモンスターは自身の種別を変更することになるが、それだと BlockLayer を変更することと変わらない。\r\n * - アイテムとして持っている土偶を立てたときは、振舞いは Item から Unit に変わる。これも結局状態変更することと変わらない。\r\n */\r\nvar REGame_Entity = /** @class */ (function () {\r\n    function REGame_Entity() {\r\n        this.attrbutes = [];\r\n        this._basicBehaviors = []; // Entity 生成時にセットされる基本 Behavior. Entity 破棄まで変更されることは無い。\r\n        //private _adhocBehaviors: REGame_Behavior[] = [];    // 実行中にセットされる Behavior. 状態異常などで、基本とは異なる振る舞いをするときにセットされる。\r\n        this._states = [];\r\n        this._id = 0;\r\n        this._name = \"\"; // 主にデバッグ用\r\n        this._destroyed = false;\r\n        // HC3 で作ってた CommonAttribute はこっちに持ってきた。\r\n        // これらは Entity ごとに一意であるべきで、Framework が必要としている必須パラメータ。\r\n        // Attribute よりはこっちに置いた方がいいだろう。\r\n        this._displayName = '';\r\n        this._iconName = '';\r\n        this._blockLayer = BlockLayer.Unit;\r\n        this.prefabKey = { kind: 0, id: 0 };\r\n        this.rmmzEventId = 0;\r\n        // HC3 までは PositionalAttribute に持たせていたが、こっちに持ってきた。\r\n        // お店のセキュリティシステムなど、これらを使わない Entity もあるのだが、\r\n        // ほとんどの Entity が持つことになるパラメータなので、Attribute にするとコードが複雑になりすぎる。\r\n        this.floorId = 0; /**< Entity が存在しているフロア。0 は無効値 & 異常値。直接変更禁止。transfarMap を使うこと */\r\n        this.x = 0; /**< 論理 X 座標 */\r\n        this.y = 0; /**< 論理 Y 座標 */\r\n        //--------------------\r\n        // 以下、一時的に Entity に直接持たせてる Attr. 利用率とかで、別途 Attr クラスに分けたりする。\r\n        this.dir = 4; // Numpad Dir\r\n        // Block を占有するかどうか\r\n        this.blockOccupied = true;\r\n        // 隣接移動直後の DialogOpend かどうか。\r\n        // 階段などの Entity に対しては足元コマンドを自動表示したりする。\r\n        // ユーザビリティのためだけに参照する点に注意。セーブデータをロードした直後はウィンドウを表示したりしたくないので、セーブデータに含まれる。\r\n        this.immediatelyAfterAdjacentMoving = false;\r\n    }\r\n    //static newEntity(): REGame_Entity {\r\n    //    const e = new REGame_Entity();\r\n    //    REGame.world._addEntity(e);\r\n    //    return e;\r\n    //}\r\n    REGame_Entity.prototype.id = function () {\r\n        return this._id;\r\n    };\r\n    REGame_Entity.prototype.addAttribute = function (value) {\r\n        this.attrbutes.push(value);\r\n        return this;\r\n    };\r\n    REGame_Entity.prototype.basicBehaviors = function () {\r\n        return this._basicBehaviors;\r\n    };\r\n    REGame_Entity.prototype.addBasicBehavior = function (value) {\r\n        this._basicBehaviors.unshift(value);\r\n    };\r\n    //addAdhocBehavior(value: REGame_Behavior) {\r\n    //    this._adhocBehaviors.unshift(value);\r\n    //}\r\n    REGame_Entity.prototype.addBehavior = function (value) {\r\n        this._basicBehaviors.unshift(value);\r\n    };\r\n    REGame_Entity.prototype.removeBehavior = function (value) {\r\n        var index = this._basicBehaviors.findIndex(function (x) { return x == value; });\r\n        if (index >= 0)\r\n            this._basicBehaviors.splice(index, 1);\r\n    };\r\n    REGame_Entity.prototype.addState = function (value) {\r\n        this._states.unshift(value);\r\n    };\r\n    REGame_Entity.prototype.removeState = function (value) {\r\n        var index = this._states.findIndex(function (x) { return x == value; });\r\n        if (index >= 0)\r\n            this._states.splice(index, 1);\r\n    };\r\n    /**\r\n     * 動的に生成した Game_Event が参照する EventData.\r\n     * 頻繁にアクセスされる可能性があるので Attribute ではなくこちらに持たせている。\r\n     */\r\n    //eventData(): IDataMapEvent | undefined {\r\n    //    return this._eventData;\r\n    //}\r\n    REGame_Entity.prototype.isDestroyed = function () {\r\n        return this._destroyed;\r\n    };\r\n    REGame_Entity.prototype.destroy = function () {\r\n        this._destroyed = true;\r\n    };\r\n    REGame_Entity.prototype.findAttribute = function (ctor) {\r\n        for (var i = 0; i < this.attrbutes.length; i++) {\r\n            var a = this.attrbutes[i];\r\n            if (a instanceof ctor) {\r\n                return a;\r\n            }\r\n        }\r\n        return undefined;\r\n        /*\r\n        const r = this.attrbutes.find(x => x.constructor.toString() === Text.name);\r\n        if (r)\r\n            return r as unknown as T;\r\n        else\r\n            return undefined;\r\n            */\r\n    };\r\n    REGame_Entity.prototype.queryProperty = function (propertyId) {\r\n        for (var i = 0; i < this._basicBehaviors.length; i++) {\r\n            var value = this._basicBehaviors[i].onQueryProperty(propertyId);\r\n            if (value !== undefined) {\r\n                return value;\r\n            }\r\n        }\r\n        return RESystem_1.RESystem.propertyData[propertyId].defaultValue;\r\n    };\r\n    REGame_Entity.prototype.queryActions = function () {\r\n        var result = []; // TODO: あとで flatMap() 使うようにしたい\r\n        for (var i = 0; i < this._basicBehaviors.length; i++) {\r\n            result = result.concat(this._basicBehaviors[i].onQueryActions());\r\n        }\r\n        return result;\r\n    };\r\n    REGame_Entity.prototype.queryReactions = function () {\r\n        var result = []; // TODO: あとで flatMap() 使うようにしたい\r\n        for (var i = 0; i < this._basicBehaviors.length; i++) {\r\n            result = result.concat(this._basicBehaviors[i].onQueryReactions());\r\n        }\r\n        return result;\r\n    };\r\n    REGame_Entity.prototype._callBehaviorIterationHelper = function (func) {\r\n        for (var i = 0; i < this._basicBehaviors.length; i++) {\r\n            var r = func(this._basicBehaviors[i]); //this._behaviors[i].onPreAction(cmd);\r\n            if (r != RECommand_1.REResponse.Pass) {\r\n                return r;\r\n            }\r\n        }\r\n        return RECommand_1.REResponse.Pass;\r\n    };\r\n    REGame_Entity.prototype._callStateIterationHelper = function (func) {\r\n        for (var i = 0; i < this._states.length; i++) {\r\n            var r = func(this._states[i]);\r\n            if (r != RECommand_1.REResponse.Pass) {\r\n                return r;\r\n            }\r\n        }\r\n        return RECommand_1.REResponse.Pass;\r\n    };\r\n    REGame_Entity.prototype._callDecisionPhase = function (context, phase) {\r\n        var _this = this;\r\n        var r = this._callStateIterationHelper(function (x) { return x.onDecisionPhase(_this, context, phase); });\r\n        if (r != RECommand_1.REResponse.Pass)\r\n            return r;\r\n        return this._callBehaviorIterationHelper(function (x) { return x.onDecisionPhase(_this, context, phase); });\r\n    };\r\n    REGame_Entity.prototype._sendPreAction = function (context, cmd) {\r\n        var _this = this;\r\n        return this._callBehaviorIterationHelper(function (x) { return x.onPreAction(_this, context, cmd); });\r\n    };\r\n    REGame_Entity.prototype._sendPreRection = function (context, cmd) {\r\n        var _this = this;\r\n        return this._callBehaviorIterationHelper(function (x) { return x.onPreReaction(_this, context, cmd); });\r\n    };\r\n    REGame_Entity.prototype._sendAction = function (context, cmd) {\r\n        var _this = this;\r\n        return this._callBehaviorIterationHelper(function (x) { return x.onAction(_this, context, cmd); });\r\n    };\r\n    REGame_Entity.prototype._sendReaction = function (context, cmd) {\r\n        var _this = this;\r\n        return this._callBehaviorIterationHelper(function (x) { return x.onReaction(_this, context, cmd); });\r\n    };\r\n    REGame_Entity.prototype.makeSaveContents = function () {\r\n        var contents = {};\r\n        contents.id = this._id;\r\n        contents.floorId = this.floorId;\r\n        contents.x = this.x;\r\n        contents.y = this.y;\r\n        contents.attrbutes = this.attrbutes;\r\n        contents.behaviors = this._basicBehaviors.map(function (x) { return x.dataId; });\r\n        return contents;\r\n    };\r\n    REGame_Entity.prototype.extractSaveContents = function (contents) {\r\n        this._id = contents.id;\r\n        this.floorId = contents.floorId;\r\n        this.x = contents.x;\r\n        this.y = contents.y;\r\n        this.attrbutes = contents.attrbutes.map(function (x) {\r\n            var i = RESystem_1.RESystem.createAttribute(x.dataId);\r\n            Object.assign(i, x);\r\n            return i;\r\n        });\r\n        this._basicBehaviors = contents.behaviors.map(function (x) {\r\n            return RESystem_1.RESystem.createBehavior(x);\r\n        });\r\n    };\r\n    return REGame_Entity;\r\n}());\r\nexports.REGame_Entity = REGame_Entity;\r\n\n\n//# sourceURL=webpack:///./ts/RE/REGame_Entity.ts?");

/***/ }),

/***/ "./ts/RE/REGame_Map.ts":
/*!*****************************!*\
  !*** ./ts/RE/REGame_Map.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REGame_Map = void 0;\r\nvar Common_1 = __webpack_require__(/*! ../Common */ \"./ts/Common.ts\");\r\nvar REGame_Block_1 = __webpack_require__(/*! ./REGame_Block */ \"./ts/RE/REGame_Block.ts\");\r\nvar REData_1 = __webpack_require__(/*! ../data/REData */ \"./ts/data/REData.ts\");\r\nvar REGame_1 = __webpack_require__(/*! ./REGame */ \"./ts/RE/REGame.ts\");\r\nvar REMapBuilder_1 = __webpack_require__(/*! ../system/REMapBuilder */ \"./ts/system/REMapBuilder.ts\");\r\nvar REEntityFactory_1 = __webpack_require__(/*! ../system/REEntityFactory */ \"./ts/system/REEntityFactory.ts\");\r\nvar Helpers_1 = __webpack_require__(/*! ts/system/Helpers */ \"./ts/system/Helpers.ts\");\r\nvar RESystem_1 = __webpack_require__(/*! ts/system/RESystem */ \"./ts/system/RESystem.ts\");\r\n/**\r\n * アクティブなマップオブジェクト。インスタンスは1つだけ存在する。\r\n *\r\n * Map 遷移が行われたとき、World に存在する Entity のうち、\r\n * この Map 上にいることになっている Entity は、自動的に追加される。\r\n *\r\n * このクラスのメソッドによる登場や移動は Sequel を伴わない。そういったものは Command 処理側で対応すること。\r\n */\r\nvar REGame_Map = /** @class */ (function () {\r\n    function REGame_Map() {\r\n        this._floorId = 0;\r\n        this._width = 0;\r\n        this._height = 0;\r\n        this._blocks = [];\r\n        this._entityIds = []; // マップ内に登場している Entity\r\n        this._adhocEntityIds = [];\r\n        this._borderWall = new REGame_Block_1.REGame_Block(this, -1, -1); // マップ有効範囲外に存在するダミー要素\r\n    }\r\n    REGame_Map.prototype.setup = function (floorId) {\r\n        Common_1.assert(this._entityIds.length == 0);\r\n        this._floorId = floorId;\r\n        var builder = new REMapBuilder_1.REMapBuilder(this);\r\n        RESystem_1.RESystem.integration.onLoadFixedMap(builder);\r\n    };\r\n    REGame_Map.prototype.setupEmptyMap = function (width, height) {\r\n        Common_1.assert(this._entityIds.length == 0); // 外部で releaseMap してから setup すること\r\n        Common_1.assert(this._adhocEntityIds.length == 0); // 外部で releaseMap してから setup すること\r\n        this._width = width;\r\n        this._height = height;\r\n        var count = this._width * this._height;\r\n        this._blocks = new Array(count);\r\n        for (var i = 0; i < count; i++) {\r\n            this._blocks[i] = new REGame_Block_1.REGame_Block(this, i % this._width, i / this._width);\r\n            // TileEntity 追加\r\n            var tile = REEntityFactory_1.REEntityFactory.newTile(REGame_Block_1.TileKind.Floor);\r\n            tile.floorId = this._floorId;\r\n            this.markAdhocEntity(tile);\r\n            this._addEntity(tile);\r\n            this._blocks[i].addEntity(REGame_Block_1.BlockLayerKind.Terrain, tile);\r\n        }\r\n    };\r\n    REGame_Map.prototype.releaseMap = function () {\r\n        this.destroyAdhocEntities();\r\n        this._removeAllEntities();\r\n        this._width = 0;\r\n        this._height = 0;\r\n        this._blocks = [];\r\n    };\r\n    REGame_Map.prototype.isValid = function () {\r\n        return this._width > 0;\r\n    };\r\n    REGame_Map.prototype.floorId = function () {\r\n        return this._floorId;\r\n    };\r\n    REGame_Map.prototype.width = function () {\r\n        return this._width;\r\n    };\r\n    REGame_Map.prototype.height = function () {\r\n        return this._height;\r\n    };\r\n    REGame_Map.prototype.isFixedMap = function () {\r\n        var _a;\r\n        return ((_a = REData_1.REData.floors[this._floorId]) === null || _a === void 0 ? void 0 : _a.mapKind) == REData_1.REFloorMapKind.FixedMap;\r\n    };\r\n    REGame_Map.prototype.isRandomMap = function () {\r\n        var _a;\r\n        return ((_a = REData_1.REData.floors[this._floorId]) === null || _a === void 0 ? void 0 : _a.mapKind) == REData_1.REFloorMapKind.RandomMap;\r\n    };\r\n    REGame_Map.prototype.block = function (x, y) {\r\n        if (x < 0 || this._width <= x || y < 0 || this._height <= y) {\r\n            return this._borderWall;\r\n        }\r\n        else {\r\n            return this._blocks[y * this._width + x];\r\n        }\r\n    };\r\n    REGame_Map.prototype.entities = function () {\r\n        return this._entityIds\r\n            .map(function (id) { return REGame_1.REGame.world.entity(id); })\r\n            .filter(function (e) { return e != undefined; });\r\n    };\r\n    REGame_Map.prototype._addEntity = function (entity) {\r\n        // 新規で追加するほか、マップロード時に、そのマップに存在することになっている Entity の追加でも使うので、\r\n        // floorId は外部で設定済みであることを前提とする。\r\n        Common_1.assert(entity.floorId == this.floorId());\r\n        Common_1.assert(entity._id > 0);\r\n        this._entityIds.push(entity._id);\r\n        RESystem_1.RESystem.integration.onEntityEnteredMap(entity);\r\n    };\r\n    REGame_Map.prototype._removeEntity = function (entity) {\r\n        Common_1.assert(entity.floorId == this.floorId());\r\n        this._entityIds = this._entityIds.filter(function (x) { return x != entity._id; });\r\n        entity.floorId = 0;\r\n        RESystem_1.RESystem.integration.onEntityLeavedMap(entity);\r\n    };\r\n    /** エンティティを、このマップのみの AdhocEntity としてマークする */\r\n    REGame_Map.prototype.markAdhocEntity = function (entity) {\r\n        this._adhocEntityIds.push(entity.id());\r\n    };\r\n    REGame_Map.prototype.destroyAdhocEntities = function () {\r\n        this._adhocEntityIds.forEach(function (x) {\r\n            REGame_1.REGame.world.entity(x).destroy();\r\n        });\r\n        this._adhocEntityIds = [];\r\n    };\r\n    REGame_Map.prototype._removeAllEntities = function () {\r\n        this._entityIds.forEach(function (x) {\r\n            var entity = REGame_1.REGame.world.entity(x);\r\n            entity.floorId = 0;\r\n            RESystem_1.RESystem.integration.onEntityLeavedMap(entity);\r\n        });\r\n        this._entityIds = [];\r\n    };\r\n    REGame_Map.prototype.canEntering = function (block, entity, layer) {\r\n        // TODO: 壁抜けや浮遊状態で変わる\r\n        return !block.layers()[layer].isOccupied() && block.tileKind() == REGame_Block_1.TileKind.Floor;\r\n    };\r\n    REGame_Map.prototype.canLeaving = function (block, entity) {\r\n        // TODO: 壁抜けや浮遊状態で変わる\r\n        return /*!block->isOccupied() &&*/ block.tileKind() == REGame_Block_1.TileKind.Floor;\r\n    };\r\n    REGame_Map.prototype.checkPassage = function (entity, dir, toLayer) {\r\n        var offset = Helpers_1.Helpers.dirToTileOffset(dir);\r\n        var oldBlock = this.block(entity.x, entity.y);\r\n        var newBlock = this.block(entity.x + offset.x, entity.y + offset.y);\r\n        var layer = (toLayer) ? toLayer : entity.queryProperty(RESystem_1.RESystem.properties.homeLayer);\r\n        if (this.canLeaving(oldBlock, entity) && this.canEntering(newBlock, entity, layer)) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * 移動可能判定を伴うタイル間移動\r\n     *\r\n     * 指定位置の Block と Entity のみをもとに、移動可否判定を行いつつ移動する。\r\n     *\r\n     * 他の Entity から移動の割り込みを受けるようなケースでは、moveEntity() の呼び出し元の Command ハンドリング側で対応すること。\r\n     */\r\n    REGame_Map.prototype.moveEntity = function (entity, x, y, toLayer) {\r\n        Common_1.assert(entity.floorId == this.floorId());\r\n        var oldBlock = this.block(entity.x, entity.y);\r\n        var newBlock = this.block(x, y);\r\n        if (this.canLeaving(oldBlock, entity) && this.canEntering(newBlock, entity, toLayer)) {\r\n            oldBlock.removeEntity(entity);\r\n            entity.x = x;\r\n            entity.y = y;\r\n            newBlock.addEntity(toLayer, entity);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * Entity の位置設定\r\n     *\r\n     * moveEntity() と異なり、移動可能判定を行わずに強制移動する。\r\n     * マップ生成時の Entity 配置や、ワープ移動などで使用する。\r\n     */\r\n    REGame_Map.prototype.locateEntity = function (entity, x, y, toLayer) {\r\n        Common_1.assert(entity.floorId == this.floorId());\r\n        var oldBlock = this.block(entity.x, entity.y);\r\n        var newBlock = this.block(x, y);\r\n        var layer = (toLayer) ? toLayer : entity.queryProperty(RESystem_1.RESystem.properties.homeLayer);\r\n        oldBlock.removeEntity(entity);\r\n        entity.x = x;\r\n        entity.y = y;\r\n        newBlock.addEntity(layer, entity);\r\n    };\r\n    return REGame_Map;\r\n}());\r\nexports.REGame_Map = REGame_Map;\r\n\n\n//# sourceURL=webpack:///./ts/RE/REGame_Map.ts?");

/***/ }),

/***/ "./ts/RE/REGame_Sequel.ts":
/*!********************************!*\
  !*** ./ts/RE/REGame_Sequel.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RESequelSet = exports.RESequelRun = exports.RESequelClip = exports.REGame_Sequel = void 0;\r\nvar Common_1 = __webpack_require__(/*! ts/Common */ \"./ts/Common.ts\");\r\nvar REData_1 = __webpack_require__(/*! ../data/REData */ \"./ts/data/REData.ts\");\r\n/**\r\n * Sequel\r\n *\r\n * Sequel 個別にデータを持たせたいときに利用予定 (継承よりはフィールドに持たせた方がいいかも)\r\n */\r\nvar REGame_Sequel = /** @class */ (function () {\r\n    function REGame_Sequel(entity, sequelId) {\r\n        this._entity = entity;\r\n        this._sequelId = sequelId;\r\n        this._parallel = REData_1.REData.sequels[this._sequelId].parallel;\r\n    }\r\n    REGame_Sequel.prototype.entity = function () {\r\n        return this._entity;\r\n    };\r\n    REGame_Sequel.prototype.sequelId = function () {\r\n        return this._sequelId;\r\n    };\r\n    REGame_Sequel.prototype.data = function () {\r\n        return REData_1.REData.sequels[this._sequelId];\r\n    };\r\n    REGame_Sequel.prototype.isParallel = function () {\r\n        return this._parallel;\r\n    };\r\n    return REGame_Sequel;\r\n}());\r\nexports.REGame_Sequel = REGame_Sequel;\r\n/**\r\n * ある Entity に連続適用する Sequel のリスト。\r\n *\r\n * 倍速移動などで、複数の Sequel が追加されることがある。\r\n */\r\nvar RESequelClip = /** @class */ (function () {\r\n    function RESequelClip(firstItem) {\r\n        this._sequels = [firstItem];\r\n    }\r\n    RESequelClip.prototype.sequels = function () {\r\n        return this._sequels;\r\n    };\r\n    RESequelClip.prototype.entity = function () {\r\n        return this._sequels[0].entity();\r\n    };\r\n    RESequelClip.prototype.isParallel = function () {\r\n        return this._sequels[0].isParallel();\r\n    };\r\n    RESequelClip.prototype.add = function (sequel) {\r\n        this._sequels.push(sequel);\r\n    };\r\n    return RESequelClip;\r\n}());\r\nexports.RESequelClip = RESequelClip;\r\n/**\r\n * 並列実行の単位。同時実行できる RESequelClip はまとめてひとつの SequelRun に属する。\r\n */\r\nvar RESequelRun = /** @class */ (function () {\r\n    function RESequelRun(firstItem) {\r\n        this._clips = [new RESequelClip(firstItem)];\r\n    }\r\n    RESequelRun.prototype.clips = function () {\r\n        return this._clips;\r\n    };\r\n    RESequelRun.prototype.isParallel = function () {\r\n        return this._clips[0].isParallel();\r\n    };\r\n    RESequelRun.prototype.add = function (sequel) {\r\n        Common_1.assert(sequel.isParallel() == this.isParallel());\r\n        var index = this._clips.findIndex(function (x) { return x.entity() == sequel.entity(); });\r\n        if (index < 0) {\r\n            this._clips.push(new RESequelClip(sequel));\r\n        }\r\n        else {\r\n            this._clips[index].add(sequel);\r\n        }\r\n    };\r\n    return RESequelRun;\r\n}());\r\nexports.RESequelRun = RESequelRun;\r\n/**\r\n * 一連のコマンドチェーン内で発生した Sequel を、並列実行などを考慮して整理して保持する。\r\n * その後 Visual レイヤーに渡り、アニメーションが実行される。\r\n */\r\nvar RESequelSet = /** @class */ (function () {\r\n    function RESequelSet() {\r\n        this._runs = [];\r\n        this._allParallel = true;\r\n        this._isEmpty = true;\r\n    }\r\n    RESequelSet.prototype.runs = function () {\r\n        return this._runs;\r\n    };\r\n    RESequelSet.prototype.isAllParallel = function () {\r\n        return this._allParallel;\r\n    };\r\n    RESequelSet.prototype.isEmpty = function () {\r\n        return this._isEmpty;\r\n    };\r\n    RESequelSet.prototype.reset = function () {\r\n        this._runs.splice(0);\r\n        this._allParallel = true;\r\n        this._isEmpty = true;\r\n    };\r\n    RESequelSet.prototype.addSequel = function (sequel) {\r\n        var newRun = false;\r\n        if (this._runs.length == 0) {\r\n            // 初回\r\n            newRun = true;\r\n        }\r\n        else if (!sequel.isParallel()) {\r\n            // 並列実行しないものは新しい Run へ追加する\r\n            newRun = true;\r\n        }\r\n        else {\r\n            var lastRun = this._runs[this._runs.length - 1];\r\n            if (!lastRun.isParallel()) {\r\n                // 並列 Sequel を追加しようとしたが、追加済みの終端は非並列だった。\r\n                // 新しい Run へ追加する。\r\n                newRun = true;\r\n            }\r\n            else {\r\n                // 並列 Sequel が連続\r\n            }\r\n        }\r\n        if (newRun) {\r\n            this._runs.push(new RESequelRun(sequel));\r\n        }\r\n        else {\r\n            this._runs[this._runs.length - 1].add(sequel);\r\n        }\r\n        if (!sequel.isParallel()) {\r\n            this._allParallel = false;\r\n        }\r\n        this._isEmpty = false;\r\n    };\r\n    return RESequelSet;\r\n}());\r\nexports.RESequelSet = RESequelSet;\r\n\n\n//# sourceURL=webpack:///./ts/RE/REGame_Sequel.ts?");

/***/ }),

/***/ "./ts/RE/REGame_World.ts":
/*!*******************************!*\
  !*** ./ts/RE/REGame_World.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RE_Game_World = void 0;\r\nvar REGame_Entity_1 = __webpack_require__(/*! ./REGame_Entity */ \"./ts/RE/REGame_Entity.ts\");\r\nvar REGame_1 = __webpack_require__(/*! ./REGame */ \"./ts/RE/REGame.ts\");\r\nvar Random_1 = __webpack_require__(/*! ts/math/Random */ \"./ts/math/Random.ts\");\r\n/**\r\n * 1ゲーム内に1インスタンス存在する。\r\n */\r\nvar RE_Game_World = /** @class */ (function () {\r\n    function RE_Game_World() {\r\n        this._entities = [];\r\n        this._random = new Random_1.Random(Math.floor(Math.random() * 65535) + 1);\r\n        var e = this.spawnEntity(); // [0] dummy entity\r\n        e._name = \"null\";\r\n    }\r\n    RE_Game_World.prototype.entity = function (id) {\r\n        var e = this._entities[id];\r\n        if (e)\r\n            return e;\r\n        else\r\n            throw new Error(\"Invalid entity. id:\" + id);\r\n    };\r\n    RE_Game_World.prototype.random = function () {\r\n        return this._random;\r\n    };\r\n    /**\r\n     * 新しい Entity を World 内に生成する。\r\n     *\r\n     * 生成された Entity はいずれの Floor にも属さない状態となっている。\r\n     * 出現させるには transfarEntity() を呼び出す必要がある。\r\n     */\r\n    RE_Game_World.prototype.spawnEntity = function () {\r\n        var entity = new REGame_Entity_1.REGame_Entity();\r\n        this._registerEntity(entity);\r\n        return entity;\r\n    };\r\n    RE_Game_World.prototype._registerEntity = function (entity) {\r\n        // TODO: 空き場所を愚直に線形探索。\r\n        // 大量の Entity を扱うようになったら最適化する。\r\n        var index = this._entities.findIndex(function (x, i) { return i > 0 && x == undefined; });\r\n        if (index < 0) {\r\n            entity._id = this._entities.length;\r\n            this._entities.push(entity);\r\n        }\r\n        else {\r\n            entity._id = index;\r\n            this._entities[index] = entity;\r\n        }\r\n    };\r\n    /**\r\n     * Entity を指定した位置に移動する。\r\n     * - 現在表示中のマップへ移動した場合、そのマップへ登場する。\r\n     *   - 移動先の同一 BlockLayer に別の Entity がいた場合、移動は失敗する。\r\n     * - 表示中以外のマップ(固定マップ)へ移動した場合、\r\n     *   - 移動先の同一 BlockLayer に別の Entity がいた場合、移動は失敗する。\r\n     * - 表示中以外のマップ(ランダムマップ)へ移動した場合、\r\n     *   - 座標は常に 0,0 へ移動し、成功する。ほかの Entity とは重なるが、ランダムマップ生成時に再配置される。\r\n     */\r\n    RE_Game_World.prototype._transfarEntity = function (entity, floorId, x, y) {\r\n        if (REGame_1.REGame.map.floorId() != floorId && REGame_1.REGame.map.floorId() == entity.floorId) {\r\n            // 現在マップからの離脱\r\n            REGame_1.REGame.map._removeEntity(entity);\r\n        }\r\n        if (REGame_1.REGame.map.floorId() == floorId) {\r\n            // 現在表示中のマップへの移動\r\n            entity.floorId = floorId;\r\n            REGame_1.REGame.map._addEntity(entity);\r\n            REGame_1.REGame.map.locateEntity(entity, x, y);\r\n        }\r\n        else {\r\n            entity.floorId = floorId;\r\n            entity.x = x;\r\n            entity.y = y;\r\n        }\r\n        // Camera が注視している Entity が別マップへ移動したら、マップ遷移\r\n        if (REGame_1.REGame.camera.focusedEntityId() == entity.id() &&\r\n            REGame_1.REGame.map.floorId() != entity.floorId) {\r\n            REGame_1.REGame.camera.reserveFloorTransferToFocusedEntity();\r\n        }\r\n        return true;\r\n    };\r\n    RE_Game_World.prototype.update = function () {\r\n        console.log(\"_removeDestroyesEntities\");\r\n        this._removeDestroyesEntities();\r\n    };\r\n    RE_Game_World.prototype._removeDestroyesEntities = function () {\r\n        for (var i = 0; i < this._entities.length; i++) {\r\n            var entity = this._entities[i];\r\n            if (entity && entity.isDestroyed()) {\r\n                this._entities[i] = undefined;\r\n                if (REGame_1.REGame.camera.focusedEntityId() == entity._id) {\r\n                    REGame_1.REGame.camera.clearFocus();\r\n                }\r\n            }\r\n        }\r\n    };\r\n    // 現在の Map(Floor) に存在するべき Entity を、Map に登場 (追加) させる\r\n    RE_Game_World.prototype.enterEntitiesToCurrentMap = function () {\r\n        for (var i = 1; i < this._entities.length; i++) {\r\n            var entity = this._entities[i];\r\n            if (entity) {\r\n                if (REGame_1.REGame.map.floorId() == entity.floorId) {\r\n                    REGame_1.REGame.map._addEntity(entity);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    return RE_Game_World;\r\n}());\r\nexports.RE_Game_World = RE_Game_World;\r\n\n\n//# sourceURL=webpack:///./ts/RE/REGame_World.ts?");

/***/ }),

/***/ "./ts/RMMZIntegration.ts":
/*!*******************************!*\
  !*** ./ts/RMMZIntegration.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RMMZIntegration = void 0;\r\nvar Common_1 = __webpack_require__(/*! ./Common */ \"./ts/Common.ts\");\r\nvar REData_1 = __webpack_require__(/*! ./data/REData */ \"./ts/data/REData.ts\");\r\nvar REDataManager_1 = __webpack_require__(/*! ./data/REDataManager */ \"./ts/data/REDataManager.ts\");\r\nvar REGame_1 = __webpack_require__(/*! ./RE/REGame */ \"./ts/RE/REGame.ts\");\r\nvar REGame_Block_1 = __webpack_require__(/*! ./RE/REGame_Block */ \"./ts/RE/REGame_Block.ts\");\r\nvar REEntityFactory_1 = __webpack_require__(/*! ./system/REEntityFactory */ \"./ts/system/REEntityFactory.ts\");\r\nvar REIntegration_1 = __webpack_require__(/*! ./system/REIntegration */ \"./ts/system/REIntegration.ts\");\r\nvar REVisual_1 = __webpack_require__(/*! ./visual/REVisual */ \"./ts/visual/REVisual.ts\");\r\nvar RMMZIntegration = /** @class */ (function (_super) {\r\n    __extends(RMMZIntegration, _super);\r\n    function RMMZIntegration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    RMMZIntegration.prototype.onReserveTransferFloor = function (floorId) {\r\n        throw new Error(\"Method not implemented.\");\r\n    };\r\n    RMMZIntegration.prototype.onLoadFixedMap = function (builder) {\r\n        var _this = this;\r\n        var _a, _b;\r\n        if (!$dataMap) {\r\n            throw new Error();\r\n        }\r\n        builder.reset((_a = $dataMap.width) !== null && _a !== void 0 ? _a : 10, (_b = $dataMap.height) !== null && _b !== void 0 ? _b : 10);\r\n        for (var y = 0; y < builder.height(); y++) {\r\n            for (var x = 0; x < builder.width(); x++) {\r\n                if ($gameMap.checkPassage(x, y, 0xF)) {\r\n                    builder.setTileKind(x, y, REGame_Block_1.TileKind.Floor);\r\n                }\r\n                else {\r\n                    builder.setTileKind(x, y, REGame_Block_1.TileKind.HardWall);\r\n                }\r\n            }\r\n        }\r\n        // 固定マップ上のイベントを Entity として出現させる\r\n        $gameMap.events().forEach(function (e) {\r\n            if (e && e._entityMetadata) {\r\n                if (e._entityMetadata.entity) {\r\n                    var entity = _this.newEntity(e._entityMetadata);\r\n                    entity.prefabKey = { kind: 0, id: e.eventId() };\r\n                    entity.rmmzEventId = e.eventId();\r\n                    REGame_1.REGame.world._transfarEntity(entity, REGame_1.REGame.map.floorId(), e.x, e.y);\r\n                    REGame_1.REGame.map.markAdhocEntity(entity);\r\n                }\r\n            }\r\n        });\r\n    };\r\n    RMMZIntegration.prototype.onFlushSequelSet = function (sequelSet) {\r\n    };\r\n    RMMZIntegration.prototype.onCheckVisualSequelRunning = function () {\r\n        if (REVisual_1.REVisual.entityVisualSet)\r\n            return REVisual_1.REVisual.entityVisualSet.visualRunning();\r\n        else\r\n            return false;\r\n    };\r\n    RMMZIntegration.prototype.onDialogOpend = function (context) {\r\n        var _a;\r\n        (_a = REVisual_1.REVisual.manager) === null || _a === void 0 ? void 0 : _a.openDialog(context);\r\n    };\r\n    RMMZIntegration.prototype.onUpdateDialog = function (context) {\r\n        var manager = REVisual_1.REVisual.manager;\r\n        if (manager) {\r\n            Common_1.assert(!manager._dialogNavigator.isEmpty());\r\n            manager._dialogNavigator.update(context);\r\n        }\r\n    };\r\n    RMMZIntegration.prototype.onDialogClosed = function (context) {\r\n        var manager = REVisual_1.REVisual.manager;\r\n        if (manager) {\r\n            manager.closeDialog(context);\r\n        }\r\n    };\r\n    RMMZIntegration.prototype.onEntityEnteredMap = function (entity) {\r\n        var _a;\r\n        var databaseMap = REDataManager_1.REDataManager.databaseMap();\r\n        Common_1.assert(databaseMap);\r\n        Common_1.assert(databaseMap.events);\r\n        //  entity に対応する動的イベントを新たに生成する\r\n        if (entity.prefabKey.kind > 0 && entity.prefabKey.id > 0) {\r\n            var prefabKey_1 = REData_1.REData.entityKinds[entity.prefabKey.kind].prefabKind + \":\" + entity.prefabKey.id;\r\n            var index = databaseMap.events.findIndex(function (x) { return (x) ? x.name == prefabKey_1 : false; });\r\n            if (index >= 0) {\r\n                var eventData = databaseMap.events[index];\r\n                var event_1 = $gameMap.spawnREEvent(eventData);\r\n                entity.rmmzEventId = event_1.eventId();\r\n            }\r\n            else {\r\n                throw new Error(prefabKey_1 + \" not found in REDatabase map.\");\r\n            }\r\n        }\r\n        else if (entity.prefabKey.kind == 0 && entity.prefabKey.id > 0) {\r\n            // entity は、RMMZ のマップ上に初期配置されているイベントを元に作成された。\r\n            // 固定マップの場合はここに入ってくるが、$gameMap.events の既存のインスタンスを参照しているため追加は不要。\r\n        }\r\n        else {\r\n            // Tile などは RMMZ のイベント化する必要はない\r\n            return;\r\n        }\r\n        (_a = REVisual_1.REVisual.entityVisualSet) === null || _a === void 0 ? void 0 : _a.createVisual(entity);\r\n    };\r\n    RMMZIntegration.prototype.onEntityLeavedMap = function (entity) {\r\n        var _a;\r\n        (_a = REVisual_1.REVisual.entityVisualSet) === null || _a === void 0 ? void 0 : _a.deleteVisual(entity);\r\n    };\r\n    RMMZIntegration.prototype.newEntity = function (data) {\r\n        var _a;\r\n        switch (data.entity) {\r\n            case \"ExitPoint\":\r\n                return REEntityFactory_1.REEntityFactory.newExitPoint();\r\n            case \"Enemy\":\r\n                return REEntityFactory_1.REEntityFactory.newMonster((_a = data.enemyId) !== null && _a !== void 0 ? _a : 0);\r\n            default:\r\n                throw new Error(\"Invalid entity name: \" + name);\r\n        }\r\n    };\r\n    return RMMZIntegration;\r\n}(REIntegration_1.REIntegration));\r\nexports.RMMZIntegration = RMMZIntegration;\r\n\n\n//# sourceURL=webpack:///./ts/RMMZIntegration.ts?");

/***/ }),

/***/ "./ts/Scene_Boot.ts":
/*!**************************!*\
  !*** ./ts/Scene_Boot.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar REDataManager_1 = __webpack_require__(/*! ./data/REDataManager */ \"./ts/data/REDataManager.ts\");\r\nvar _Scene_Boot_isReady = Scene_Boot.prototype.isReady;\r\nScene_Boot.prototype.isReady = function () {\r\n    // ベースの isReady の中から onDatabaseLoaded が呼び出される\r\n    var result = _Scene_Boot_isReady.call(this);\r\n    if (!window[\"RE_databaseMap\"]) {\r\n        return false;\r\n    }\r\n    else {\r\n        // Database マップの読み込みが完了\r\n        return result;\r\n    }\r\n};\r\nvar _Scene_Boot_onDatabaseLoaded = Scene_Boot.prototype.onDatabaseLoaded;\r\nScene_Boot.prototype.onDatabaseLoaded = function () {\r\n    _Scene_Boot_onDatabaseLoaded.call(this);\r\n    REDataManager_1.REDataManager.loadData();\r\n    // Database マップ読み込み開始\r\n    var filename = \"Map\" + REDataManager_1.REDataManager.databaseMapId.padZero(3) + \".json\";\r\n    DataManager.loadDataFile(\"RE_databaseMap\", filename);\r\n};\r\n\n\n//# sourceURL=webpack:///./ts/Scene_Boot.ts?");

/***/ }),

/***/ "./ts/Scene_Map.ts":
/*!*************************!*\
  !*** ./ts/Scene_Map.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Common_1 = __webpack_require__(/*! ./Common */ \"./ts/Common.ts\");\r\nvar REData_1 = __webpack_require__(/*! ./data/REData */ \"./ts/data/REData.ts\");\r\nvar REDataManager_1 = __webpack_require__(/*! ./data/REDataManager */ \"./ts/data/REDataManager.ts\");\r\nvar REEntityVisualSet_1 = __webpack_require__(/*! ./visual/REEntityVisualSet */ \"./ts/visual/REEntityVisualSet.ts\");\r\nvar REVisual_1 = __webpack_require__(/*! ./visual/REVisual */ \"./ts/visual/REVisual.ts\");\r\nvar _Scene_Map_isReady = Scene_Map.prototype.isReady;\r\nScene_Map.prototype.isReady = function () {\r\n    if (REDataManager_1.REDataManager.landMapDataLoading) {\r\n        if (DataManager.isMapLoaded()) {\r\n            // Land 定義マップの読み込みがすべて終わった\r\n            if (REData_1.REData.floors[REDataManager_1.REDataManager.loadingMapId].mapKind == REData_1.REFloorMapKind.FixedMap) {\r\n                // イベントなどから固定マップへ直接遷移した場合はここに来る。\r\n                // この場合はベースの DataManger.loadMapData によってマップデータロード済みなので、特に何かする必要はない。\r\n                REDataManager_1.REDataManager.loadedFloorMapId = REDataManager_1.REDataManager.loadingMapId;\r\n                REDataManager_1.REDataManager.landMapDataLoading = false;\r\n                // これを呼んでおかないと、コアスクリプト内で必要なオブジェクトが作成されない。\r\n                return _Scene_Map_isReady.call(this);\r\n            }\r\n            else {\r\n                throw new Error(\"Not implemented.\");\r\n                // Reload. まだ読み込み完了していない扱いにする\r\n                return false;\r\n            }\r\n            // 固定マップを読み込む\r\n            //DataManager.loadMapData(1); // TODO: id\r\n        }\r\n        else {\r\n            // Land 定義マップの読み込み中\r\n            return false;\r\n        }\r\n    }\r\n    else {\r\n        return _Scene_Map_isReady.call(this);\r\n    }\r\n};\r\nvar _Scene_Map_onMapLoaded = Scene_Map.prototype.onMapLoaded;\r\nScene_Map.prototype.onMapLoaded = function () {\r\n    return _Scene_Map_onMapLoaded.call(this);\r\n};\r\n// マップ切り替えのたびに呼び出される。\r\n// Scene_Map.updateTransferPlayer() でマップ遷移を検出すると、\r\n// goto(Scene_Map) で別インスタンスの Scene_Map へ遷移する。\r\nvar _Scene_Map_create = Scene_Map.prototype.create;\r\nScene_Map.prototype.create = function () {\r\n    _Scene_Map_create.call(this);\r\n};\r\nvar _Scene_Map_createDisplayObjects = Scene_Map.prototype.createDisplayObjects;\r\nScene_Map.prototype.createDisplayObjects = function () {\r\n    // ベースの createDisplayObjects() では update() 一度呼ばれるため、先にインスタンスを作っておく\r\n    Common_1.assert(!REVisual_1.REVisual.entityVisualSet);\r\n    REVisual_1.REVisual.entityVisualSet = new REEntityVisualSet_1.REEntityVisualSet();\r\n    _Scene_Map_createDisplayObjects.call(this);\r\n};\r\nvar _Scene_Map_terminate = Scene_Map.prototype.terminate;\r\nScene_Map.prototype.terminate = function () {\r\n    _Scene_Map_terminate.call(this);\r\n    if (REVisual_1.REVisual.entityVisualSet) {\r\n        REVisual_1.REVisual.entityVisualSet.ternimate();\r\n        REVisual_1.REVisual.entityVisualSet = undefined;\r\n    }\r\n    //REVisual.finalize();\r\n};\r\nvar _Scene_Map_update = Scene_Map.prototype.update;\r\nScene_Map.prototype.update = function () {\r\n    var _a;\r\n    _Scene_Map_update.call(this);\r\n    (_a = REVisual_1.REVisual.entityVisualSet) === null || _a === void 0 ? void 0 : _a.update();\r\n};\r\n\n\n//# sourceURL=webpack:///./ts/Scene_Map.ts?");

/***/ }),

/***/ "./ts/Sprite_Character.ts":
/*!********************************!*\
  !*** ./ts/Sprite_Character.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar dir8PatternYTable = [\r\n    0,\r\n    4, 0, 6,\r\n    1, 0, 2,\r\n    5, 3, 7,\r\n];\r\nvar dir4PatternYTable = [\r\n    0,\r\n    0, 0, 0,\r\n    1, 0, 2,\r\n    3, 3, 3,\r\n];\r\nvar _Sprite_Character_characterPatternY = Sprite_Character.prototype.characterPatternY;\r\nSprite_Character.prototype.characterPatternY = function () {\r\n    if (this._character.characterName().endsWith(\"-X\")) {\r\n        return dir8PatternYTable[this._character.direction()];\r\n    }\r\n    else {\r\n        return dir4PatternYTable[this._character.direction()];\r\n        //return _Sprite_Character_characterPatternY.call(this);\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack:///./ts/Sprite_Character.ts?");

/***/ }),

/***/ "./ts/data/REData.ts":
/*!***************************!*\
  !*** ./ts/data/REData.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REData = exports.REFloorMapKind = void 0;\r\nvar REGame_Attribute_1 = __webpack_require__(/*! ts/RE/REGame_Attribute */ \"./ts/RE/REGame_Attribute.ts\");\r\nvar REGame_Behavior_1 = __webpack_require__(/*! ts/RE/REGame_Behavior */ \"./ts/RE/REGame_Behavior.ts\");\r\nvar REFloorMapKind;\r\n(function (REFloorMapKind) {\r\n    // データ定義用のマップ。ここへの遷移は禁止\r\n    REFloorMapKind[REFloorMapKind[\"Land\"] = 0] = \"Land\";\r\n    REFloorMapKind[REFloorMapKind[\"FixedMap\"] = 1] = \"FixedMap\";\r\n    REFloorMapKind[REFloorMapKind[\"ShuffleMap\"] = 2] = \"ShuffleMap\";\r\n    REFloorMapKind[REFloorMapKind[\"RandomMap\"] = 3] = \"RandomMap\";\r\n})(REFloorMapKind = exports.REFloorMapKind || (exports.REFloorMapKind = {}));\r\nvar REData = /** @class */ (function () {\r\n    function REData() {\r\n    }\r\n    REData.reset = function () {\r\n        this.entityKinds = [{ id: 0, name: 'null', prefabKind: \"\" }];\r\n        this.actors = [{ id: 0, name: 'null', initialFloorId: 0, initialX: 0, initialY: 0 }];\r\n        this.monsters = [{ id: 0, name: 'null', exp: 0, params: [] }];\r\n        this.lands = [{ id: 0, mapId: 0, eventTableMapId: 0, itemTableMapId: 0, enemyTableMapId: 0, trapTableMapId: 0, floorIds: [] }];\r\n        this.floors = [{ id: 0, mapId: 0, landId: 0, mapKind: REFloorMapKind.FixedMap }];\r\n        this.factions = [{ id: 0, name: 'null', schedulingOrder: 0 }];\r\n        this.actions = [{ id: 0, displayName: 'null' }];\r\n        this.sequels = [{ id: 0, name: 'null', parallel: false }];\r\n        this.parameters = [{ id: 0, name: 'null' }];\r\n        this.attributes = [{ id: 0, name: 'null' }];\r\n        this.behaviors = [{ id: 0, name: 'null' }];\r\n        this.skills = [{ id: 0, name: 'null', paramCosts: [] }];\r\n        this.states = [{ id: 0, name: 'null' }];\r\n        this._attributeFactories = [function () { return new REGame_Attribute_1.REGame_Attribute(); }];\r\n        this._behaviorFactories = [function () { return new REGame_Behavior_1.REGame_Behavior(); }];\r\n    };\r\n    REData.addEntityKind = function (name, prefabKind) {\r\n        var newId = this.entityKinds.length;\r\n        this.entityKinds.push({\r\n            id: newId,\r\n            name: name,\r\n            prefabKind: prefabKind,\r\n        });\r\n        return newId;\r\n    };\r\n    /**\r\n     * Add actor.\r\n     */\r\n    REData.addActor = function (name) {\r\n        var newId = this.actors.length;\r\n        this.actors.push({\r\n            id: newId,\r\n            name: name,\r\n            initialFloorId: 0,\r\n            initialX: 0,\r\n            initialY: 0,\r\n        });\r\n        return newId;\r\n    };\r\n    /**\r\n     * Add Monster.\r\n     */\r\n    REData.addMonster = function (name) {\r\n        var newId = this.monsters.length;\r\n        this.monsters.push({\r\n            id: newId,\r\n            name: name,\r\n            exp: 0,\r\n            params: [],\r\n        });\r\n        return newId;\r\n    };\r\n    /**\r\n     * Add land.\r\n     * @param mapId : RMMZ mapID\r\n     */\r\n    REData.addLand = function (mapId) {\r\n        var newId = this.lands.length;\r\n        this.lands.push({\r\n            id: newId,\r\n            mapId: mapId,\r\n            eventTableMapId: 0,\r\n            itemTableMapId: 0,\r\n            enemyTableMapId: 0,\r\n            trapTableMapId: 0,\r\n            floorIds: [],\r\n        });\r\n        return newId;\r\n    };\r\n    /**\r\n     * Add floor.\r\n     * @param mapId : RMMZ mapID\r\n     */\r\n    REData.addFloor = function (mapId, landId, kind) {\r\n        var newId = this.floors.length;\r\n        this.floors.push({\r\n            id: newId,\r\n            mapId: mapId,\r\n            landId: landId,\r\n            mapKind: kind,\r\n        });\r\n        return newId;\r\n    };\r\n    REData.addAction = function (displayName) {\r\n        var newId = this.actions.length;\r\n        this.actions.push({\r\n            id: newId,\r\n            displayName: displayName\r\n        });\r\n        return newId;\r\n    };\r\n    REData.addParameter = function (name) {\r\n        var newId = this.parameters.length;\r\n        this.parameters.push({\r\n            id: newId,\r\n            name: name\r\n        });\r\n        return newId;\r\n    };\r\n    REData.addAttribute = function (name, factory) {\r\n        var newId = this.attributes.length;\r\n        this.attributes.push({\r\n            id: newId,\r\n            name: name,\r\n        });\r\n        this._attributeFactories.push(factory);\r\n        return newId;\r\n    };\r\n    REData.addBehavior = function (name, factory) {\r\n        var newId = this.behaviors.length;\r\n        this.behaviors.push({\r\n            id: newId,\r\n            name: name,\r\n        });\r\n        this._behaviorFactories.push(factory);\r\n        return newId;\r\n    };\r\n    REData.addSkill = function (name) {\r\n        var newId = this.skills.length;\r\n        this.skills.push({\r\n            id: newId,\r\n            name: name,\r\n            paramCosts: [],\r\n        });\r\n        return newId;\r\n    };\r\n    REData.addState = function (name, factory) {\r\n        var newId = this.states.length;\r\n        this.states.push({\r\n            id: newId,\r\n            name: name,\r\n        });\r\n        this._stateFactories[newId] = factory;\r\n        return newId;\r\n    };\r\n    REData.addSequel = function (name) {\r\n        var newId = this.sequels.length;\r\n        this.sequels.push({\r\n            id: newId,\r\n            name: name,\r\n            parallel: false,\r\n        });\r\n        return newId;\r\n    };\r\n    REData.MAX_DUNGEON_FLOORS = 100;\r\n    // Common defineds.\r\n    REData.ActorDefaultFactionId = 1;\r\n    REData.EnemeyDefaultFactionId = 2;\r\n    REData.NormalAttackSkillId = 1;\r\n    REData.entityKinds = [];\r\n    REData.actors = [];\r\n    REData.monsters = [];\r\n    REData.lands = [];\r\n    REData.floors = []; // 1~マップ最大数までは、MapId と一致する。それより後は Land の Floor.\r\n    REData.factions = [];\r\n    REData.actions = [{ id: 0, displayName: 'null' }];\r\n    REData.sequels = [{ id: 0, name: 'null', parallel: false }];\r\n    REData.parameters = [{ id: 0, name: 'null' }];\r\n    REData.attributes = [{ id: 0, name: 'null' }];\r\n    REData.behaviors = [{ id: 0, name: 'null' }];\r\n    REData.skills = [];\r\n    REData.states = [];\r\n    REData._attributeFactories = [];\r\n    REData._behaviorFactories = [];\r\n    REData._stateFactories = [];\r\n    return REData;\r\n}());\r\nexports.REData = REData;\r\n\n\n//# sourceURL=webpack:///./ts/data/REData.ts?");

/***/ }),

/***/ "./ts/data/REDataManager.ts":
/*!**********************************!*\
  !*** ./ts/data/REDataManager.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REDataManager = void 0;\r\n//import 'types/index.d.ts'\r\nvar RETileAttribute_1 = __webpack_require__(/*! ts/objects/attributes/RETileAttribute */ \"./ts/objects/attributes/RETileAttribute.ts\");\r\nvar REDecisionBehavior_1 = __webpack_require__(/*! ts/objects/behaviors/REDecisionBehavior */ \"./ts/objects/behaviors/REDecisionBehavior.ts\");\r\nvar REUnitBehavior_1 = __webpack_require__(/*! ts/objects/behaviors/REUnitBehavior */ \"./ts/objects/behaviors/REUnitBehavior.ts\");\r\nvar DebugMoveRightState_1 = __webpack_require__(/*! ts/objects/states/DebugMoveRightState */ \"./ts/objects/states/DebugMoveRightState.ts\");\r\nvar REGame_Attribute_1 = __webpack_require__(/*! ts/RE/REGame_Attribute */ \"./ts/RE/REGame_Attribute.ts\");\r\nvar RESystem_1 = __webpack_require__(/*! ts/system/RESystem */ \"./ts/system/RESystem.ts\");\r\nvar Common_1 = __webpack_require__(/*! ../Common */ \"./ts/Common.ts\");\r\nvar REData_1 = __webpack_require__(/*! ./REData */ \"./ts/data/REData.ts\");\r\nvar REDataManager = /** @class */ (function () {\r\n    function REDataManager() {\r\n    }\r\n    REDataManager.setupCommonData = function () {\r\n        REData_1.REData.reset();\r\n        // Parameters\r\n        RESystem_1.RESystem.parameters = {\r\n            hp: REData_1.REData.addParameter(\"HP\"),\r\n            mp: REData_1.REData.addParameter(\"MP\"),\r\n            tp: REData_1.REData.addParameter(\"TP\"),\r\n            mhp: REData_1.REData.addParameter(\"MHP\"),\r\n            mmp: REData_1.REData.addParameter(\"MMP\"),\r\n            atk: REData_1.REData.addParameter(\"ATK\"),\r\n            def: REData_1.REData.addParameter(\"DEF\"),\r\n            mat: REData_1.REData.addParameter(\"MAT\"),\r\n            mdf: REData_1.REData.addParameter(\"MDF\"),\r\n            agi: REData_1.REData.addParameter(\"AGI\"),\r\n            luk: REData_1.REData.addParameter(\"LUK\"),\r\n            satiety: REData_1.REData.addParameter(\"満腹度\"),\r\n        };\r\n        RESystem_1.RESystem.entityKinds = {\r\n            actor: REData_1.REData.addEntityKind(\"Actor\", \"Actor\"),\r\n            WeaponKindId: REData_1.REData.addEntityKind(\"武器\", \"Weapon\"),\r\n            ShieldKindId: REData_1.REData.addEntityKind(\"盾\", \"Shield\"),\r\n            ArrowKindId: REData_1.REData.addEntityKind(\"矢\", \"Arrow\"),\r\n            //RE_Data.addEntityKind(\"石\"),\r\n            //RE_Data.addEntityKind(\"弾\"),\r\n            BraceletKindId: REData_1.REData.addEntityKind(\"腕輪\", \"Bracelet\"),\r\n            FoodKindId: REData_1.REData.addEntityKind(\"食料\", \"Food\"),\r\n            HerbKindId: REData_1.REData.addEntityKind(\"草\", \"Herb\"),\r\n            ScrollKindId: REData_1.REData.addEntityKind(\"巻物\", \"Scroll\"),\r\n            WandKindId: REData_1.REData.addEntityKind(\"杖\", \"Wand\"),\r\n            PotKindId: REData_1.REData.addEntityKind(\"壺\", \"Pot\"),\r\n            DiscountTicketKindId: REData_1.REData.addEntityKind(\"割引券\", \"DiscountTicket\"),\r\n            BuildingMaterialKindId: REData_1.REData.addEntityKind(\"材料\", \"BuildingMaterial\"),\r\n            TrapKindId: REData_1.REData.addEntityKind(\"罠\", \"Trap\"),\r\n            FigurineKindId: REData_1.REData.addEntityKind(\"土偶\", \"Figurine\"),\r\n            MonsterKindId: REData_1.REData.addEntityKind(\"モンスター\", \"Monster\"),\r\n        };\r\n        // Factions\r\n        {\r\n            REData_1.REData.factions = [\r\n                { id: 0, name: '', schedulingOrder: 9999 },\r\n                { id: 1, name: 'Friends', schedulingOrder: 1 },\r\n                { id: 2, name: 'Enemy', schedulingOrder: 2 },\r\n                { id: 3, name: 'Neutral', schedulingOrder: 3 },\r\n            ];\r\n        }\r\n        // Actions\r\n        REData_1.REData.DirectionChangeActionId = REData_1.REData.addAction(\"DirectionChange\");\r\n        REData_1.REData.MoveToAdjacentActionId = REData_1.REData.addAction(\"MoveToAdjacent\");\r\n        REData_1.REData.ProceedFloorActionId = REData_1.REData.addAction(\"すすむ\");\r\n        REData_1.REData.AttackActionId = REData_1.REData.addAction(\"Attack\");\r\n        // Attributes\r\n        RESystem_1.RESystem.attributes = {\r\n            tile: REData_1.REData.addAttribute(\"Tile\", function () { return new RETileAttribute_1.RETileAttribute(); }),\r\n            unit: REData_1.REData.addAttribute(\"Unit\", function () { return new REGame_Attribute_1.REGame_UnitAttribute(); }),\r\n        };\r\n        // Behaviors\r\n        RESystem_1.RESystem.behaviors = {\r\n            decision: REData_1.REData.addBehavior(\"Decision\", function () { return new REDecisionBehavior_1.REGame_DecisionBehavior(); }),\r\n            unit: REData_1.REData.addBehavior(\"Unit\", function () { return new REUnitBehavior_1.REUnitBehavior(); }),\r\n        };\r\n        // States\r\n        RESystem_1.RESystem.states = {\r\n            speedDown: 0,\r\n            speedUp: 0,\r\n            confusion: 0,\r\n            sleep: 0,\r\n            blind: 0,\r\n            paralysis: 0,\r\n            sealed: 0,\r\n            substitute: 0,\r\n            transparent: 0,\r\n            sightThrough: 0,\r\n            sharpEar: 0,\r\n            clairvoyant: 0,\r\n            deception: 0,\r\n            mouthClosed: 0,\r\n            debug_MoveRight: REData_1.REData.addState(\"debug_MoveRight\", function () { return new DebugMoveRightState_1.LDebugMoveRightState(); }),\r\n        };\r\n        // Sequels\r\n        RESystem_1.RESystem.sequels = {\r\n            MoveSequel: REData_1.REData.addSequel(\"Move\"),\r\n            attack: REData_1.REData.addSequel(\"attack\"),\r\n            CollapseSequel: REData_1.REData.addSequel(\"Collapse\"),\r\n        };\r\n        REData_1.REData.sequels[RESystem_1.RESystem.sequels.MoveSequel].parallel = true;\r\n    };\r\n    REDataManager.loadData = function () {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\r\n        this.setupCommonData();\r\n        //REData.addAction();\r\n        // Import Actors\r\n        $dataActors.forEach(function (x) {\r\n            var _a;\r\n            if (x) {\r\n                REData_1.REData.addActor((_a = x.name) !== null && _a !== void 0 ? _a : \"null\");\r\n            }\r\n        });\r\n        // 1番アクターの初期フロアを、RMMZプレイヤーの初期位置にする\r\n        REData_1.REData.actors[1].initialFloorId = (_a = $dataSystem.startMapId) !== null && _a !== void 0 ? _a : 0;\r\n        REData_1.REData.actors[1].initialX = (_b = $dataSystem.startX) !== null && _b !== void 0 ? _b : 0;\r\n        REData_1.REData.actors[1].initialY = (_c = $dataSystem.startY) !== null && _c !== void 0 ? _c : 0;\r\n        // Import Skills\r\n        $dataSkills.forEach(function (x) {\r\n            var _a, _b, _c;\r\n            if (x) {\r\n                var id = REData_1.REData.addSkill((_a = x.name) !== null && _a !== void 0 ? _a : \"null\");\r\n                var skill = REData_1.REData.skills[id];\r\n                skill.paramCosts[RESystem_1.RESystem.parameters.mp] = (_b = x.mpCost) !== null && _b !== void 0 ? _b : 0;\r\n                skill.paramCosts[RESystem_1.RESystem.parameters.tp] = (_c = x.tpCost) !== null && _c !== void 0 ? _c : 0;\r\n            }\r\n        });\r\n        // Import Monsters\r\n        $dataEnemies.forEach(function (x) {\r\n            var _a, _b;\r\n            if (x) {\r\n                var id = REData_1.REData.addMonster((_a = x.name) !== null && _a !== void 0 ? _a : \"\");\r\n                var monster = REData_1.REData.monsters[id];\r\n                monster.exp = (_b = x.exp) !== null && _b !== void 0 ? _b : 0;\r\n                if (x.params) {\r\n                    // see: Object.defineProperties\r\n                    monster.params[RESystem_1.RESystem.parameters.mhp] = x.params[0];\r\n                    monster.params[RESystem_1.RESystem.parameters.mmp] = x.params[1];\r\n                    monster.params[RESystem_1.RESystem.parameters.atk] = x.params[2];\r\n                    monster.params[RESystem_1.RESystem.parameters.def] = x.params[3];\r\n                    monster.params[RESystem_1.RESystem.parameters.mat] = x.params[4];\r\n                    monster.params[RESystem_1.RESystem.parameters.mdf] = x.params[5];\r\n                    monster.params[RESystem_1.RESystem.parameters.agi] = x.params[6];\r\n                    monster.params[RESystem_1.RESystem.parameters.luk] = x.params[7];\r\n                }\r\n            }\r\n        });\r\n        // Import Lands\r\n        // 最初に Land を作る\r\n        REData_1.REData.addLand(0); // dummy\r\n        for (var i = 0; i < $dataMapInfos.length; i++) {\r\n            var info = $dataMapInfos[i];\r\n            if (info && ((_d = info.name) === null || _d === void 0 ? void 0 : _d.startsWith(\"RELand:\"))) {\r\n                REData_1.REData.addLand(i);\r\n            }\r\n        }\r\n        var _loop_1 = function () {\r\n            var info = $dataMapInfos[i];\r\n            if (info) {\r\n                var land = REData_1.REData.lands.find(function (x) { return info.parentId && x.mapId == info.parentId; });\r\n                if (land) {\r\n                    if ((_e = info.name) === null || _e === void 0 ? void 0 : _e.startsWith(\"Event\")) {\r\n                        land.eventTableMapId = i;\r\n                    }\r\n                    else if ((_f = info.name) === null || _f === void 0 ? void 0 : _f.startsWith(\"Item\")) {\r\n                        land.itemTableMapId = i;\r\n                    }\r\n                    else if ((_g = info.name) === null || _g === void 0 ? void 0 : _g.startsWith(\"Enemy\")) {\r\n                        land.enemyTableMapId = i;\r\n                    }\r\n                    else if ((_h = info.name) === null || _h === void 0 ? void 0 : _h.startsWith(\"Trap\")) {\r\n                        land.trapTableMapId = i;\r\n                    }\r\n                    else {\r\n                        // 固定マップ or シャッフルマップ用のテンプレートマップ\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        // parent が Land である Map を、データテーブル用のマップとして関連付ける\r\n        for (var i = 0; i < $dataMapInfos.length; i++) {\r\n            _loop_1();\r\n        }\r\n        // Floor 情報を作る\r\n        // ※フロア数を Land マップの width としているが、これは MapInfo から読み取ることはできず、\r\n        //   全マップを一度ロードする必要がある。しかしそうすると処理時間が大きくなってしまう。\r\n        //   ひとまず欠番は多くなるが、最大フロア数でデータを作ってみる。\r\n        {\r\n            // 固定マップ\r\n            REData_1.REData.floors = new Array($dataMapInfos.length + (REData_1.REData.lands.length * REData_1.REData.MAX_DUNGEON_FLOORS));\r\n            var _loop_2 = function (i_1) {\r\n                var info = $dataMapInfos[i_1];\r\n                if (this_1.isDatabaseMap(i_1)) {\r\n                    this_1.databaseMapId = i_1;\r\n                }\r\n                else if (info && ((_j = info.name) === null || _j === void 0 ? void 0 : _j.startsWith(\"RELand:\"))) {\r\n                    var land = REData_1.REData.lands.find(function (x) { return x.mapId == i_1; });\r\n                    Common_1.assert(land);\r\n                    REData_1.REData.floors[i_1] = { id: i_1, landId: land.id, mapId: i_1, mapKind: REData_1.REFloorMapKind.Land };\r\n                }\r\n                else if (info && info.parentId) {\r\n                    var parentInfo_1 = $dataMapInfos[info.parentId];\r\n                    var land = REData_1.REData.lands.find(function (x) { return parentInfo_1 && parentInfo_1.parentId && x.mapId == parentInfo_1.parentId; });\r\n                    if (land) {\r\n                        var kind = undefined;\r\n                        if (parentInfo_1.name == \"[RandomMaps]\") {\r\n                            kind = REData_1.REFloorMapKind.RandomMap;\r\n                        }\r\n                        else if (parentInfo_1.name == \"[ShuffleMaps]\") {\r\n                            kind = REData_1.REFloorMapKind.ShuffleMap;\r\n                        }\r\n                        else if (parentInfo_1.name == \"[FixedMaps]\") {\r\n                            kind = REData_1.REFloorMapKind.FixedMap;\r\n                        }\r\n                        if (kind !== undefined) {\r\n                            REData_1.REData.floors[i_1] = { id: i_1, landId: land.id, mapId: i_1, mapKind: kind };\r\n                        }\r\n                        else {\r\n                            // RE には関係のないマップ\r\n                            REData_1.REData.floors[i_1] = { id: 0, landId: 0, mapId: 0, mapKind: REData_1.REFloorMapKind.FixedMap };\r\n                        }\r\n                    }\r\n                    else {\r\n                        // RE には関係のないマップ\r\n                        REData_1.REData.floors[i_1] = { id: 0, landId: 0, mapId: 0, mapKind: REData_1.REFloorMapKind.FixedMap };\r\n                    }\r\n                }\r\n                else {\r\n                    // RE には関係のないマップ\r\n                    REData_1.REData.floors[i_1] = { id: 0, landId: 0, mapId: 0, mapKind: REData_1.REFloorMapKind.FixedMap };\r\n                }\r\n            };\r\n            var this_1 = this;\r\n            for (var i_1 = 0; i_1 < $dataMapInfos.length; i_1++) {\r\n                _loop_2(i_1);\r\n            }\r\n            // ランダムマップ\r\n            for (var i_2 = 0; i_2 < REData_1.REData.lands.length; i_2++) {\r\n                var beginFloorId = $dataMapInfos.length + (i_2 * REData_1.REData.MAX_DUNGEON_FLOORS);\r\n                REData_1.REData.lands[i_2].floorIds = new Array(REData_1.REData.MAX_DUNGEON_FLOORS);\r\n                for (var iFloor = 0; iFloor < REData_1.REData.MAX_DUNGEON_FLOORS; iFloor++) {\r\n                    var floorId = beginFloorId + iFloor;\r\n                    REData_1.REData.lands[i_2].floorIds[iFloor] = floorId;\r\n                    REData_1.REData.floors[floorId] = {\r\n                        id: floorId,\r\n                        landId: REData_1.REData.lands[i_2].id,\r\n                        mapId: 0,\r\n                        mapKind: REData_1.REFloorMapKind.RandomMap,\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    };\r\n    REDataManager.floor = function (mapId) {\r\n        return REData_1.REData.floors[mapId];\r\n    };\r\n    REDataManager.isDatabaseMap = function (mapId) {\r\n        var info = $dataMapInfos[mapId];\r\n        if (info && info.name && info.name.startsWith(\"REDatabase\"))\r\n            return true;\r\n        else\r\n            return false;\r\n    };\r\n    REDataManager.isLandMap = function (mapId) {\r\n        var info = $dataMapInfos[mapId];\r\n        if (info && info.name && info.name.startsWith(\"RELand:\"))\r\n            return true;\r\n        else\r\n            return false;\r\n    };\r\n    REDataManager.isRESystemMap = function (mapId) {\r\n        var flooor = REData_1.REData.floors[mapId];\r\n        return flooor.landId > 0;\r\n    };\r\n    REDataManager.isFloorMap = function (mapId) {\r\n        return REData_1.REData.floors[mapId].landId > 0;\r\n        /*\r\n        const info = $dataMapInfos[mapId];\r\n        if (info && info.name && info.name.startsWith(\"REFloor:\"))\r\n            return true;\r\n        else\r\n            return false;\r\n        */\r\n    };\r\n    REDataManager.dataLandDefinitionMap = function () {\r\n        return window[\"RE_dataLandMap\"];\r\n    };\r\n    REDataManager.dataEventTableMap = function () {\r\n        return window[\"RE_dataEventTableMap\"];\r\n    };\r\n    REDataManager.dataItemTableMap = function () {\r\n        return window[\"RE_dataItemTableMap\"];\r\n    };\r\n    REDataManager.dataEnemyTableMap = function () {\r\n        return window[\"RE_dataEnemyTableMap\"];\r\n    };\r\n    REDataManager.dataTrapTableMap = function () {\r\n        return window[\"RE_dataTrapTableMap\"];\r\n    };\r\n    REDataManager.databaseMap = function () {\r\n        return window[\"RE_databaseMap\"];\r\n    };\r\n    REDataManager.databaseMapId = 0;\r\n    REDataManager.landMapDataLoading = false;\r\n    //static _dataLandDefinitionMap: IDataMap | undefined = undefined;\r\n    REDataManager.loadedLandId = 0;\r\n    REDataManager.loadedFloorMapId = 0;\r\n    REDataManager.loadingMapId = 0;\r\n    return REDataManager;\r\n}());\r\nexports.REDataManager = REDataManager;\r\n\n\n//# sourceURL=webpack:///./ts/data/REDataManager.ts?");

/***/ }),

/***/ "./ts/dialogs/EventExecutionDialog.ts":
/*!********************************************!*\
  !*** ./ts/dialogs/EventExecutionDialog.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RE = void 0;\r\nvar REDialog_1 = __webpack_require__(/*! ts/system/REDialog */ \"./ts/system/REDialog.ts\");\r\nvar RE;\r\n(function (RE) {\r\n    var EventExecutionDialog = /** @class */ (function (_super) {\r\n        __extends(EventExecutionDialog, _super);\r\n        function EventExecutionDialog(rmmzEventId) {\r\n            var _this = _super.call(this) || this;\r\n            _this._rmmzEventId = rmmzEventId;\r\n            return _this;\r\n        }\r\n        EventExecutionDialog.prototype.rmmzEventId = function () {\r\n            return this._rmmzEventId;\r\n        };\r\n        EventExecutionDialog.prototype.onUpdate = function (context) {\r\n        };\r\n        return EventExecutionDialog;\r\n    }(REDialog_1.REDialog));\r\n    RE.EventExecutionDialog = EventExecutionDialog;\r\n})(RE = exports.RE || (exports.RE = {}));\r\n\n\n//# sourceURL=webpack:///./ts/dialogs/EventExecutionDialog.ts?");

/***/ }),

/***/ "./ts/dialogs/REManualDecisionDialog.ts":
/*!**********************************************!*\
  !*** ./ts/dialogs/REManualDecisionDialog.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REManualActionDialog = void 0;\r\nvar REDialog_1 = __webpack_require__(/*! ../system/REDialog */ \"./ts/system/REDialog.ts\");\r\nvar REManualActionDialog = /** @class */ (function (_super) {\r\n    __extends(REManualActionDialog, _super);\r\n    function REManualActionDialog() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    REManualActionDialog.prototype.onUpdate = function (context) {\r\n        //console.log(\"REManualActionDialog.update\");\r\n    };\r\n    return REManualActionDialog;\r\n}(REDialog_1.REDialog));\r\nexports.REManualActionDialog = REManualActionDialog;\r\n\n\n//# sourceURL=webpack:///./ts/dialogs/REManualDecisionDialog.ts?");

/***/ }),

/***/ "./ts/index.ts":
/*!*********************!*\
  !*** ./ts/index.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__webpack_require__(/*! ./PrefabEvent */ \"./ts/PrefabEvent.ts\");\r\n__webpack_require__(/*! ./DataManager */ \"./ts/DataManager.ts\");\r\n__webpack_require__(/*! ./Game_Player */ \"./ts/Game_Player.ts\");\r\n__webpack_require__(/*! ./Game_Event */ \"./ts/Game_Event.ts\");\r\n__webpack_require__(/*! ./Game_Map */ \"./ts/Game_Map.ts\");\r\n__webpack_require__(/*! ./data/REData */ \"./ts/data/REData.ts\");\r\n__webpack_require__(/*! ./data/REDataManager */ \"./ts/data/REDataManager.ts\");\r\n__webpack_require__(/*! ./RE/REGame_Entity */ \"./ts/RE/REGame_Entity.ts\");\r\n__webpack_require__(/*! ./system/REEntityFactory */ \"./ts/system/REEntityFactory.ts\");\r\n__webpack_require__(/*! ./RE/REGame_Map */ \"./ts/RE/REGame_Map.ts\");\r\n__webpack_require__(/*! ./RE/REGame_Core */ \"./ts/RE/REGame_Core.ts\");\r\n__webpack_require__(/*! ./Scene_Boot */ \"./ts/Scene_Boot.ts\");\r\n__webpack_require__(/*! ./Scene_Map */ \"./ts/Scene_Map.ts\");\r\n__webpack_require__(/*! ./Sprite_Character */ \"./ts/Sprite_Character.ts\");\r\n\n\n//# sourceURL=webpack:///./ts/index.ts?");

/***/ }),

/***/ "./ts/math/Random.ts":
/*!***************************!*\
  !*** ./ts/math/Random.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Random = void 0;\r\nvar Random = /** @class */ (function () {\r\n    function Random(seed) {\r\n        this._x = 123456789;\r\n        this._y = 362436069;\r\n        this._z = 521288629;\r\n        this._w = seed;\r\n    }\r\n    Random.prototype.nextInt = function () {\r\n        var t = this._x ^ (this._x << 11);\r\n        this._x = this._y;\r\n        this._y = this._z;\r\n        this._z = this._w;\r\n        this._w = (this._w ^ (this._w >> 19)) ^ (t ^ (t >> 8));\r\n        return this._w;\r\n    };\r\n    Random.prototype.nextIntWithMax = function (maxValue) {\r\n        if (maxValue == 0) {\r\n            return 0;\r\n        }\r\n        var r = this.nextInt();\r\n        r %= maxValue;\r\n        return r;\r\n    };\r\n    Random.prototype.nextIntWithMinMax = function (minValue, maxValue) {\r\n        if (maxValue - minValue == 0) {\r\n            return 0;\r\n        }\r\n        var r = this.nextInt();\r\n        r %= maxValue - minValue;\r\n        r += minValue;\r\n        return r;\r\n    };\r\n    Random.prototype.nextIntWithWidth = function (median, width) {\r\n        return this.nextIntWithMinMax(median - width, median + width);\r\n    };\r\n    return Random;\r\n}());\r\nexports.Random = Random;\r\n\n\n//# sourceURL=webpack:///./ts/math/Random.ts?");

/***/ }),

/***/ "./ts/math/Vector2.ts":
/*!****************************!*\
  !*** ./ts/math/Vector2.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// NOTE: 実行速度よりも書きやすさ・安全性重視で。\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Vector2 = void 0;\r\nvar Vector2 = /** @class */ (function () {\r\n    function Vector2(x, y) {\r\n        if (x === void 0) { x = 0.0; }\r\n        if (y === void 0) { y = 0.0; }\r\n        this.x = 0.0;\r\n        this.y = 0.0;\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    Vector2.clone = function (value) {\r\n        return new Vector2(value.x, value.y);\r\n    };\r\n    Vector2.add = function (a, b) {\r\n        if (typeof b === \"number\") {\r\n            return new Vector2(a.x + b, a.y + b);\r\n        }\r\n        else {\r\n            return new Vector2(a.x + b.x, a.y + b.y);\r\n        }\r\n    };\r\n    Vector2.sub = function (a, b) {\r\n        if (typeof b === \"number\") {\r\n            return new Vector2(a.x - b, a.y - b);\r\n        }\r\n        else {\r\n            return new Vector2(a.x - b.x, a.y - b.y);\r\n        }\r\n    };\r\n    Vector2.mul = function (a, b) {\r\n        if (typeof b === \"number\") {\r\n            return new Vector2(a.x * b, a.y * b);\r\n        }\r\n        else {\r\n            return new Vector2(a.x * b.x, a.y * b.y);\r\n        }\r\n    };\r\n    Vector2.div = function (a, b) {\r\n        if (typeof b === \"number\") {\r\n            return new Vector2(a.x / b, a.y / b);\r\n        }\r\n        else {\r\n            return new Vector2(a.x / b.x, a.y / b.y);\r\n        }\r\n    };\r\n    Vector2.sign = function (value) {\r\n        return new Vector2((value.x < 0.0) ? -1.0 : ((value.x > 0.0) ? 1.0 : 0.0), (value.y < 0.0) ? -1.0 : ((value.y > 0.0) ? 1.0 : 0.0));\r\n    };\r\n    return Vector2;\r\n}());\r\nexports.Vector2 = Vector2;\r\n\n\n//# sourceURL=webpack:///./ts/math/Vector2.ts?");

/***/ }),

/***/ "./ts/objects/REGame_Camera.ts":
/*!*************************************!*\
  !*** ./ts/objects/REGame_Camera.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REGame_Camera = void 0;\r\nvar REGame_1 = __webpack_require__(/*! ts/RE/REGame */ \"./ts/RE/REGame.ts\");\r\nvar RESystem_1 = __webpack_require__(/*! ts/system/RESystem */ \"./ts/system/RESystem.ts\");\r\n/**\r\n * 始点位置。ツクールの Game_Player と連携する。\r\n *\r\n * ツクールのマップ移動=Game_Player の移動であるように、RE でもマップ移動=Camera の移動、となる。\r\n */\r\nvar REGame_Camera = /** @class */ (function () {\r\n    function REGame_Camera() {\r\n        this._focusedEntityId = 0;\r\n        this._transferingNewFloorId = 0;\r\n        this._transferingNewX = 0;\r\n        this._transferingNewY = 0;\r\n        /*\r\n        _update() {\r\n            // 注視している Entity が別の Floor にいる場合、Camera を移動する\r\n            const entity = this.focusedEntity();\r\n            if (entity) {\r\n                if (REGame.map.floorId() != entity.floorId) {\r\n    \r\n                }\r\n            }\r\n        }\r\n        */\r\n    }\r\n    REGame_Camera.prototype.focusedEntityId = function () {\r\n        return this._focusedEntityId;\r\n    };\r\n    REGame_Camera.prototype.focusedEntity = function () {\r\n        return REGame_1.REGame.world.entity(this._focusedEntityId);\r\n    };\r\n    REGame_Camera.prototype.focus = function (entity) {\r\n        this._focusedEntityId = entity._id;\r\n    };\r\n    REGame_Camera.prototype.clearFocus = function () {\r\n        this._focusedEntityId = 0;\r\n    };\r\n    REGame_Camera.prototype.isFloorTransfering = function () {\r\n        return this._transferingNewFloorId > 0;\r\n    };\r\n    REGame_Camera.prototype.transferingNewFloorId = function () {\r\n        return this._transferingNewFloorId;\r\n    };\r\n    REGame_Camera.prototype.reserveFloorTransferToFocusedEntity = function () {\r\n        var entity = this.focusedEntity();\r\n        if (entity) {\r\n            this.reserveFloorTransfer(entity.floorId, entity.x, entity.y);\r\n        }\r\n    };\r\n    REGame_Camera.prototype.reserveFloorTransfer = function (floorId, x, y) {\r\n        this._transferingNewFloorId = floorId;\r\n        this._transferingNewX = x;\r\n        this._transferingNewY = y;\r\n        RESystem_1.RESystem.integration.onReserveTransferFloor(floorId);\r\n    };\r\n    REGame_Camera.prototype.clearFloorTransfering = function () {\r\n        this._transferingNewFloorId = 0;\r\n        this._transferingNewX = 0;\r\n        this._transferingNewY = 0;\r\n    };\r\n    return REGame_Camera;\r\n}());\r\nexports.REGame_Camera = REGame_Camera;\r\n\n\n//# sourceURL=webpack:///./ts/objects/REGame_Camera.ts?");

/***/ }),

/***/ "./ts/objects/REGame_System.ts":
/*!*************************************!*\
  !*** ./ts/objects/REGame_System.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REGame_System = void 0;\r\n/**\r\n * グローバル設定\r\n */\r\nvar REGame_System = /** @class */ (function () {\r\n    function REGame_System() {\r\n        /**  */\r\n        this._mainPlayerEntityId = 0;\r\n    }\r\n    return REGame_System;\r\n}());\r\nexports.REGame_System = REGame_System;\r\n\n\n//# sourceURL=webpack:///./ts/objects/REGame_System.ts?");

/***/ }),

/***/ "./ts/objects/State.ts":
/*!*****************************!*\
  !*** ./ts/objects/State.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LState = void 0;\r\nvar RECommand_1 = __webpack_require__(/*! ts/system/RECommand */ \"./ts/system/RECommand.ts\");\r\n/**\r\n * State\r\n *\r\n * 各メソッドは Behavior と同一\r\n */\r\nvar LState = /** @class */ (function () {\r\n    function LState() {\r\n        this._dataId = 0;\r\n    }\r\n    LState.prototype.onQueryProperty = function (propertyId) { return undefined; };\r\n    LState.prototype.onQueryActions = function () { return []; };\r\n    LState.prototype.onDecisionPhase = function (entity, context, phase) { return RECommand_1.REResponse.Pass; };\r\n    LState.prototype.onPreAction = function (entity, context, cmd) { return RECommand_1.REResponse.Pass; };\r\n    LState.prototype.onPreReaction = function (entity, context, cmd) { return RECommand_1.REResponse.Pass; };\r\n    LState.prototype.onAction = function (entity, context, cmd) { return RECommand_1.REResponse.Pass; };\r\n    LState.prototype.onReaction = function (entity, context, cmd) { return RECommand_1.REResponse.Pass; };\r\n    return LState;\r\n}());\r\nexports.LState = LState;\r\n\n\n//# sourceURL=webpack:///./ts/objects/State.ts?");

/***/ }),

/***/ "./ts/objects/attributes/RETileAttribute.ts":
/*!**************************************************!*\
  !*** ./ts/objects/attributes/RETileAttribute.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RETileAttribute = void 0;\r\nvar REGame_Block_1 = __webpack_require__(/*! ../../RE/REGame_Block */ \"./ts/RE/REGame_Block.ts\");\r\nvar REGame_Attribute_1 = __webpack_require__(/*! ../../RE/REGame_Attribute */ \"./ts/RE/REGame_Attribute.ts\");\r\nvar RETileAttribute = /** @class */ (function (_super) {\r\n    __extends(RETileAttribute, _super);\r\n    function RETileAttribute() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this._data = {\r\n            tileKind: REGame_Block_1.TileKind.Floor,\r\n        };\r\n        return _this;\r\n    }\r\n    RETileAttribute.prototype.tileKind = function () { return this._data.tileKind; };\r\n    RETileAttribute.prototype.setTileKind = function (value) { this._data.tileKind = value; return this; };\r\n    RETileAttribute.prototype.data = function () {\r\n        return this._data;\r\n    };\r\n    return RETileAttribute;\r\n}(REGame_Attribute_1.REGame_Attribute));\r\nexports.RETileAttribute = RETileAttribute;\r\n\n\n//# sourceURL=webpack:///./ts/objects/attributes/RETileAttribute.ts?");

/***/ }),

/***/ "./ts/objects/behaviors/REDecisionBehavior.ts":
/*!****************************************************!*\
  !*** ./ts/objects/behaviors/REDecisionBehavior.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REGame_DecisionBehavior = void 0;\r\nvar REManualDecisionDialog_1 = __webpack_require__(/*! ts/dialogs/REManualDecisionDialog */ \"./ts/dialogs/REManualDecisionDialog.ts\");\r\nvar RECommand_1 = __webpack_require__(/*! ../../system/RECommand */ \"./ts/system/RECommand.ts\");\r\nvar REGame_Behavior_1 = __webpack_require__(/*! ../../RE/REGame_Behavior */ \"./ts/RE/REGame_Behavior.ts\");\r\nvar REGame_1 = __webpack_require__(/*! ts/RE/REGame */ \"./ts/RE/REGame.ts\");\r\nvar REData_1 = __webpack_require__(/*! ts/data/REData */ \"./ts/data/REData.ts\");\r\n/**\r\n * Scheduler から通知された各タイミングにおいて、行動決定を行う Behavior.\r\n *\r\n * この Behavior は標準的な行動決定のみ行う。\r\n * 状態異常による行動制限(&経過ターンのデクリメント)・暴走は、状態異常の Behavior 側で onDecisionPhase() をフックして実装する。\r\n */\r\nvar REGame_DecisionBehavior = /** @class */ (function (_super) {\r\n    __extends(REGame_DecisionBehavior, _super);\r\n    function REGame_DecisionBehavior() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    REGame_DecisionBehavior.prototype.onDecisionPhase = function (entity, context, phase) {\r\n        if (phase == REGame_Behavior_1.DecisionPhase.Manual) { // TODO: Manual っていう名前が良くない気がするので直したい。\r\n            context.openDialog(entity, new REManualDecisionDialog_1.REManualActionDialog());\r\n            return RECommand_1.REResponse.Consumed;\r\n        }\r\n        else if (phase == REGame_Behavior_1.DecisionPhase.AIMinor) {\r\n            // 右へ移動するだけ\r\n            //let dir = 6;\r\n            // ランダム移動\r\n            var table = [1, 2, 3, 4, 6, 7, 8, 9];\r\n            var dir = table[REGame_1.REGame.world.random().nextIntWithMax(8)];\r\n            if (dir != 0 && REGame_1.REGame.map.checkPassage(entity, dir)) {\r\n                context.postAction(REData_1.REData.DirectionChangeActionId, entity, undefined, { direction: dir });\r\n                context.postAction(REData_1.REData.MoveToAdjacentActionId, entity, undefined, { direction: dir });\r\n            }\r\n            context.postConsumeActionToken(entity);\r\n            return RECommand_1.REResponse.Consumed;\r\n        }\r\n        return RECommand_1.REResponse.Pass;\r\n    };\r\n    return REGame_DecisionBehavior;\r\n}(REGame_Behavior_1.REGame_Behavior));\r\nexports.REGame_DecisionBehavior = REGame_DecisionBehavior;\r\n\n\n//# sourceURL=webpack:///./ts/objects/behaviors/REDecisionBehavior.ts?");

/***/ }),

/***/ "./ts/objects/behaviors/REExitPointBehavior.ts":
/*!*****************************************************!*\
  !*** ./ts/objects/behaviors/REExitPointBehavior.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REExitPointBehavior = void 0;\r\nvar REData_1 = __webpack_require__(/*! ts/data/REData */ \"./ts/data/REData.ts\");\r\nvar EventExecutionDialog_1 = __webpack_require__(/*! ts/dialogs/EventExecutionDialog */ \"./ts/dialogs/EventExecutionDialog.ts\");\r\nvar REGame_Behavior_1 = __webpack_require__(/*! ts/RE/REGame_Behavior */ \"./ts/RE/REGame_Behavior.ts\");\r\nvar REGame_Block_1 = __webpack_require__(/*! ts/RE/REGame_Block */ \"./ts/RE/REGame_Block.ts\");\r\nvar RECommand_1 = __webpack_require__(/*! ts/system/RECommand */ \"./ts/system/RECommand.ts\");\r\nvar RESystem_1 = __webpack_require__(/*! ts/system/RESystem */ \"./ts/system/RESystem.ts\");\r\n/**\r\n * [2020/11/1] NOTE: Player が乗ったときの UI 表示タイミング\r\n * ----------\r\n * 乗った瞬間ではなく、乗った次のターンの Dialog 表示時である点に注意。\r\n * ただ、これはアイテムなど「あしもと」に対して行う表示と同様のシステムになりそう。\r\n * - アイテムを拾うのは手番内。\r\n * - アイテムに「のった」表示も手番内。\r\n * - お店のアイテムにのったときの UI 表示は次のターン。\r\n *\r\n * あとこれはコアシステムとして必須の機能ではなくて、ユーザビリティのための便利機能。\r\n *\r\n * Dialog 側で足元の Entty の種別をみて Window 表示とかやると、また拡張性が微妙になる。\r\n * できれば Item や階段の Behavior 側の「乗られた」Reaction で、\r\n * 「次の Player Dialog Open時に表示したいユーザビリティアクション」みたいなものを、PlayerEntity の set して実現したいところ。\r\n * set はしてるけど、次に Player が行動不能だったりしたら破棄するだけ。\r\n *\r\n * …と考えてみたが、階段上へ移動 → モンスターの吹き飛ばしで階段上以外へ移動 → そのあとは UI 表示しない といこともあるので、この対策が何か必要。\r\n *\r\n * HC4 の時に実装したリアクションコマンド形式がいいかも。\r\n * Behavior に問い合わせ用のメソッド追加する必要があるけど、Entity に対してどんなアクションをとれるか聞く仕組みがあると自然。\r\n */\r\nvar REExitPointBehavior = /** @class */ (function (_super) {\r\n    __extends(REExitPointBehavior, _super);\r\n    function REExitPointBehavior() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    REExitPointBehavior.prototype.onQueryProperty = function (propertyId) {\r\n        if (propertyId == RESystem_1.RESystem.properties.homeLayer)\r\n            return REGame_Block_1.BlockLayerKind.Ground;\r\n        else\r\n            _super.prototype.onQueryProperty.call(this, propertyId);\r\n    };\r\n    REExitPointBehavior.prototype.onQueryActions = function () {\r\n        return [REData_1.REData.ProceedFloorActionId];\r\n    };\r\n    REExitPointBehavior.prototype.onReaction = function (entity, context, cmd) {\r\n        if (cmd.action().id == REData_1.REData.ProceedFloorActionId) {\r\n            //const event = $gameMap.event(entity.rmmzEventId);\r\n            context.openDialog(entity, new EventExecutionDialog_1.RE.EventExecutionDialog(entity.rmmzEventId));\r\n        }\r\n        return RECommand_1.REResponse.Pass;\r\n    };\r\n    return REExitPointBehavior;\r\n}(REGame_Behavior_1.REGame_Behavior));\r\nexports.REExitPointBehavior = REExitPointBehavior;\r\n\n\n//# sourceURL=webpack:///./ts/objects/behaviors/REExitPointBehavior.ts?");

/***/ }),

/***/ "./ts/objects/behaviors/REUnitBehavior.ts":
/*!************************************************!*\
  !*** ./ts/objects/behaviors/REUnitBehavior.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REUnitBehavior = void 0;\r\nvar RECommand_1 = __webpack_require__(/*! ../../system/RECommand */ \"./ts/system/RECommand.ts\");\r\nvar REGame_Behavior_1 = __webpack_require__(/*! ../../RE/REGame_Behavior */ \"./ts/RE/REGame_Behavior.ts\");\r\nvar REData_1 = __webpack_require__(/*! ts/data/REData */ \"./ts/data/REData.ts\");\r\nvar REGame_1 = __webpack_require__(/*! ts/RE/REGame */ \"./ts/RE/REGame.ts\");\r\nvar RESystem_1 = __webpack_require__(/*! ts/system/RESystem */ \"./ts/system/RESystem.ts\");\r\nvar Helpers_1 = __webpack_require__(/*! ts/system/Helpers */ \"./ts/system/Helpers.ts\");\r\n/**\r\n *\r\n */\r\nvar REUnitBehavior = /** @class */ (function (_super) {\r\n    __extends(REUnitBehavior, _super);\r\n    function REUnitBehavior() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    REUnitBehavior.prototype.onQueryReactions = function () {\r\n        return [REData_1.REData.AttackActionId];\r\n    };\r\n    REUnitBehavior.prototype.onAction = function (entity, context, cmd) {\r\n        if (cmd.action().id == REData_1.REData.DirectionChangeActionId) {\r\n            cmd.actor().dir = cmd.args().direction;\r\n            return RECommand_1.REResponse.Consumed;\r\n        }\r\n        else if (cmd.action().id == REData_1.REData.MoveToAdjacentActionId) {\r\n            var args = cmd.args();\r\n            var offset = Helpers_1.Helpers.dirToTileOffset(args.direction);\r\n            if (REGame_1.REGame.map.moveEntity(entity, entity.x + offset.x, entity.y + offset.y, entity.queryProperty(RESystem_1.RESystem.properties.homeLayer))) {\r\n                context.postSequel(entity, RESystem_1.RESystem.sequels.MoveSequel);\r\n                // 次の DialogOpen 時に足元の優先コマンドを表示したりする\r\n                entity.immediatelyAfterAdjacentMoving = true;\r\n                return RECommand_1.REResponse.Consumed;\r\n            }\r\n        }\r\n        else if (cmd.action().id == REData_1.REData.ProceedFloorActionId) {\r\n            console.log(\"★\");\r\n        }\r\n        else if (cmd.action().id == REData_1.REData.AttackActionId) {\r\n            console.log(\"AttackAction\");\r\n            context.postSequel(entity, RESystem_1.RESystem.sequels.attack);\r\n            /*\r\n\r\n\r\n            context.postActionToBlock();\r\n            */\r\n            return RECommand_1.REResponse.Consumed;\r\n        }\r\n        return RECommand_1.REResponse.Pass;\r\n    };\r\n    REUnitBehavior.prototype.onReaction = function (entity, context, cmd) {\r\n        if (cmd.action().id == REData_1.REData.AttackActionId) {\r\n            console.log(\"onReaction AttackAction\");\r\n            context.postSequel(entity, RESystem_1.RESystem.sequels.attack);\r\n            /*\r\n\r\n\r\n            context.postActionToBlock();\r\n            */\r\n            entity.destroy();\r\n            return RECommand_1.REResponse.Consumed;\r\n        }\r\n        return RECommand_1.REResponse.Pass;\r\n    };\r\n    return REUnitBehavior;\r\n}(REGame_Behavior_1.REGame_Behavior));\r\nexports.REUnitBehavior = REUnitBehavior;\r\n\n\n//# sourceURL=webpack:///./ts/objects/behaviors/REUnitBehavior.ts?");

/***/ }),

/***/ "./ts/objects/skills/SkillBehavior.ts":
/*!********************************************!*\
  !*** ./ts/objects/skills/SkillBehavior.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.VNormalAttackSkillBehavior = exports.VSkillBehavior = void 0;\r\nvar REData_1 = __webpack_require__(/*! ts/data/REData */ \"./ts/data/REData.ts\");\r\nvar REGame_1 = __webpack_require__(/*! ts/RE/REGame */ \"./ts/RE/REGame.ts\");\r\nvar Helpers_1 = __webpack_require__(/*! ts/system/Helpers */ \"./ts/system/Helpers.ts\");\r\nvar VSkillBehavior = /** @class */ (function () {\r\n    function VSkillBehavior() {\r\n    }\r\n    return VSkillBehavior;\r\n}());\r\nexports.VSkillBehavior = VSkillBehavior;\r\nvar VNormalAttackSkillBehavior = /** @class */ (function (_super) {\r\n    __extends(VNormalAttackSkillBehavior, _super);\r\n    function VNormalAttackSkillBehavior() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    VNormalAttackSkillBehavior.prototype.onPerforme = function (entity, context) {\r\n        console.log(\"VNormalAttackSkillBehavior\");\r\n        var front = Helpers_1.Helpers.makeEntityFrontPosition(entity, 1);\r\n        var block = REGame_1.REGame.map.block(front.x, front.y);\r\n        var reacor = context.findReactorEntityInBlock(block, REData_1.REData.AttackActionId);\r\n        context.postAction(REData_1.REData.AttackActionId, entity, reacor);\r\n    };\r\n    return VNormalAttackSkillBehavior;\r\n}(VSkillBehavior));\r\nexports.VNormalAttackSkillBehavior = VNormalAttackSkillBehavior;\r\n\n\n//# sourceURL=webpack:///./ts/objects/skills/SkillBehavior.ts?");

/***/ }),

/***/ "./ts/objects/states/DebugMoveRightState.ts":
/*!**************************************************!*\
  !*** ./ts/objects/states/DebugMoveRightState.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LDebugMoveRightState = void 0;\r\nvar REData_1 = __webpack_require__(/*! ts/data/REData */ \"./ts/data/REData.ts\");\r\nvar REGame_1 = __webpack_require__(/*! ts/RE/REGame */ \"./ts/RE/REGame.ts\");\r\nvar RECommand_1 = __webpack_require__(/*! ts/system/RECommand */ \"./ts/system/RECommand.ts\");\r\nvar State_1 = __webpack_require__(/*! ../State */ \"./ts/objects/State.ts\");\r\nvar LDebugMoveRightState = /** @class */ (function (_super) {\r\n    __extends(LDebugMoveRightState, _super);\r\n    function LDebugMoveRightState() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    LDebugMoveRightState.prototype.onDecisionPhase = function (entity, context, phase) {\r\n        console.log(\"★LDebugMoveRightState\");\r\n        // 右へ移動するだけ\r\n        var dir = 6;\r\n        // ランダム移動\r\n        //const table = [1,2,3,4,6,7,8,9];\r\n        //const dir = table[REGame.world.random().nextIntWithMax(8)];\r\n        if (dir != 0 && REGame_1.REGame.map.checkPassage(entity, dir)) {\r\n            context.postAction(REData_1.REData.DirectionChangeActionId, entity, undefined, { direction: dir });\r\n            context.postAction(REData_1.REData.MoveToAdjacentActionId, entity, undefined, { direction: dir });\r\n        }\r\n        context.postConsumeActionToken(entity);\r\n        return RECommand_1.REResponse.Consumed;\r\n    };\r\n    return LDebugMoveRightState;\r\n}(State_1.LState));\r\nexports.LDebugMoveRightState = LDebugMoveRightState;\r\n\n\n//# sourceURL=webpack:///./ts/objects/states/DebugMoveRightState.ts?");

/***/ }),

/***/ "./ts/rmmz/RMMZHelper.ts":
/*!*******************************!*\
  !*** ./ts/rmmz/RMMZHelper.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RMMZHelper = void 0;\r\nvar RMMZHelper = /** @class */ (function () {\r\n    function RMMZHelper() {\r\n    }\r\n    RMMZHelper.readEntityMetadata = function (event) {\r\n        if (event._pageIndex >= 0) {\r\n            var list = event.list();\r\n            if (list) {\r\n                // collect comments\r\n                var comments = \"\";\r\n                for (var i = 0; i < list.length; i++) {\r\n                    if (list[i].code == 108 || list[i].code == 408) {\r\n                        if (list[i].parameters) {\r\n                            comments += list[i].parameters;\r\n                        }\r\n                    }\r\n                }\r\n                var index = comments.indexOf(\"@REEntity\");\r\n                if (index >= 0) {\r\n                    var block = comments.substring(index + 6);\r\n                    block = block.substring(block.indexOf(\"{\"), block.indexOf(\"}\") + 1);\r\n                    var metadata = {};\r\n                    eval(\"metadata = \" + block);\r\n                    return metadata;\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    return RMMZHelper;\r\n}());\r\nexports.RMMZHelper = RMMZHelper;\r\n\n\n//# sourceURL=webpack:///./ts/rmmz/RMMZHelper.ts?");

/***/ }),

/***/ "./ts/system/Helpers.ts":
/*!******************************!*\
  !*** ./ts/system/Helpers.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Helpers = void 0;\r\nvar Vector2_1 = __webpack_require__(/*! ts/math/Vector2 */ \"./ts/math/Vector2.ts\");\r\nvar Helpers = /** @class */ (function () {\r\n    function Helpers() {\r\n    }\r\n    Helpers.dirToTileOffset = function (dir) {\r\n        return this._dirToTileOffsetTable[dir];\r\n    };\r\n    Helpers.makeFrontPosition = function (x, y, dir, length) {\r\n        var offset = this._dirToTileOffsetTable[dir];\r\n        return new Vector2_1.Vector2(x + offset.x * length, y + offset.y * length);\r\n    };\r\n    Helpers.makeEntityFrontPosition = function (entity, length) {\r\n        var offset = this._dirToTileOffsetTable[entity.dir];\r\n        return new Vector2_1.Vector2(entity.x + offset.x * length, entity.y + offset.y * length);\r\n    };\r\n    Helpers._dirToTileOffsetTable = [\r\n        { x: 0, y: 0 },\r\n        { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 },\r\n        { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 },\r\n        { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },\r\n    ];\r\n    return Helpers;\r\n}());\r\nexports.Helpers = Helpers;\r\n\n\n//# sourceURL=webpack:///./ts/system/Helpers.ts?");

/***/ }),

/***/ "./ts/system/RECommand.ts":
/*!********************************!*\
  !*** ./ts/system/RECommand.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RECommand = exports.REResponse = void 0;\r\nvar REData_1 = __webpack_require__(/*! ../data/REData */ \"./ts/data/REData.ts\");\r\n/** RECommand の処理結果 */\r\nvar REResponse;\r\n(function (REResponse) {\r\n    /** 目的の処理を実行し終え、 RECommand は実行済みであることを示します。後続の Behavior に RECommand は通知されません。 */\r\n    REResponse[REResponse[\"Consumed\"] = 0] = \"Consumed\";\r\n    /** RECommand はハンドリングされませんでした。続けて後続の Behavior に RECommand を通知します。 */\r\n    REResponse[REResponse[\"Pass\"] = 1] = \"Pass\";\r\n    /** 状態異常の制限により、目的の処理を実行できなかったことを示します。後続の Behavior に RECommand は通知されません。 */\r\n    REResponse[REResponse[\"Canceled\"] = 2] = \"Canceled\";\r\n    //Aborted,\r\n})(REResponse = exports.REResponse || (exports.REResponse = {}));\r\n/** Command 表現及び引数 */\r\nvar RECommand // sealed\r\n = /** @class */ (function () {\r\n    function RECommand(actionId, actor, reactor, args) {\r\n        this._actionId = actionId;\r\n        this._actor = actor;\r\n        this._reactor = reactor;\r\n        this._args = args;\r\n    }\r\n    /** この Command の発生元となった Action */\r\n    RECommand.prototype.action = function () { return REData_1.REData.actions[this._actionId]; };\r\n    RECommand.prototype.args = function () { return this._args; };\r\n    /** Action 側 Entity */\r\n    RECommand.prototype.actor = function () {\r\n        if (this._actor)\r\n            return this._actor;\r\n        else\r\n            throw new Error();\r\n    };\r\n    /** Reaction 側 Entity */\r\n    RECommand.prototype.reactor = function () { return this._reactor; };\r\n    RECommand.prototype.save = function () {\r\n        return JSON.stringify({ act: this._actionId, args: this.args });\r\n    };\r\n    return RECommand;\r\n}());\r\nexports.RECommand = RECommand;\r\n\n\n//# sourceURL=webpack:///./ts/system/RECommand.ts?");

/***/ }),

/***/ "./ts/system/RECommandContext.ts":
/*!***************************************!*\
  !*** ./ts/system/RECommandContext.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RECommandContext = void 0;\r\nvar RECommand_1 = __webpack_require__(/*! ./RECommand */ \"./ts/system/RECommand.ts\");\r\nvar Common_1 = __webpack_require__(/*! ts/Common */ \"./ts/Common.ts\");\r\nvar REGame_Sequel_1 = __webpack_require__(/*! ts/RE/REGame_Sequel */ \"./ts/RE/REGame_Sequel.ts\");\r\nvar RESystem_1 = __webpack_require__(/*! ./RESystem */ \"./ts/system/RESystem.ts\");\r\nvar RECommandContext = /** @class */ (function () {\r\n    function RECommandContext(owner) {\r\n        this._visualAnimationWaiting = false; // 不要かも\r\n        this._recodingCommandList = [];\r\n        this._runningCommandList = [];\r\n        this._messageIndex = 0;\r\n        this._lastActorResponce = RECommand_1.REResponse.Pass;\r\n        this._lastReactorResponce = RECommand_1.REResponse.Pass;\r\n        this._commandChainRunning = false;\r\n        this._owner = owner;\r\n    }\r\n    RECommandContext.prototype.postAction = function (actionId, actor, reactor, args) {\r\n        var _this = this;\r\n        Common_1.assert(actionId > 0);\r\n        var actualCommand = new RECommand_1.RECommand(actionId, actor, reactor, args);\r\n        var m1 = function () {\r\n            Common_1.Log.doCommand(\"PreAction\");\r\n            return actor._sendPreAction(_this, actualCommand);\r\n        };\r\n        this._recodingCommandList.push({ name: \"sendPreAction\", func: m1 });\r\n        if (reactor) {\r\n            var m2 = function () {\r\n                if (_this._lastActorResponce == RECommand_1.REResponse.Pass) { // m1 で未処理なら send\r\n                    Common_1.Log.doCommand(\"PreRection\");\r\n                    return reactor._sendPreRection(_this, actualCommand);\r\n                }\r\n                else\r\n                    return _this._lastActorResponce;\r\n            };\r\n            this._recodingCommandList.push({ name: \"sendPreRection\", func: m2 });\r\n        }\r\n        var m3 = function () {\r\n            if (_this._lastActorResponce == RECommand_1.REResponse.Pass) { // m2 で未処理なら send\r\n                Common_1.Log.doCommand(\"Action\");\r\n                return actor._sendAction(_this, actualCommand);\r\n            }\r\n            else\r\n                return _this._lastActorResponce;\r\n        };\r\n        this._recodingCommandList.push({ name: \"sendAction\", func: m3 });\r\n        if (reactor) {\r\n            var m4 = function () {\r\n                if (_this._lastActorResponce == RECommand_1.REResponse.Pass) { // m3 で未処理なら send\r\n                    Common_1.Log.doCommand(\"Reaction\");\r\n                    return reactor._sendReaction(_this, actualCommand);\r\n                }\r\n                else\r\n                    return _this._lastActorResponce;\r\n            };\r\n            this._recodingCommandList.push({ name: \"sendReaction\", func: m4 });\r\n        }\r\n        Common_1.Log.postCommand(\"postAction\");\r\n    };\r\n    /*\r\n    postActionToBlock(actionId: number, actor: REGame_Entity, block: REGame_Block, args?: any) {\r\n        // 送信対象検索\r\n        let reactor = thi;\r\n        if (!reactor) {\r\n            return;\r\n        }\r\n\r\n        this.postAction(actionId, actor, reactor, args);\r\n    }\r\n    */\r\n    RECommandContext.prototype.findReactorEntityInBlock = function (block, actionId) {\r\n        var layers = block.layers();\r\n        for (var iLayer = layers.length - 1; iLayer >= 0; iLayer--) { // 上の Layer から\r\n            var reactor = layers[iLayer].entities().find(function (entity) { return entity.queryReactions().find(function (x) { return x == actionId; }) != undefined; });\r\n            if (reactor)\r\n                return reactor;\r\n        }\r\n        return undefined;\r\n    };\r\n    RECommandContext.prototype.openDialog = function (causeEntity, dialogModel) {\r\n        var _this = this;\r\n        var m1 = function () {\r\n            Common_1.Log.doCommand(\"OpenDialog\");\r\n            _this._owner._openDialogModel(causeEntity, dialogModel);\r\n            return RECommand_1.REResponse.Consumed;\r\n        };\r\n        this._recodingCommandList.push({ name: \"openDialog\", func: m1 });\r\n        Common_1.Log.postCommand(\"openDialog\");\r\n    };\r\n    RECommandContext.prototype.postSequel = function (entity, sequelId) {\r\n        var _this = this;\r\n        Common_1.assert(sequelId > 0);\r\n        var m1 = function () {\r\n            Common_1.Log.doCommand(\"Sequel\");\r\n            _this._owner.addSequel(new REGame_Sequel_1.REGame_Sequel(entity, sequelId));\r\n            _this._visualAnimationWaiting = true;\r\n            return RECommand_1.REResponse.Consumed;\r\n        };\r\n        this._recodingCommandList.push({ name: \"Sequel\", func: m1 });\r\n        Common_1.Log.postCommand(\"Sequel\");\r\n    };\r\n    RECommandContext.prototype.postConsumeActionToken = function (entity) {\r\n        var _this = this;\r\n        var m1 = function () {\r\n            Common_1.Log.doCommand(\"ConsumeActionToken\");\r\n            _this._owner.consumeActionToken(entity);\r\n            return RECommand_1.REResponse.Consumed;\r\n        };\r\n        this._recodingCommandList.push({ name: \"ConsumeActionToken\", func: m1 });\r\n        Common_1.Log.postCommand(\"ConsumeActionToken\");\r\n    };\r\n    RECommandContext.prototype.postPerformSkill = function (performer, skillId) {\r\n        var _this = this;\r\n        var m1 = function () {\r\n            Common_1.Log.doCommand(\"PerformSkill\");\r\n            RESystem_1.RESystem.skillBehaviors[skillId].onPerforme(performer, _this);\r\n            return RECommand_1.REResponse.Consumed;\r\n        };\r\n        this._recodingCommandList.push({ name: \"PerformSkill\", func: m1 });\r\n        Common_1.Log.postCommand(\"PerformSkill\");\r\n    };\r\n    // Skill や Item などの効果適用。\r\n    // MP cost など発動可能判定は呼び出す前に済ませること。\r\n    RECommandContext.prototype.postApplyEffect = function (context) {\r\n        var m1 = function () {\r\n            Common_1.Log.doCommand(\"ApplyEffect\");\r\n            // TODO:\r\n            return RECommand_1.REResponse.Consumed;\r\n        };\r\n        this._recodingCommandList.push({ name: \"ApplyEffect\", func: m1 });\r\n        Common_1.Log.postCommand(\"ApplyEffect\");\r\n    };\r\n    RECommandContext.prototype.visualAnimationWaiting = function () {\r\n        return this._visualAnimationWaiting;\r\n    };\r\n    RECommandContext.prototype.clearVisualAnimationWaiting = function () {\r\n        this._visualAnimationWaiting = false;\r\n    };\r\n    RECommandContext.prototype.isRunning = function () {\r\n        return this._messageIndex < this._runningCommandList.length;\r\n    };\r\n    /*\r\n    _process(): boolean {\r\n        if (this.isRunning()) {\r\n            // コマンドリスト実行中\r\n            this._processCommand();\r\n            \r\n            if (!this.isRunning()) {\r\n                // 実行終了。\r\n                this._owner.\r\n            }\r\n        }\r\n\r\n        \r\n        if (!this.isRunning() && this._recodingCommandList.length > 0) {\r\n            // _runningCommandList は終了したが、_recodingCommandList に次のコマンドチェーンが溜まっていればそれの実行を始める\r\n            this._submit();\r\n        }\r\n\r\n        // _runningCommandList にも _recodingCommandList にもコマンドが無ければ false を返して、スケジューリングフェーズを次に進める\r\n        return this.isRunning();\r\n    }\r\n    */\r\n    RECommandContext.prototype._processCommand = function () {\r\n        if (this.isRunning()) {\r\n            var message = this._runningCommandList[this._messageIndex];\r\n            var response = message.func();\r\n            if (this._owner._getDialogContext()._hasDialogModel()) {\r\n                // もし command の実行で Dialog が表示されたときは index を進めない。\r\n                // Dialog が閉じたときに進めるが、例えば矢弾を装備したとき等はターンの消費しないので進めない。\r\n            }\r\n            else {\r\n                this._next();\r\n            }\r\n        }\r\n    };\r\n    RECommandContext.prototype._next = function () {\r\n        Common_1.assert(this._commandChainRunning);\r\n        this._messageIndex++;\r\n        if (this._messageIndex >= this._runningCommandList.length) {\r\n            this._commandChainRunning = false;\r\n            Common_1.Log.d(\"<<<<[End CommandChain]\");\r\n            // CommandChain 中に post されたものがあれば、続けて swap して実行開始してみる\r\n            if (this._recodingCommandList.length > 0) {\r\n                this._submit();\r\n            }\r\n        }\r\n    };\r\n    // Decision の後に実行する\r\n    RECommandContext.prototype._submit = function () {\r\n        var _a;\r\n        Common_1.assert(!this._commandChainRunning);\r\n        // swap\r\n        _a = [this._recodingCommandList, this._runningCommandList], this._runningCommandList = _a[0], this._recodingCommandList = _a[1];\r\n        // clear\r\n        this._recodingCommandList.splice(0);\r\n        this._messageIndex = 0;\r\n        if (this._runningCommandList.length > 0) {\r\n            Common_1.Log.d(\">>>>[Start CommandChain]\");\r\n            this._commandChainRunning = true;\r\n            //this.dumpCommands();\r\n        }\r\n    };\r\n    RECommandContext.prototype.dumpCommands = function () {\r\n        console.log(\"Commands:\");\r\n        this._runningCommandList.forEach(function (x) {\r\n            console.log(\"  \" + x.name);\r\n        });\r\n    };\r\n    return RECommandContext;\r\n}());\r\nexports.RECommandContext = RECommandContext;\r\n\n\n//# sourceURL=webpack:///./ts/system/RECommandContext.ts?");

/***/ }),

/***/ "./ts/system/RECommandRecorder.ts":
/*!****************************************!*\
  !*** ./ts/system/RECommandRecorder.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RECommandRecorder = exports.RERecordingCommandType = void 0;\r\nvar fs = __importStar(__webpack_require__(/*! fs */ \"fs\"));\r\nvar Common_1 = __webpack_require__(/*! ts/Common */ \"./ts/Common.ts\");\r\nvar RERecordingCommandType;\r\n(function (RERecordingCommandType) {\r\n    RERecordingCommandType[RERecordingCommandType[\"Action\"] = 1] = \"Action\";\r\n    RERecordingCommandType[RERecordingCommandType[\"Sequel\"] = 2] = \"Sequel\";\r\n    RERecordingCommandType[RERecordingCommandType[\"ConsumeActionToken\"] = 3] = \"ConsumeActionToken\";\r\n})(RERecordingCommandType = exports.RERecordingCommandType || (exports.RERecordingCommandType = {}));\r\nvar RECommandRecorder = /** @class */ (function () {\r\n    function RECommandRecorder() {\r\n        this._recording = true;\r\n        this._stream = fs.createWriteStream(\"test.txt\");\r\n    }\r\n    RECommandRecorder.prototype.isRecording = function () {\r\n        return this._recording;\r\n    };\r\n    RECommandRecorder.prototype.push = function (cmd) {\r\n        Common_1.assert(this._recording);\r\n        this._stream.write(JSON.stringify(cmd) + \"\\n\");\r\n    };\r\n    return RECommandRecorder;\r\n}());\r\nexports.RECommandRecorder = RECommandRecorder;\r\n\n\n//# sourceURL=webpack:///./ts/system/RECommandRecorder.ts?");

/***/ }),

/***/ "./ts/system/REDialog.ts":
/*!*******************************!*\
  !*** ./ts/system/REDialog.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REDialog = exports.REDialogContext = void 0;\r\nvar Common_1 = __webpack_require__(/*! ts/Common */ \"./ts/Common.ts\");\r\nvar REGame_1 = __webpack_require__(/*! ts/RE/REGame */ \"./ts/RE/REGame.ts\");\r\nvar RECommandRecorder_1 = __webpack_require__(/*! ./RECommandRecorder */ \"./ts/system/RECommandRecorder.ts\");\r\nvar RESystem_1 = __webpack_require__(/*! ./RESystem */ \"./ts/system/RESystem.ts\");\r\nvar REDialogContext = /** @class */ (function () {\r\n    //_visual: REDialogVisual | undefined;\r\n    function REDialogContext(owner, commandContext) {\r\n        this._owner = owner;\r\n        this._commandContext = commandContext;\r\n        this._dialogModel = null;\r\n    }\r\n    REDialogContext.prototype.causeEntity = function () {\r\n        return this._causeEntity;\r\n    };\r\n    REDialogContext.prototype.dialog = function () {\r\n        if (this._dialogModel)\r\n            return this._dialogModel;\r\n        else\r\n            throw new Error(\"_dialogModel\");\r\n    };\r\n    REDialogContext.prototype.commandContext = function () {\r\n        return this._commandContext;\r\n    };\r\n    REDialogContext.prototype.postAction = function (actionId, actor, reactor, args) {\r\n        this._commandContext.postAction(actionId, actor, reactor, args);\r\n        if (REGame_1.REGame.recorder.isRecording()) {\r\n            REGame_1.REGame.recorder.push({\r\n                type: RECommandRecorder_1.RERecordingCommandType.Action,\r\n                data: {\r\n                    actionId: actionId,\r\n                    actorEntityId: actor.id(),\r\n                    reactorEntityId: (reactor) ? reactor.id() : 0,\r\n                    args: args,\r\n                }\r\n            });\r\n        }\r\n    };\r\n    REDialogContext.prototype.closeDialog = function (consumeAction) {\r\n        if (consumeAction && this._causeEntity) {\r\n            //this._owner.consumeActionToken(this._causeEntity);\r\n            this._commandContext.postConsumeActionToken(this._causeEntity);\r\n            if (REGame_1.REGame.recorder.isRecording()) {\r\n                REGame_1.REGame.recorder.push({\r\n                    type: RECommandRecorder_1.RERecordingCommandType.ConsumeActionToken,\r\n                    data: {\r\n                        entityId: this._causeEntity.id(),\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        this._owner._closeDialogModel();\r\n        this._commandContext._next();\r\n    };\r\n    REDialogContext.prototype.setCauseEntity = function (value) {\r\n        this._causeEntity = value;\r\n    };\r\n    REDialogContext.prototype._setDialogModel = function (value) {\r\n        this._dialogModel = value;\r\n    };\r\n    REDialogContext.prototype._hasDialogModel = function () {\r\n        return this._dialogModel !== null;\r\n    };\r\n    REDialogContext.prototype._update = function () {\r\n        Common_1.assert(this._dialogModel !== null);\r\n        //REGame.recorder._recording = true;\r\n        this._dialogModel.onUpdate(this);\r\n        RESystem_1.RESystem.integration.onUpdateDialog(this);\r\n        //REGame.recorder._recording = false;\r\n        //if (this._visual) {\r\n        //    this._visual.onUpdate(this);\r\n        //}\r\n    };\r\n    return REDialogContext;\r\n}());\r\nexports.REDialogContext = REDialogContext;\r\n/**\r\n * GameDialog\r\n *\r\n * Dialog と名前がついているが、必ずしも UI を持つものではない。\r\n * 名前通り、エンドユーザーとの「対話」のためのインターフェイスを実装する。\r\n */\r\nvar REDialog = /** @class */ (function () {\r\n    function REDialog() {\r\n    }\r\n    REDialog.prototype.onUpdate = function (context) { };\r\n    return REDialog;\r\n}());\r\nexports.REDialog = REDialog;\r\n\n\n//# sourceURL=webpack:///./ts/system/REDialog.ts?");

/***/ }),

/***/ "./ts/system/REEntityFactory.ts":
/*!**************************************!*\
  !*** ./ts/system/REEntityFactory.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REEntityFactory = void 0;\r\nvar REGame_Attribute_1 = __webpack_require__(/*! ../RE/REGame_Attribute */ \"./ts/RE/REGame_Attribute.ts\");\r\nvar REData_1 = __webpack_require__(/*! ../data/REData */ \"./ts/data/REData.ts\");\r\nvar REGame_1 = __webpack_require__(/*! ../RE/REGame */ \"./ts/RE/REGame.ts\");\r\nvar REDecisionBehavior_1 = __webpack_require__(/*! ../objects/behaviors/REDecisionBehavior */ \"./ts/objects/behaviors/REDecisionBehavior.ts\");\r\nvar REUnitBehavior_1 = __webpack_require__(/*! ../objects/behaviors/REUnitBehavior */ \"./ts/objects/behaviors/REUnitBehavior.ts\");\r\nvar RETileAttribute_1 = __webpack_require__(/*! ../objects/attributes/RETileAttribute */ \"./ts/objects/attributes/RETileAttribute.ts\");\r\nvar REExitPointBehavior_1 = __webpack_require__(/*! ts/objects/behaviors/REExitPointBehavior */ \"./ts/objects/behaviors/REExitPointBehavior.ts\");\r\nvar REEntityFactory = /** @class */ (function () {\r\n    function REEntityFactory() {\r\n    }\r\n    REEntityFactory.newTile = function (kind) {\r\n        var entity = REGame_1.REGame.world.spawnEntity();\r\n        entity.addAttribute(new RETileAttribute_1.RETileAttribute().setTileKind(kind));\r\n        return entity;\r\n    };\r\n    REEntityFactory.newActor = function () {\r\n        var e = REGame_1.REGame.world.spawnEntity();\r\n        e.attrbutes = [\r\n            new REGame_Attribute_1.REGame_UnitAttribute()\r\n                .setFactionId(REData_1.REData.ActorDefaultFactionId),\r\n        ];\r\n        e.addBasicBehavior(new REDecisionBehavior_1.REGame_DecisionBehavior());\r\n        e.addBasicBehavior(new REUnitBehavior_1.REUnitBehavior());\r\n        return e;\r\n    };\r\n    REEntityFactory.newMonster = function (monsterId) {\r\n        var e = REGame_1.REGame.world.spawnEntity();\r\n        e.attrbutes = [\r\n            new REGame_Attribute_1.REGame_UnitAttribute()\r\n                .setFactionId(REData_1.REData.EnemeyDefaultFactionId),\r\n        ];\r\n        e.addBasicBehavior(new REDecisionBehavior_1.REGame_DecisionBehavior());\r\n        e.addBasicBehavior(new REUnitBehavior_1.REUnitBehavior());\r\n        return e;\r\n    };\r\n    REEntityFactory.newExitPoint = function () {\r\n        var e = REGame_1.REGame.world.spawnEntity();\r\n        e.addBasicBehavior(new REExitPointBehavior_1.REExitPointBehavior());\r\n        return e;\r\n    };\r\n    return REEntityFactory;\r\n}());\r\nexports.REEntityFactory = REEntityFactory;\r\n\n\n//# sourceURL=webpack:///./ts/system/REEntityFactory.ts?");

/***/ }),

/***/ "./ts/system/REGameManager.ts":
/*!************************************!*\
  !*** ./ts/system/REGameManager.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REGameManager = void 0;\r\nvar REGame_1 = __webpack_require__(/*! ../RE/REGame */ \"./ts/RE/REGame.ts\");\r\nvar REEntityFactory_1 = __webpack_require__(/*! ./REEntityFactory */ \"./ts/system/REEntityFactory.ts\");\r\nvar REGame_Map_1 = __webpack_require__(/*! ../RE/REGame_Map */ \"./ts/RE/REGame_Map.ts\");\r\nvar REGame_World_1 = __webpack_require__(/*! ../RE/REGame_World */ \"./ts/RE/REGame_World.ts\");\r\nvar REGame_Core_1 = __webpack_require__(/*! ../RE/REGame_Core */ \"./ts/RE/REGame_Core.ts\");\r\nvar REData_1 = __webpack_require__(/*! ../data/REData */ \"./ts/data/REData.ts\");\r\nvar REScheduler_1 = __webpack_require__(/*! ./REScheduler */ \"./ts/system/REScheduler.ts\");\r\nvar REGame_Attribute_1 = __webpack_require__(/*! ../RE/REGame_Attribute */ \"./ts/RE/REGame_Attribute.ts\");\r\nvar REGame_Camera_1 = __webpack_require__(/*! ../objects/REGame_Camera */ \"./ts/objects/REGame_Camera.ts\");\r\nvar REGame_System_1 = __webpack_require__(/*! ../objects/REGame_System */ \"./ts/objects/REGame_System.ts\");\r\nvar RESystem_1 = __webpack_require__(/*! ./RESystem */ \"./ts/system/RESystem.ts\");\r\nvar RECommandRecorder_1 = __webpack_require__(/*! ./RECommandRecorder */ \"./ts/system/RECommandRecorder.ts\");\r\nvar SkillBehavior_1 = __webpack_require__(/*! ts/objects/skills/SkillBehavior */ \"./ts/objects/skills/SkillBehavior.ts\");\r\n/**\r\n */\r\nvar REGameManager = /** @class */ (function () {\r\n    function REGameManager() {\r\n    }\r\n    // DataManager.createGameObjects に従って呼び出される。\r\n    // ゲーム起動時に1回呼び出される点に注意。NewGame 選択時に改めて1回呼び出される。\r\n    REGameManager.createGameObjects = function () {\r\n        REGame_1.REGame.scheduler = new REScheduler_1.REScheduler();\r\n        REGame_1.REGame.core = new REGame_Core_1.REGame_Core();\r\n        REGame_1.REGame.system = new REGame_System_1.REGame_System();\r\n        REGame_1.REGame.world = new REGame_World_1.RE_Game_World();\r\n        REGame_1.REGame.map = new REGame_Map_1.REGame_Map();\r\n        REGame_1.REGame.camera = new REGame_Camera_1.REGame_Camera();\r\n        REGame_1.REGame.uniqueActorUnits = [];\r\n        REGame_1.REGame.recorder = new RECommandRecorder_1.RECommandRecorder();\r\n        // Create unique units\r\n        REData_1.REData.actors.forEach(function (x) {\r\n            if (x.id > 0) {\r\n                var unit_1 = REEntityFactory_1.REEntityFactory.newActor();\r\n                unit_1.prefabKey.kind = RESystem_1.RESystem.entityKinds.actor;\r\n                unit_1.prefabKey.id = x.id;\r\n                unit_1.floorId = x.initialFloorId;\r\n                unit_1.x = x.initialX;\r\n                unit_1.y = x.initialY;\r\n                REGame_1.REGame.uniqueActorUnits.push(unit_1);\r\n                //const attr = unit.findAttribute(REGame_PositionalAttribute);\r\n                //if (attr) {\r\n                //}\r\n            }\r\n        });\r\n        // TODO: とりあえずまずは全部同じにしてテスト\r\n        RESystem_1.RESystem.skillBehaviors = REData_1.REData.skills.map(function (x) { return new SkillBehavior_1.VNormalAttackSkillBehavior(); });\r\n        // 1 番 Actor をデフォルトで操作可能とする\r\n        var firstActor = REGame_1.REGame.uniqueActorUnits[0];\r\n        REGame_1.REGame.core.mainPlayerEntiyId = firstActor._id;\r\n        REGame_1.REGame.system._mainPlayerEntityId = firstActor._id;\r\n        var unit = firstActor.findAttribute(REGame_Attribute_1.REGame_UnitAttribute);\r\n        if (unit) {\r\n            unit.setManualMovement(true);\r\n        }\r\n        REGame_1.REGame.camera.focus(firstActor);\r\n        /*\r\n                let a = RE_Game_EntityFactory.newActor();\r\n                let b = a.findAttribute(RE_Game_UnitAttribute);\r\n                let c = a.findAttribute(RE_Game_PositionalAttribute);\r\n                console.log(\"b: \", b);\r\n                console.log(\"c: \", c);\r\n                */\r\n    };\r\n    REGameManager.performFloorTransfer = function () {\r\n        if (REGame_1.REGame.camera.isFloorTransfering()) {\r\n            // マップ構築\r\n            REGame_1.REGame.map._removeAllEntities();\r\n            REGame_1.REGame.map.setup(REGame_1.REGame.camera.transferingNewFloorId());\r\n            REGame_1.REGame.world.enterEntitiesToCurrentMap();\r\n            REGame_1.REGame.camera.clearFloorTransfering();\r\n        }\r\n    };\r\n    REGameManager.update = function () {\r\n        if (REGame_1.REGame.camera.isFloorTransfering()) {\r\n            // マップ遷移中はコアシステムとしては何もしない。\r\n            // performFloorTransfer() すること。\r\n            return;\r\n        }\r\n        REGame_1.REGame.scheduler.stepSimulation();\r\n    };\r\n    return REGameManager;\r\n}());\r\nexports.REGameManager = REGameManager;\r\n\n\n//# sourceURL=webpack:///./ts/system/REGameManager.ts?");

/***/ }),

/***/ "./ts/system/REIntegration.ts":
/*!************************************!*\
  !*** ./ts/system/REIntegration.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REIntegration = void 0;\r\nvar REIntegration = /** @class */ (function () {\r\n    function REIntegration() {\r\n    }\r\n    return REIntegration;\r\n}());\r\nexports.REIntegration = REIntegration;\r\n\n\n//# sourceURL=webpack:///./ts/system/REIntegration.ts?");

/***/ }),

/***/ "./ts/system/REMapBuilder.ts":
/*!***********************************!*\
  !*** ./ts/system/REMapBuilder.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REMapBuilder = void 0;\r\nvar RETileAttribute_1 = __webpack_require__(/*! ts/objects/attributes/RETileAttribute */ \"./ts/objects/attributes/RETileAttribute.ts\");\r\nvar Common_1 = __webpack_require__(/*! ts/Common */ \"./ts/Common.ts\");\r\n/**\r\n * 地形生成を行うモジュールに対して、マップデータへのアクセスを提供するクラス。\r\n * 直接 REGame_Map に触れるのは危険 & 余計に気にする API が多すぎるので、ラップしたもの。\r\n */\r\nvar REMapBuilder = /** @class */ (function () {\r\n    function REMapBuilder(map) {\r\n        this._map = map;\r\n    }\r\n    REMapBuilder.prototype.floorId = function () {\r\n        return this._map.floorId();\r\n    };\r\n    REMapBuilder.prototype.width = function () {\r\n        return this._map.width();\r\n    };\r\n    REMapBuilder.prototype.height = function () {\r\n        return this._map.height();\r\n    };\r\n    REMapBuilder.prototype.reset = function (width, height) {\r\n        this._map.setupEmptyMap(width, height);\r\n    };\r\n    REMapBuilder.prototype.setTileKind = function (x, y, value) {\r\n        if (x < 0 || this.width() <= x || y < 0 || this.height() <= y) {\r\n            throw new Error();\r\n        }\r\n        var tile = this._map.block(x, y).tile();\r\n        var attr = tile.findAttribute(RETileAttribute_1.RETileAttribute);\r\n        Common_1.assert(attr);\r\n        attr.setTileKind(value);\r\n    };\r\n    return REMapBuilder;\r\n}());\r\nexports.REMapBuilder = REMapBuilder;\r\n\n\n//# sourceURL=webpack:///./ts/system/REMapBuilder.ts?");

/***/ }),

/***/ "./ts/system/REScheduler.ts":
/*!**********************************!*\
  !*** ./ts/system/REScheduler.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REScheduler = void 0;\r\nvar Common_1 = __webpack_require__(/*! ../Common */ \"./ts/Common.ts\");\r\nvar RECommandContext_1 = __webpack_require__(/*! ./RECommandContext */ \"./ts/system/RECommandContext.ts\");\r\nvar REData_1 = __webpack_require__(/*! ../data/REData */ \"./ts/data/REData.ts\");\r\nvar REDialog_1 = __webpack_require__(/*! ./REDialog */ \"./ts/system/REDialog.ts\");\r\nvar REGame_1 = __webpack_require__(/*! ../RE/REGame */ \"./ts/RE/REGame.ts\");\r\nvar REGame_Attribute_1 = __webpack_require__(/*! ../RE/REGame_Attribute */ \"./ts/RE/REGame_Attribute.ts\");\r\nvar REGame_Behavior_1 = __webpack_require__(/*! ../RE/REGame_Behavior */ \"./ts/RE/REGame_Behavior.ts\");\r\nvar REGame_Sequel_1 = __webpack_require__(/*! ts/RE/REGame_Sequel */ \"./ts/RE/REGame_Sequel.ts\");\r\nvar RESystem_1 = __webpack_require__(/*! ./RESystem */ \"./ts/system/RESystem.ts\");\r\n;\r\n;\r\nvar SchedulerPhase;\r\n(function (SchedulerPhase) {\r\n    SchedulerPhase[SchedulerPhase[\"TurnStarting\"] = 0] = \"TurnStarting\";\r\n    SchedulerPhase[SchedulerPhase[\"RunStarting\"] = 1] = \"RunStarting\";\r\n    /**\r\n     * マニュアル入力\r\n     * Dialog が close すると、次の Phase に進む。\r\n     */\r\n    SchedulerPhase[SchedulerPhase[\"ManualAction\"] = 2] = \"ManualAction\";\r\n    /**\r\n     * AI 行動フェーズ 1\r\n     * モンスターの移動・攻撃対象決定\r\n     */\r\n    SchedulerPhase[SchedulerPhase[\"AIMinorAction\"] = 3] = \"AIMinorAction\";\r\n    /**\r\n     * AI 行動フェーズ 2\r\n     */\r\n    SchedulerPhase[SchedulerPhase[\"AIMajorAction\"] = 4] = \"AIMajorAction\";\r\n    SchedulerPhase[SchedulerPhase[\"RunEnding\"] = 5] = \"RunEnding\";\r\n    SchedulerPhase[SchedulerPhase[\"TurnEnding\"] = 6] = \"TurnEnding\";\r\n})(SchedulerPhase || (SchedulerPhase = {}));\r\n/**\r\n * see Scheduler.md\r\n */\r\nvar REScheduler = /** @class */ (function () {\r\n    function REScheduler() {\r\n        this._phase = SchedulerPhase.TurnStarting;\r\n        this._units = [];\r\n        this._runs = [];\r\n        this._currentRun = 0;\r\n        this._currentStep = 0;\r\n        this._sequelSet = new REGame_Sequel_1.RESequelSet();\r\n        this._actionConsumed = false;\r\n        this._commandContext = new RECommandContext_1.RECommandContext(this);\r\n        this._dialogContext = new REDialog_1.REDialogContext(this, this._commandContext);\r\n    }\r\n    REScheduler.prototype.commandContext = function () {\r\n        return this._commandContext;\r\n    };\r\n    REScheduler.prototype.actionScheduleTable = function () {\r\n        return this._runs;\r\n    };\r\n    REScheduler.prototype.stepSimulation = function () {\r\n        while (true) {\r\n            // Sequel 終了待ち\r\n            if (RESystem_1.RESystem.integration.onCheckVisualSequelRunning()) {\r\n                // Sequel 実行中\r\n                break;\r\n            }\r\n            /*\r\n            if (this._commandContext.visualAnimationWaiting()) {\r\n                if (RESystem.integration.onCheckVisualSequelRunning()) {\r\n                    // Sequel 実行中\r\n                    break;\r\n                }\r\n                else {\r\n                    // Sequel 終了\r\n                    this._commandContext.clearVisualAnimationWaiting();\r\n                }\r\n            }\r\n            */\r\n            // 現在のコマンドリストの実行は終了しているが、Visual 側がアニメーション中であれば完了を待ってから次の Unit の行動を始めたい\r\n            if (!this._commandContext.isRunning() && RESystem_1.RESystem.integration.onCheckVisualSequelRunning()) {\r\n                break;\r\n            }\r\n            // Dialog の処理はイベント実行よりも優先する。\r\n            // 行商人の処理など。\r\n            if (this._dialogContext._hasDialogModel()) {\r\n                this._dialogContext._update();\r\n                var entity = this._dialogContext.causeEntity();\r\n                if (entity) {\r\n                    entity.immediatelyAfterAdjacentMoving = false;\r\n                }\r\n                if (this._dialogContext._hasDialogModel()) {\r\n                    // Dialog 表示中は後続コマンドを実行しない\r\n                    break;\r\n                }\r\n                else {\r\n                    // update() で Dialog が Close された。\r\n                    // すぐに post されたコマンドの実行を始める。\r\n                    // こうしておかないと、移動 Sequel 開始までに 1Frame 空いてしまうため、一瞬遅延してみえてしまう。\r\n                }\r\n            }\r\n            if (this._commandContext.isRunning()) {\r\n                this._commandContext._processCommand();\r\n                if (!this._commandContext.isRunning()) {\r\n                    // _processCommand() の後で isRunning が落ちていたら、\r\n                    // 実行中コマンドリストの実行が完了した。\r\n                }\r\n                // 攻撃などのメジャーアクションで同期的　Sequel が post されていれば flush.\r\n                // もし歩行など並列のみであればあとでまとめて実行したので不要。\r\n                if (!this._sequelSet.isAllParallel()) {\r\n                    this.flushSequelSet();\r\n                }\r\n            }\r\n            if (this._commandContext.isRunning()) {\r\n                // コマンド実行中。まだフェーズを進ませない\r\n            }\r\n            else {\r\n                //sweepCollapseList();\r\n                //m_commandContext->beginCommandChain();\r\n                this.stepSimulationInternal();\r\n            }\r\n        }\r\n    };\r\n    REScheduler.prototype.stepSimulationInternal = function () {\r\n        switch (this._phase) {\r\n            case SchedulerPhase.TurnStarting:\r\n                this.update_TurnStarting();\r\n                break;\r\n            case SchedulerPhase.RunStarting:\r\n                this.update_RunStarting();\r\n                break;\r\n            case SchedulerPhase.ManualAction:\r\n                this.update_ManualAction();\r\n                break;\r\n            case SchedulerPhase.AIMinorAction:\r\n                this.update_AIMinorAction();\r\n                break;\r\n            case SchedulerPhase.AIMajorAction:\r\n                this.update_AIMajorAction();\r\n                break;\r\n            case SchedulerPhase.RunEnding:\r\n                this.update_RunEnding();\r\n                break;\r\n            case SchedulerPhase.TurnEnding:\r\n                this.update_TurnEnding();\r\n                break;\r\n            default:\r\n                Common_1.assert(0);\r\n                break;\r\n        }\r\n    };\r\n    REScheduler.prototype.update_TurnStarting = function () {\r\n        Common_1.Log.d(\"========== [TurnStarting] ==========\");\r\n        this.buildOrderTable();\r\n        // ターン開始時の各 unit の設定更新\r\n        this._units.forEach(function (unit) {\r\n            var attr = unit.attr;\r\n            // 鈍足状態の対応。待ちターン数を更新\r\n            if (attr.speedLevel() < 0) {\r\n                if (attr.waitTurnCount() == 0) {\r\n                    attr.setWaitTurnCount(1);\r\n                }\r\n                else {\r\n                    attr.setWaitTurnCount(attr.waitTurnCount() - 1);\r\n                }\r\n            }\r\n            // 行動トークンを更新\r\n            if (attr.waitTurnCount() == 0) {\r\n                // 行動トークンを、速度の分だけ配る。鈍足状態でも 1 つ配る。\r\n                // リセットではなく追加である点に注意。借金している場合に備える。\r\n                attr.setActionTokenCount(attr.actionTokenCount() + Math.max(1, attr.speedLevel()));\r\n            }\r\n            else {\r\n                // 鈍足状態。このターンは行動トークンをもらえない。\r\n            }\r\n        });\r\n        this._currentRun = 0;\r\n        this._phase = SchedulerPhase.RunStarting;\r\n        Common_1.Log.d(\"e update_TurnStarting\");\r\n    };\r\n    REScheduler.prototype.update_RunStarting = function () {\r\n        Common_1.Log.d(\"s update_RunStarting\");\r\n        this._currentStep = -1;\r\n        this._phase = SchedulerPhase.ManualAction;\r\n        this._runs.forEach(function (run) {\r\n            run.steps.forEach(function (step) {\r\n                step.unit.attr._targetingEntityId = 0;\r\n            });\r\n        });\r\n        Common_1.Log.d(\"e update_RunStarting\");\r\n    };\r\n    REScheduler.prototype.consumeActionToken = function (entity) {\r\n        var attr = entity.findAttribute(REGame_Attribute_1.REGame_UnitAttribute);\r\n        Common_1.assert(attr);\r\n        attr.setActionTokenCount(attr.actionTokenCount() - 1); // ここで借金することもあり得る\r\n        //this.nextActionUnit();\r\n        this._actionConsumed = true;\r\n    };\r\n    /*\r\n    nextActionUnit() {\r\n        const run = this._runs[this._currentRun];\r\n        const step = run.steps[this._currentStep];\r\n\r\n        if (this._phase == SchedulerPhase.AIMinorAction && step.unit.attr._targetingEntityId > 0) {\r\n            //\r\n            this._currentStep++;\r\n        }\r\n        else {\r\n            if (step.iterationCount > 0) {\r\n                step.iterationCount--;\r\n                console.log(\"decl iterationCount:\", step.iterationCount, step.unit.unit?._name);\r\n                console.trace();\r\n            }\r\n            \r\n            if (step.iterationCount <= 0) {\r\n                this._currentStep++;\r\n            }\r\n        }\r\n        \r\n\r\n    }\r\n    */\r\n    REScheduler.prototype.prepareActionPhase = function () {\r\n        var run = this._runs[this._currentRun];\r\n        if (this._currentStep < 0) {\r\n            // 初回\r\n            this._currentStep++;\r\n        }\r\n        else {\r\n            // ひとつ前の callDecisionPhase() を基点に実行された 1 つ以上ののコマンドチェーンの結果を確認\r\n            if (this._actionConsumed) {\r\n                // 行動トークンを消費する行動がとられた。\r\n                var step = run.steps[this._currentStep];\r\n                step.iterationCount--;\r\n                if (step.iterationCount <= 0) {\r\n                    this._currentStep++;\r\n                }\r\n                else {\r\n                    // まだ iterationCount が残っているので、同じ Step を再び実行する\r\n                }\r\n            }\r\n            else {\r\n                // 向き変更のみなど、行動トークンは消費しなかった\r\n            }\r\n        }\r\n    };\r\n    REScheduler.prototype.update_ManualAction = function () {\r\n        // ひとつ前の callDecisionPhase() を基点に実行された 1 つ以上ののコマンドチェーンの結果を処理\r\n        this.prepareActionPhase();\r\n        var run = this._runs[this._currentRun];\r\n        while (true) {\r\n            if (this._currentStep >= run.steps.length) {\r\n                this._currentStep = -1;\r\n                this._phase = SchedulerPhase.AIMinorAction;\r\n                return;\r\n            }\r\n            var step = run.steps[this._currentStep];\r\n            var unit = step.unit;\r\n            if (unit.entity && unit.attr.manualMovement() && unit.attr.actionTokenCount() > 0) {\r\n                unit.entity._callDecisionPhase(this._commandContext, REGame_Behavior_1.DecisionPhase.Manual);\r\n                this._commandContext._submit(); // swap\r\n                return;\r\n            }\r\n            else {\r\n                // このフェーズでは実行できない step だった。次の step へ。\r\n                this._currentStep++;\r\n            }\r\n        }\r\n    };\r\n    REScheduler.prototype.update_AIMinorAction = function () {\r\n        // ひとつ前の callDecisionPhase() を基点に実行された 1 つ以上ののコマンドチェーンの結果を処理\r\n        this.prepareActionPhase();\r\n        var run = this._runs[this._currentRun];\r\n        while (true) {\r\n            if (this._currentStep >= run.steps.length) {\r\n                this._currentStep = -1;\r\n                this._phase = SchedulerPhase.AIMajorAction;\r\n                return;\r\n            }\r\n            var step = run.steps[this._currentStep];\r\n            var unit = step.unit;\r\n            if (unit.entity && !unit.attr.manualMovement() && unit.attr.actionTokenCount() > 0 &&\r\n                unit.attr._targetingEntityId <= 0) { // Minor では行動対象決定の判定も見る\r\n                unit.entity._callDecisionPhase(this._commandContext, REGame_Behavior_1.DecisionPhase.AIMinor);\r\n                this._commandContext._submit(); // swap\r\n                return;\r\n            }\r\n            else {\r\n                // このフェーズでは実行できない step だった。次の step へ。\r\n                this._currentStep++;\r\n            }\r\n        }\r\n    };\r\n    REScheduler.prototype.update_AIMajorAction = function () {\r\n        // ひとつ前の callDecisionPhase() を基点に実行された 1 つ以上ののコマンドチェーンの結果を処理\r\n        this.prepareActionPhase();\r\n        var run = this._runs[this._currentRun];\r\n        while (true) {\r\n            if (this._currentStep >= run.steps.length) {\r\n                this._currentStep = -1;\r\n                this._phase = SchedulerPhase.RunEnding;\r\n                return;\r\n            }\r\n            var step = run.steps[this._currentStep];\r\n            var unit = step.unit;\r\n            if (unit.entity && !unit.attr.manualMovement() && unit.attr.actionTokenCount() > 0) {\r\n                unit.entity._callDecisionPhase(this._commandContext, REGame_Behavior_1.DecisionPhase.AIMajor);\r\n                this._commandContext._submit(); // swap\r\n                return;\r\n            }\r\n            else {\r\n                // このフェーズでは実行できない step だった。次の step へ。\r\n                this._currentStep++;\r\n            }\r\n        }\r\n    };\r\n    REScheduler.prototype.update_RunEnding = function () {\r\n        console.log(\"update_RunEnding\");\r\n        this._currentRun++;\r\n        if (this._currentRun >= this._runs.length) {\r\n            this._phase = SchedulerPhase.TurnEnding;\r\n        }\r\n        else {\r\n            this._phase = SchedulerPhase.RunStarting;\r\n        }\r\n    };\r\n    REScheduler.prototype.update_TurnEnding = function () {\r\n        console.log(\"update_TurnEnding flushSequelSet\");\r\n        // ターン終了時に Sequel が残っていればすべて掃き出す\r\n        this.flushSequelSet();\r\n        this._phase = SchedulerPhase.TurnStarting;\r\n    };\r\n    REScheduler.prototype.buildOrderTable = function () {\r\n        var _this = this;\r\n        this._units = [];\r\n        var runCount = 0;\r\n        // 行動できるすべての entity を集める\r\n        {\r\n            REGame_1.REGame.map.entities().forEach(function (entity) {\r\n                var attr = entity.findAttribute(REGame_Attribute_1.REGame_UnitAttribute);\r\n                if (attr) {\r\n                    Common_1.assert(attr.factionId() > 0);\r\n                    Common_1.assert(attr.speedLevel() != 0);\r\n                    var actionCount = attr.speedLevel();\r\n                    // 鈍足状態の対応\r\n                    if (actionCount < 0) {\r\n                        actionCount = 1;\r\n                    }\r\n                    _this._units.push({\r\n                        entity: entity,\r\n                        attr: attr,\r\n                        actionCount: actionCount\r\n                    });\r\n                    // このターン内の最大行動回数 (phase 数) を調べる\r\n                    runCount = Math.max(runCount, actionCount);\r\n                }\r\n            });\r\n        }\r\n        // 勢力順にソート\r\n        this._units = this._units.sort(function (a, b) { return REData_1.REData.factions[a.attr.factionId()].schedulingOrder - REData_1.REData.factions[b.attr.factionId()].schedulingOrder; });\r\n        this._runs = new Array(runCount);\r\n        for (var i = 0; i < this._runs.length; i++) {\r\n            this._runs[i] = { steps: [] };\r\n        }\r\n        // Faction にかかわらず、マニュアル操作 Unit は最優先で追加する\r\n        this._units.forEach(function (unit) {\r\n            if (unit.attr.manualMovement()) {\r\n                for (var i = 0; i < unit.actionCount; i++) {\r\n                    _this._runs[i].steps.push({\r\n                        unit: unit,\r\n                        iterationCount: 1,\r\n                    });\r\n                }\r\n            }\r\n        });\r\n        // 次は倍速以上の NPC. これは前から詰めていく。\r\n        this._units.forEach(function (unit) {\r\n            if (!unit.attr.manualMovement() && unit.actionCount >= 2) {\r\n                for (var i = 0; i < unit.actionCount; i++) {\r\n                    _this._runs[i].steps.push({\r\n                        unit: unit,\r\n                        iterationCount: 1,\r\n                    });\r\n                }\r\n            }\r\n        });\r\n        // 最後に等速以下の NPC を後ろから詰めていく\r\n        this._units.forEach(function (unit) {\r\n            if (!unit.attr.manualMovement() && unit.actionCount < 2) {\r\n                for (var i = 0; i < unit.actionCount; i++) {\r\n                    _this._runs[_this._runs.length - 1 - i].steps.push({\r\n                        unit: unit,\r\n                        iterationCount: 1,\r\n                    });\r\n                }\r\n            }\r\n        });\r\n        //console.log(\"unis:\", this._units);\r\n        //console.log(\"runs:\", this._runs);\r\n        // Merge\r\n        {\r\n            var flatSteps = this._runs.flatMap(function (x) { return x.steps; });\r\n            for (var i1 = flatSteps.length - 1; i1 >= 0; i1--) {\r\n                var step1 = flatSteps[i1];\r\n                // step1 の前方を検索\r\n                for (var i2 = i1 - 1; i2 >= 0; i2--) {\r\n                    var step2 = flatSteps[i2];\r\n                    if (step2.unit.attr.factionId() != step1.unit.attr.factionId()) {\r\n                        // 別勢力の行動予定が見つかったら終了\r\n                        break;\r\n                    }\r\n                    if (step2.unit.entity == step1.unit.entity) {\r\n                        // 勢力をまたがずに同一 entity の行動予定が見つかったら、\r\n                        // そちらへ iterationCount をマージする。\r\n                        step2.iterationCount += step1.iterationCount;\r\n                        step1.iterationCount = 0;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    REScheduler.prototype._foreachRunSteps = function (start, func) {\r\n        var each = false;\r\n        for (var i = 0; i < this._runs.length; i++) {\r\n            var run = this._runs[i];\r\n            for (var j = 0; j < run.steps.length; j++) {\r\n                if (!each && run.steps[i] == start) {\r\n                    each = true;\r\n                }\r\n                if (each) {\r\n                    if (!func(run.steps[i])) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    REScheduler.prototype._openDialogModel = function (causeEntity, value) {\r\n        this._dialogContext.setCauseEntity(causeEntity);\r\n        this._dialogContext._setDialogModel(value);\r\n        RESystem_1.RESystem.integration.onDialogOpend(this._dialogContext);\r\n        //const visual = \r\n        //this._dialogContext._visual = visual;\r\n    };\r\n    REScheduler.prototype._closeDialogModel = function () {\r\n        this._dialogContext._setDialogModel(null);\r\n        //if (this._dialogContext._visual) {\r\n        //    this._dialogContext._visual.onClose();\r\n        //    this._dialogContext._visual = undefined;\r\n        //}\r\n        RESystem_1.RESystem.integration.onDialogClosed(this._dialogContext);\r\n    };\r\n    REScheduler.prototype._getDialogContext = function () {\r\n        return this._dialogContext;\r\n    };\r\n    REScheduler.prototype.addSequel = function (sequel) {\r\n        this._sequelSet.addSequel(sequel);\r\n    };\r\n    REScheduler.prototype.flushSequelSet = function () {\r\n        Common_1.Log.d(\"[FlushSequel]\");\r\n        if (!this._sequelSet.isEmpty()) {\r\n            if (this.signalFlushSequelSet) {\r\n                this.signalFlushSequelSet(this._sequelSet);\r\n            }\r\n            RESystem_1.RESystem.integration.onFlushSequelSet(this._sequelSet);\r\n            this._sequelSet = new REGame_Sequel_1.RESequelSet();\r\n        }\r\n    };\r\n    return REScheduler;\r\n}());\r\nexports.REScheduler = REScheduler;\r\n\n\n//# sourceURL=webpack:///./ts/system/REScheduler.ts?");

/***/ }),

/***/ "./ts/system/RESystem.ts":
/*!*******************************!*\
  !*** ./ts/system/RESystem.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RESystem = void 0;\r\nvar REData_1 = __webpack_require__(/*! ts/data/REData */ \"./ts/data/REData.ts\");\r\nvar REGame_Block_1 = __webpack_require__(/*! ts/RE/REGame_Block */ \"./ts/RE/REGame_Block.ts\");\r\nvar RESystem = /** @class */ (function () {\r\n    function RESystem() {\r\n    }\r\n    RESystem.createAttribute = function (dataId) {\r\n        var i = REData_1.REData._attributeFactories[dataId]();\r\n        i.dataId = dataId;\r\n        return i;\r\n    };\r\n    RESystem.createBehavior = function (dataId) {\r\n        var i = REData_1.REData._behaviorFactories[dataId]();\r\n        i.dataId = dataId;\r\n        return i;\r\n    };\r\n    RESystem.createState = function (dataId) {\r\n        var i = REData_1.REData._stateFactories[dataId]();\r\n        i._dataId = dataId;\r\n        return i;\r\n    };\r\n    RESystem.propertyData = [\r\n        { id: 0, defaultValue: undefined },\r\n        { id: 1, defaultValue: REGame_Block_1.BlockLayerKind.Unit }\r\n    ];\r\n    RESystem.properties = {\r\n        homeLayer: 1,\r\n    };\r\n    return RESystem;\r\n}());\r\nexports.RESystem = RESystem;\r\n\n\n//# sourceURL=webpack:///./ts/system/RESystem.ts?");

/***/ }),

/***/ "./ts/visual/REDialogVisual.ts":
/*!*************************************!*\
  !*** ./ts/visual/REDialogVisual.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REDialogVisualNavigator = exports.REDialogVisualWindowLayer = void 0;\r\nvar Common_1 = __webpack_require__(/*! ts/Common */ \"./ts/Common.ts\");\r\nvar REGame_1 = __webpack_require__(/*! ts/RE/REGame */ \"./ts/RE/REGame.ts\");\r\nvar REVisual_1 = __webpack_require__(/*! ./REVisual */ \"./ts/visual/REVisual.ts\");\r\nvar REDialogVisualWindowLayer = /** @class */ (function () {\r\n    function REDialogVisualWindowLayer() {\r\n        this._started = false;\r\n        this._windows = [];\r\n    }\r\n    REDialogVisualWindowLayer.prototype.dialogContext = function () {\r\n        return REGame_1.REGame.scheduler._getDialogContext();\r\n    };\r\n    //protected commandContext(): RECommandContext {\r\n    //    return REGame.scheduler.commandContext();\r\n    //}\r\n    // SubDialog が push されたとき\r\n    REDialogVisualWindowLayer.prototype.onCreate = function () {\r\n    };\r\n    // SubDialog が push されたとき\r\n    REDialogVisualWindowLayer.prototype.onStart = function () {\r\n    };\r\n    REDialogVisualWindowLayer.prototype.onUpdate = function (context) {\r\n    };\r\n    REDialogVisualWindowLayer.prototype.onClose = function () {\r\n    };\r\n    // SubDialog が push されたとき\r\n    REDialogVisualWindowLayer.prototype.onStop = function () {\r\n    };\r\n    // ウィンドウ破棄とかはここで\r\n    REDialogVisualWindowLayer.prototype.onDestroy = function () {\r\n        this._windows.forEach(function (x) {\r\n            x.destroy(undefined);\r\n        });\r\n    };\r\n    REDialogVisualWindowLayer.prototype.addWindow = function (window) {\r\n        SceneManager._scene.addWindow(window);\r\n        this._windows.push(window);\r\n    };\r\n    REDialogVisualWindowLayer.prototype.removeWindow = function (window) {\r\n        throw new Error(\"Not implemented.\");\r\n        //const windowLayer = SceneManager._scene._windowLayer as any;\r\n        //windowLayer.removeChild(window);\r\n    };\r\n    REDialogVisualWindowLayer.prototype.push = function (dialog) {\r\n        var _a;\r\n        (_a = REVisual_1.REVisual.manager) === null || _a === void 0 ? void 0 : _a._dialogNavigator.push(dialog);\r\n    };\r\n    REDialogVisualWindowLayer.prototype.pop = function () {\r\n        var _a;\r\n        (_a = REVisual_1.REVisual.manager) === null || _a === void 0 ? void 0 : _a._dialogNavigator.pop();\r\n    };\r\n    REDialogVisualWindowLayer.prototype.doneDialog = function (consumeAction) {\r\n        Common_1.assert(this._navigator);\r\n        this._navigator.clear();\r\n        return this.dialogContext().closeDialog(consumeAction);\r\n    };\r\n    return REDialogVisualWindowLayer;\r\n}());\r\nexports.REDialogVisualWindowLayer = REDialogVisualWindowLayer;\r\n/**\r\n * SceneManager と同じく、スタックで Sub Dialog を管理するクラス。\r\n *\r\n * SceneManager でメニュー表示などを実装すると、ウィンドウが表示されたときには Scene_Map の表示情報はすべて破棄されている。\r\n * そのため、ウィンドウを表示したままキャラクターをアニメーションさせることができない。\r\n *\r\n * このクラスはその対策として、Scene_Map 内でウィンドウの遷移管理を行う。\r\n */\r\nvar REDialogVisualNavigator = /** @class */ (function () {\r\n    function REDialogVisualNavigator() {\r\n        this._dialogs = [];\r\n    }\r\n    REDialogVisualNavigator.prototype.isEmpty = function () {\r\n        return !this._scene && !this._nextScene && this._dialogs.length == 0;\r\n    };\r\n    REDialogVisualNavigator.prototype.push = function (dialog) {\r\n        this._nextScene = dialog;\r\n        dialog._navigator = this;\r\n        if (this._scene) {\r\n            this._scene.onStop();\r\n        }\r\n    };\r\n    REDialogVisualNavigator.prototype.pop = function () {\r\n        this._nextScene = this._dialogs.pop();\r\n        if (this._scene) {\r\n            this._scene.onStop();\r\n        }\r\n    };\r\n    REDialogVisualNavigator.prototype.clear = function () {\r\n        if (this._scene) {\r\n            this._scene.onStop();\r\n            this._scene.onClose();\r\n            this._scene.onDestroy();\r\n        }\r\n        if (this._nextScene) {\r\n            this._nextScene.onStop();\r\n            this._nextScene.onClose();\r\n            this._nextScene.onDestroy();\r\n        }\r\n        for (var i = this._dialogs.length - 1; i >= 0; i--) {\r\n            this._dialogs[i].onStop();\r\n            this._dialogs[i].onClose();\r\n            this._dialogs[i].onDestroy();\r\n        }\r\n        this._dialogs = [];\r\n        this._scene = undefined;\r\n        this._nextScene = undefined;\r\n    };\r\n    REDialogVisualNavigator.prototype.update = function (context) {\r\n        this.changeScene();\r\n        this.updateScene(context);\r\n    };\r\n    REDialogVisualNavigator.prototype.changeScene = function () {\r\n        if (this._nextScene) {\r\n            if (this._scene) {\r\n                this._scene.onDestroy();\r\n            }\r\n            this._scene = this._nextScene;\r\n            this._nextScene = undefined;\r\n            if (this._scene) {\r\n                this._scene.onCreate();\r\n            }\r\n        }\r\n    };\r\n    REDialogVisualNavigator.prototype.updateScene = function (context) {\r\n        if (this._scene) {\r\n            if (this._scene._started) {\r\n                this._scene.onUpdate(context);\r\n            }\r\n            else {\r\n                this._scene._started = true;\r\n                this._scene.onStart();\r\n                this._scene.onUpdate(context);\r\n            }\r\n        }\r\n    };\r\n    return REDialogVisualNavigator;\r\n}());\r\nexports.REDialogVisualNavigator = REDialogVisualNavigator;\r\n\n\n//# sourceURL=webpack:///./ts/visual/REDialogVisual.ts?");

/***/ }),

/***/ "./ts/visual/REEntityVisualSet.ts":
/*!****************************************!*\
  !*** ./ts/visual/REEntityVisualSet.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REEntityVisualSet = void 0;\r\nvar REDataManager_1 = __webpack_require__(/*! ts/data/REDataManager */ \"./ts/data/REDataManager.ts\");\r\nvar REGame_1 = __webpack_require__(/*! ts/RE/REGame */ \"./ts/RE/REGame.ts\");\r\nvar REVisualSequelManager_1 = __webpack_require__(/*! ./REVisualSequelManager */ \"./ts/visual/REVisualSequelManager.ts\");\r\nvar REVisual_Entity_1 = __webpack_require__(/*! ./REVisual_Entity */ \"./ts/visual/REVisual_Entity.ts\");\r\n/**\r\n * EntityVisual の管理クラス。\r\n *\r\n * Spriteset_Map と同じように、Scene_Map の生成・破棄に合わせて Sprite の表示状態を制御する。\r\n * 実際にこのクラスが Sprite を生成するものではない点に注意。\r\n *\r\n * なお、Spriteset_Map は SceneManager.onBeforeSceneStart() からの Scene(PIXI.Stage) の destory により破棄される。\r\n */\r\nvar REEntityVisualSet = /** @class */ (function () {\r\n    function REEntityVisualSet() {\r\n        var _this = this;\r\n        this._visualEntities = [];\r\n        this._sequelManager = new REVisualSequelManager_1.REVisualSequelManager(this);\r\n        REGame_1.REGame.scheduler.signalFlushSequelSet = function (x) { return _this.handleFlushSequelSet(x); };\r\n        // init 時点の map 上にいる Entity から Visual を作る\r\n        REGame_1.REGame.map.entities().forEach(function (x) {\r\n            _this.createVisual(x);\r\n        });\r\n    }\r\n    REEntityVisualSet.prototype.ternimate = function () {\r\n        this._visualEntities = [];\r\n    };\r\n    REEntityVisualSet.prototype.update = function () {\r\n        this._sequelManager.update();\r\n        this._sequelManager.postUpdate();\r\n        this._visualEntities.forEach(function (x) {\r\n            x._update();\r\n        });\r\n        this._sequelManager.update();\r\n        this._sequelManager.postUpdate();\r\n    };\r\n    REEntityVisualSet.prototype.findEntityVisualByEntity = function (entity) {\r\n        return this._visualEntities.find(function (x) { return x.entity().id() == entity.id(); });\r\n    };\r\n    REEntityVisualSet.prototype.findEntityVisualByRMMZEventId = function (rmmzEventId) {\r\n        return this._visualEntities.find(function (x) { return x.rmmzEventId() == rmmzEventId; });\r\n    };\r\n    REEntityVisualSet.prototype.visualRunning = function () {\r\n        return this._sequelManager.isRunning();\r\n    };\r\n    REEntityVisualSet.prototype.deleteVisual = function (entity) {\r\n        var index = this._visualEntities.findIndex(function (x) { return x.entity() == entity; });\r\n        if (index >= 0) {\r\n            var visual = this._visualEntities[index];\r\n            // Game_Event の削除フラグを立てる。\r\n            // 次の Spriteset_Map で、実際に動的 Sprite が削除される。\r\n            $gameMap.event(visual.rmmzEventId()).erase();\r\n            // NOTE: このメソッドはマップ遷移時の全開放時もよばれるが、\r\n            // そのときはマップ遷移後に Spriteset_Map が新しいインスタンスで new されるため、\r\n            // ↑の erase() の意味もあまりないが、影響はないため現状とする。\r\n            this._visualEntities.splice(index, 1);\r\n        }\r\n    };\r\n    REEntityVisualSet.prototype.handleFlushSequelSet = function (sequelSet) {\r\n        this._sequelManager.setup(sequelSet);\r\n    };\r\n    REEntityVisualSet.prototype.createVisual = function (entity) {\r\n        var databaseMap = REDataManager_1.REDataManager.databaseMap();\r\n        if (!databaseMap || !databaseMap.events) {\r\n            throw new Error();\r\n        }\r\n        var event = undefined;\r\n        if (entity.prefabKey.kind > 0 && entity.prefabKey.id > 0) {\r\n            event = $gameMap.event(entity.rmmzEventId);\r\n        }\r\n        else if (entity.prefabKey.kind == 0 && entity.prefabKey.id > 0) {\r\n            // 固定マップ用。現在マップに出現しているイベントから作る\r\n            event = $gameMap.event(entity.prefabKey.id);\r\n        }\r\n        else {\r\n            // Tile などは Visual を作らない\r\n            return;\r\n            /*\r\n            eventData = {\r\n                id: 0,\r\n                name: \"null\",\r\n                note: \"\",\r\n                pages: [\r\n                    {\r\n                        conditions: {\r\n                            actorId: 1,\r\n                            actorValid: false,\r\n                            itemId: 1,\r\n                            itemValid: false,\r\n                            selfSwitchCh: \"A\",\r\n                            selfSwitchValid: false,\r\n                            switch1Id: 1,\r\n                            switch1Valid: false,\r\n                            switch2Id: 1,\r\n                            switch2Valid: false,\r\n                            variableId: 1,\r\n                            variableValid: false,\r\n                            variableValue: 1,\r\n                        },\r\n                        directionFix: false,\r\n                        image: {\r\n                            tileId: 0,\r\n                            characterName: \"\",\r\n                            direction: 2,\r\n                            pattern: 0,\r\n                            characterIndex: 1\r\n                        },\r\n                        list: [],\r\n                        moveFrequency: 3,\r\n                        moveRoute: {\r\n                            list: [],\r\n                            repeat: true,\r\n                            skippable: false,\r\n                            wait: false,\r\n                        },\r\n                        moveSpeed: 3,\r\n                        moveType: 0,\r\n                        priorityType: 1,\r\n                        stepAnime: false,\r\n                        through: false,\r\n                        trigger: 0,\r\n                        walkAnime: true,\r\n                    }\r\n                ],\r\n                x: 0,\r\n                y: 0,\r\n            };\r\n            */\r\n        }\r\n        if (!event) {\r\n            throw new Error();\r\n        }\r\n        var visual = new REVisual_Entity_1.REVisual_Entity(entity, event.eventId());\r\n        this._visualEntities.push(visual);\r\n    };\r\n    return REEntityVisualSet;\r\n}());\r\nexports.REEntityVisualSet = REEntityVisualSet;\r\n\n\n//# sourceURL=webpack:///./ts/visual/REEntityVisualSet.ts?");

/***/ }),

/***/ "./ts/visual/REManualActionDialogVisual.ts":
/*!*************************************************!*\
  !*** ./ts/visual/REManualActionDialogVisual.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REManualActionDialogVisual = void 0;\r\nvar Common_1 = __webpack_require__(/*! ts/Common */ \"./ts/Common.ts\");\r\nvar REData_1 = __webpack_require__(/*! ts/data/REData */ \"./ts/data/REData.ts\");\r\nvar REGame_1 = __webpack_require__(/*! ts/RE/REGame */ \"./ts/RE/REGame.ts\");\r\nvar REGame_Block_1 = __webpack_require__(/*! ts/RE/REGame_Block */ \"./ts/RE/REGame_Block.ts\");\r\nvar FootingDialogVisual_1 = __webpack_require__(/*! ./dialogs/FootingDialogVisual */ \"./ts/visual/dialogs/FootingDialogVisual.ts\");\r\nvar REDialogVisual_1 = __webpack_require__(/*! ./REDialogVisual */ \"./ts/visual/REDialogVisual.ts\");\r\nvar REManualActionDialogVisual = /** @class */ (function (_super) {\r\n    __extends(REManualActionDialogVisual, _super);\r\n    function REManualActionDialogVisual() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    REManualActionDialogVisual.prototype.onUpdate = function (context) {\r\n        var entity = context.causeEntity();\r\n        if (!entity)\r\n            return;\r\n        if (entity.immediatelyAfterAdjacentMoving) {\r\n            var block = REGame_1.REGame.map.block(entity.x, entity.y);\r\n            var layer = block.layer(REGame_Block_1.BlockLayerKind.Ground);\r\n            var targetEntities = layer.entities();\r\n            Common_1.assert(targetEntities.length <= 1); // TODO: 多種類は未対応\r\n            var targetEntity = targetEntities[0];\r\n            var actions = targetEntities.flatMap(function (x) { return x.queryActions(); });\r\n            if (actions.length > 0) {\r\n                console.log(\"SceneManager.push(Scene_Footing)\", actions);\r\n                this.push(new FootingDialogVisual_1.RE.FootingDialogVisual(targetEntity, actions));\r\n                //SceneManager.push(Scene_Footing);\r\n                return;\r\n            }\r\n        }\r\n        //if (Input.dir8 != 0 && Input.dir8 != entity.dir) {\r\n        //    context.postAction(REData.actions[REData.DirectionChangeActionId], entity, undefined, new REDirectionChangeCommand(Input.dir8));\r\n        //    context.closeDialog(false); // 行動消費無しで close\r\n        //}\r\n        var dir = Input.dir8;\r\n        // 移動\r\n        if (dir != 0 && REGame_1.REGame.map.checkPassage(entity, dir)) {\r\n            if (dir != 0) {\r\n                var args_1 = { direction: dir };\r\n                context.postAction(REData_1.REData.DirectionChangeActionId, entity, undefined, args_1);\r\n            }\r\n            var args = { direction: dir };\r\n            context.postAction(REData_1.REData.MoveToAdjacentActionId, entity, undefined, args);\r\n            context.closeDialog(true);\r\n            return;\r\n        }\r\n        // オートアクション\r\n        else if (Input.isTriggered(\"ok\")) {\r\n            // [通常攻撃] スキル発動\r\n            context.commandContext().postPerformSkill(entity, REData_1.REData.AttackActionId);\r\n            context.closeDialog(true);\r\n            return;\r\n        }\r\n    };\r\n    return REManualActionDialogVisual;\r\n}(REDialogVisual_1.REDialogVisualWindowLayer));\r\nexports.REManualActionDialogVisual = REManualActionDialogVisual;\r\n\n\n//# sourceURL=webpack:///./ts/visual/REManualActionDialogVisual.ts?");

/***/ }),

/***/ "./ts/visual/REVisual.ts":
/*!*******************************!*\
  !*** ./ts/visual/REVisual.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REVisual = void 0;\r\nvar REVisual_Manager_1 = __webpack_require__(/*! ./REVisual_Manager */ \"./ts/visual/REVisual_Manager.ts\");\r\n/**\r\n */\r\nvar REVisual = /** @class */ (function () {\r\n    function REVisual() {\r\n    }\r\n    REVisual.initialize = function () {\r\n        this.finalize();\r\n        this.manager = new REVisual_Manager_1.REVisual_Manager();\r\n    };\r\n    REVisual.finalize = function () {\r\n        if (this.manager) {\r\n            this.manager._finalize();\r\n            this.manager = undefined;\r\n        }\r\n    };\r\n    return REVisual;\r\n}());\r\nexports.REVisual = REVisual;\r\n\n\n//# sourceURL=webpack:///./ts/visual/REVisual.ts?");

/***/ }),

/***/ "./ts/visual/REVisualSequel.ts":
/*!*************************************!*\
  !*** ./ts/visual/REVisualSequel.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REVisualSequel_Move = exports.REVisualSequel = void 0;\r\nvar Vector2_1 = __webpack_require__(/*! ts/math/Vector2 */ \"./ts/math/Vector2.ts\");\r\nvar REVisualSequel = /** @class */ (function () {\r\n    function REVisualSequel() {\r\n    }\r\n    return REVisualSequel;\r\n}());\r\nexports.REVisualSequel = REVisualSequel;\r\n/**\r\n * 倍速移動など、1ターンに複数ブロックを移動する場合、その数だけ Sequel が生成される。\r\n * そうしないと、途中で立ち寄ったブロックを補完するようなアニメーションが表現できない。\r\n */\r\nvar REVisualSequel_Move = /** @class */ (function (_super) {\r\n    __extends(REVisualSequel_Move, _super);\r\n    function REVisualSequel_Move() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    REVisualSequel_Move.prototype.onUpdate = function (visual, context) {\r\n        // 移動は直線距離ではなく X Y 個別に計算する。\r\n        // 斜め移動時に速度が上がる問題であるが、複数の Entity が同時に移動するとき、\r\n        // 軸平行・斜め問わず完了までの時間が合うようにしないと、一方の動きが遅延してしまう。\r\n        var entity = visual.entity();\r\n        var moveSpeed = 4; // RMMZ の基本移動速度\r\n        var speed = Math.pow(2, moveSpeed) / 256;\r\n        //const frameCount = 1.0 / speed; // 水平1Tile移動に何Frame必要？\r\n        var velocity = Vector2_1.Vector2.mul(Vector2_1.Vector2.sub(new Vector2_1.Vector2(entity.x, entity.y), context.startPosition()), speed);\r\n        var d = Vector2_1.Vector2.sub(new Vector2_1.Vector2(entity.x, entity.y), visual.position());\r\n        if ((Math.abs(d.x) <= speed && Math.abs(d.y) <= speed) ||\r\n            context.frameCount() > 30) { // 速度に何か異常があっても、時間経過で必ず終了させる\r\n            visual.resetPosition();\r\n            context.end();\r\n            console.log(\"move end\", visual.position());\r\n        }\r\n        else {\r\n            //const v = Vector2.mul(Vector2.sign(d), speed);\r\n            visual.setPosition(Vector2_1.Vector2.add(visual.position(), velocity));\r\n            console.log(\"move seq\", visual.position());\r\n        }\r\n    };\r\n    return REVisualSequel_Move;\r\n}(REVisualSequel));\r\nexports.REVisualSequel_Move = REVisualSequel_Move;\r\n\n\n//# sourceURL=webpack:///./ts/visual/REVisualSequel.ts?");

/***/ }),

/***/ "./ts/visual/REVisualSequelContext.ts":
/*!********************************************!*\
  !*** ./ts/visual/REVisualSequelContext.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REVisualSequelContext = void 0;\r\nvar Vector2_1 = __webpack_require__(/*! ts/math/Vector2 */ \"./ts/math/Vector2.ts\");\r\nvar REVisual_1 = __webpack_require__(/*! ../visual/REVisual */ \"./ts/visual/REVisual.ts\");\r\nvar REVisualSequelContext = /** @class */ (function () {\r\n    function REVisualSequelContext(entityVisual) {\r\n        this._currentClip = 0;\r\n        this._frameCount = 0;\r\n        this._timeScale = 0;\r\n        this._cuurentFinished = false;\r\n        this._cancellationLocked = false;\r\n        this._startPosition = new Vector2_1.Vector2(0, 0);\r\n        this._entityVisual = entityVisual;\r\n    }\r\n    REVisualSequelContext.prototype.frameCount = function () {\r\n        return this._frameCount;\r\n    };\r\n    REVisualSequelContext.prototype.timeScale = function () {\r\n        return this._timeScale;\r\n    };\r\n    /** Sequel 開始時の Visual の position */\r\n    REVisualSequelContext.prototype.startPosition = function () {\r\n        return this._startPosition;\r\n    };\r\n    REVisualSequelContext.prototype.finished = function () {\r\n        if (this._clip) {\r\n            return this._cuurentFinished && this._currentClip < this._clip.sequels().length;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    };\r\n    REVisualSequelContext.prototype.isCancellationLocked = function () {\r\n        return this._cancellationLocked;\r\n    };\r\n    REVisualSequelContext.prototype.unlockCancellation = function () {\r\n        this._cancellationLocked = false;\r\n    };\r\n    REVisualSequelContext.prototype.end = function () {\r\n        this.unlockCancellation();\r\n        this._cuurentFinished = true;\r\n    };\r\n    REVisualSequelContext.prototype._start = function (clip) {\r\n        this._clip = clip;\r\n        this._currentClip = -1;\r\n        this._timeScale = clip.sequels().length;\r\n        this._cuurentFinished = true;\r\n        this._next();\r\n    };\r\n    REVisualSequelContext.prototype._next = function () {\r\n        if (this._clip) {\r\n            this._currentClip++;\r\n            if (this._currentClip < this._clip.sequels().length) {\r\n                this._startSequel(this._clip.sequels()[this._currentClip]);\r\n            }\r\n        }\r\n    };\r\n    REVisualSequelContext.prototype._startSequel = function (sequel) {\r\n        if (!REVisual_1.REVisual.manager)\r\n            throw new Error();\r\n        this._currentVisualSequel = REVisual_1.REVisual.manager.createVisualSequel(sequel);\r\n        this._frameCount = 0;\r\n        this._cancellationLocked = true;\r\n        this._cuurentFinished = false;\r\n        this._startPosition = Vector2_1.Vector2.clone(this._entityVisual.position());\r\n    };\r\n    REVisualSequelContext.prototype._update = function () {\r\n        if (this._currentVisualSequel) {\r\n            this._currentVisualSequel.onUpdate(this._entityVisual, this);\r\n            this._frameCount += 1;\r\n            if (this._cuurentFinished) {\r\n                // onUpdate() 実行によりアニメーションが終了した\r\n                this._currentVisualSequel = undefined;\r\n            }\r\n        }\r\n        // current の Sequel は完了しているが、全体としては未完了の場合は次の Sequel に進む\r\n        if (this._cuurentFinished && !this.finished()) {\r\n            this._next();\r\n        }\r\n    };\r\n    return REVisualSequelContext;\r\n}());\r\nexports.REVisualSequelContext = REVisualSequelContext;\r\n\n\n//# sourceURL=webpack:///./ts/visual/REVisualSequelContext.ts?");

/***/ }),

/***/ "./ts/visual/REVisualSequelManager.ts":
/*!********************************************!*\
  !*** ./ts/visual/REVisualSequelManager.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REVisualSequelManager = void 0;\r\nvar REVisualSequelManager = /** @class */ (function () {\r\n    function REVisualSequelManager(entityVisualSet) {\r\n        this._currentSequelRun = -1;\r\n        this._runningVisuals = [];\r\n        this._entityVisualSet = entityVisualSet;\r\n    }\r\n    REVisualSequelManager.prototype.setup = function (sequelSet) {\r\n        this._activeSequelSet = sequelSet;\r\n        this._currentSequelRun = -1;\r\n        this._runningVisuals.splice(0);\r\n        this.update();\r\n        console.log(\"setup\", this._activeSequelSet);\r\n    };\r\n    REVisualSequelManager.prototype.update = function () {\r\n        var _this = this;\r\n        if (this._activeSequelSet) {\r\n            var runs = this._activeSequelSet.runs();\r\n            if (this._currentSequelRun >= runs.length && this.isLogicalCompleted()) {\r\n                // すべてのアニメーションが終了した\r\n                this._runningVisuals.splice(0);\r\n                this._activeSequelSet = undefined;\r\n            }\r\n            else {\r\n                var next = -1;\r\n                if (this._currentSequelRun < 0) {\r\n                    // initial\r\n                    next = 0;\r\n                }\r\n                else if (this.isLogicalCompleted()) {\r\n                    // 再生中のものがすべて完了していれば次へ\r\n                    next = this._currentSequelRun + 1;\r\n                }\r\n                // 毎フレームは実行しないようにしたい。\r\n                // initial か、this.isLogicalCompleted()=true のときだけ実行したい。\r\n                if (next >= 0) {\r\n                    this._currentSequelRun = next;\r\n                    if (this._currentSequelRun < runs.length) {\r\n                        // 次の Run を開始する\r\n                        var run = runs[this._currentSequelRun];\r\n                        run.clips().forEach(function (x) {\r\n                            var visual = _this._entityVisualSet.findEntityVisualByEntity(x.entity());\r\n                            if (visual) {\r\n                                visual.sequelContext()._start(x);\r\n                                _this._runningVisuals.push(visual);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    REVisualSequelManager.prototype.postUpdate = function () {\r\n        if (this._activeSequelSet) {\r\n            var runs = this._activeSequelSet.runs();\r\n            if (this._currentSequelRun >= runs.length && this.isLogicalCompleted()) {\r\n                // すべてのアニメーションが終了した\r\n                this._runningVisuals.splice(0);\r\n                this._activeSequelSet = undefined;\r\n                console.log(\"!!!!!!!!!FIN\");\r\n            }\r\n        }\r\n    };\r\n    REVisualSequelManager.prototype.isRunning = function () {\r\n        return this._activeSequelSet != undefined;\r\n    };\r\n    // 現在実行中の Run に含まれる Visual (_runningVisuals) の Sequel が、\r\n    // unlock されるまで実行されているか。\r\n    REVisualSequelManager.prototype.isLogicalCompleted = function () {\r\n        for (var i = 0; i < this._runningVisuals.length; i++) {\r\n            if (this._runningVisuals[i].sequelContext().isCancellationLocked()) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    return REVisualSequelManager;\r\n}());\r\nexports.REVisualSequelManager = REVisualSequelManager;\r\n\n\n//# sourceURL=webpack:///./ts/visual/REVisualSequelManager.ts?");

/***/ }),

/***/ "./ts/visual/REVisual_Entity.ts":
/*!**************************************!*\
  !*** ./ts/visual/REVisual_Entity.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REVisual_Entity = void 0;\r\nvar Common_1 = __webpack_require__(/*! ts/Common */ \"./ts/Common.ts\");\r\nvar Vector2_1 = __webpack_require__(/*! ts/math/Vector2 */ \"./ts/math/Vector2.ts\");\r\nvar REVisualSequelContext_1 = __webpack_require__(/*! ts/visual/REVisualSequelContext */ \"./ts/visual/REVisualSequelContext.ts\");\r\nvar REVisual_1 = __webpack_require__(/*! ./REVisual */ \"./ts/visual/REVisual.ts\");\r\n/**\r\n * Entity の「見た目」を表現するためのクラス。\r\n *\r\n * RMMZ 向けのこのクラスの実装では、直接 Sprite を出したりするわけではない点に注意。\r\n * Mnager からのインスタンス生成と同時に、動的に Game_Event が生成され、このクラスはその Game_Event を操作する。\r\n */\r\nvar REVisual_Entity = /** @class */ (function () {\r\n    function REVisual_Entity(entity, rmmzEventId) {\r\n        this._entity = entity;\r\n        this._rmmzEventId = rmmzEventId;\r\n        this._spriteIndex = -1;\r\n        this._sequelContext = new REVisualSequelContext_1.REVisualSequelContext(this);\r\n        this._position = new Vector2_1.Vector2(entity.x, entity.y);\r\n    }\r\n    REVisual_Entity.prototype.entity = function () {\r\n        return this._entity;\r\n    };\r\n    REVisual_Entity.prototype.rmmzEventId = function () {\r\n        return this._rmmzEventId;\r\n    };\r\n    REVisual_Entity.prototype.rmmzSprite = function () {\r\n        return (REVisual_1.REVisual.spriteset) ? REVisual_1.REVisual.spriteset._characterSprites[this._spriteIndex] : undefined;\r\n    };\r\n    REVisual_Entity.prototype.position = function () {\r\n        return this._position;\r\n    };\r\n    REVisual_Entity.prototype.setPosition = function (value) {\r\n        this._position = value;\r\n    };\r\n    REVisual_Entity.prototype.resetPosition = function () {\r\n        this._position.x = this._entity.x;\r\n        this._position.y = this._entity.y;\r\n    };\r\n    REVisual_Entity.prototype.sequelContext = function () {\r\n        return this._sequelContext;\r\n    };\r\n    REVisual_Entity.prototype._setSpriteIndex = function (value) {\r\n        this._spriteIndex = value;\r\n    };\r\n    REVisual_Entity.prototype._update = function () {\r\n        Common_1.assert(REVisual_1.REVisual.manager);\r\n        this._sequelContext._update();\r\n        if (this._rmmzEventId >= 0) {\r\n            var tileSize = REVisual_1.REVisual.manager.tileSize();\r\n            var event_1 = $gameMap.event(this._rmmzEventId);\r\n            // 姿勢同期\r\n            event_1._x = this._position.x;\r\n            event_1._y = this._position.y;\r\n            event_1._realX = this._position.x; //(this._position.x * tileSize.x) + (tileSize.x  / 2);\r\n            event_1._realY = this._position.y; //(this._position.y * tileSize.y) + (tileSize.y  / 2);\r\n            event_1.setDirection(this._entity.dir);\r\n        }\r\n    };\r\n    return REVisual_Entity;\r\n}());\r\nexports.REVisual_Entity = REVisual_Entity;\r\n\n\n//# sourceURL=webpack:///./ts/visual/REVisual_Entity.ts?");

/***/ }),

/***/ "./ts/visual/REVisual_Manager.ts":
/*!***************************************!*\
  !*** ./ts/visual/REVisual_Manager.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REVisual_Manager = void 0;\r\nvar REManualDecisionDialog_1 = __webpack_require__(/*! ts/dialogs/REManualDecisionDialog */ \"./ts/dialogs/REManualDecisionDialog.ts\");\r\nvar Vector2_1 = __webpack_require__(/*! ts/math/Vector2 */ \"./ts/math/Vector2.ts\");\r\nvar REDialogVisual_1 = __webpack_require__(/*! ts/visual/REDialogVisual */ \"./ts/visual/REDialogVisual.ts\");\r\nvar REManualActionDialogVisual_1 = __webpack_require__(/*! ts/visual/REManualActionDialogVisual */ \"./ts/visual/REManualActionDialogVisual.ts\");\r\nvar REVisualSequel_1 = __webpack_require__(/*! ts/visual/REVisualSequel */ \"./ts/visual/REVisualSequel.ts\");\r\nvar EventExecutionDialog_1 = __webpack_require__(/*! ts/dialogs/EventExecutionDialog */ \"./ts/dialogs/EventExecutionDialog.ts\");\r\nvar REEventExecutionDialogVisual_1 = __webpack_require__(/*! ./dialogs/REEventExecutionDialogVisual */ \"./ts/visual/dialogs/REEventExecutionDialogVisual.ts\");\r\nvar RESystem_1 = __webpack_require__(/*! ts/system/RESystem */ \"./ts/system/RESystem.ts\");\r\nvar CollapseSequel_1 = __webpack_require__(/*! ./sequels/CollapseSequel */ \"./ts/visual/sequels/CollapseSequel.ts\");\r\nvar AttackSequel_1 = __webpack_require__(/*! ./sequels/AttackSequel */ \"./ts/visual/sequels/AttackSequel.ts\");\r\n/**\r\n */\r\nvar REVisual_Manager = /** @class */ (function () {\r\n    function REVisual_Manager() {\r\n        //this._dialogVisual = null;\r\n        //private _dialogVisual: REDialogVisual | null;\r\n        this._tileSize = new Vector2_1.Vector2(48, 48);\r\n        this._visualSequelFactory = [];\r\n        this._dialogNavigator = new REDialogVisual_1.REDialogVisualNavigator();\r\n        this._visualSequelFactory[RESystem_1.RESystem.sequels.MoveSequel] = function () { return new REVisualSequel_1.REVisualSequel_Move(); };\r\n        this._visualSequelFactory[RESystem_1.RESystem.sequels.attack] = function () { return new AttackSequel_1.VAttackSequel(); };\r\n        this._visualSequelFactory[RESystem_1.RESystem.sequels.CollapseSequel] = function () { return new CollapseSequel_1.VCollapseSequel(); };\r\n    }\r\n    REVisual_Manager.prototype.tileSize = function () {\r\n        return this._tileSize;\r\n    };\r\n    REVisual_Manager.prototype._finalize = function () {\r\n    };\r\n    REVisual_Manager.prototype.createVisualSequel = function (sequel) {\r\n        var factory = this._visualSequelFactory[sequel.sequelId()];\r\n        if (factory) {\r\n            return factory();\r\n        }\r\n        else {\r\n            throw new Error();\r\n        }\r\n    };\r\n    REVisual_Manager.prototype.openDialog = function (context) {\r\n        //assert(!this._dialogVisual);\r\n        var d = context.dialog();\r\n        if (d instanceof REManualDecisionDialog_1.REManualActionDialog)\r\n            this._dialogNavigator.push(new REManualActionDialogVisual_1.REManualActionDialogVisual());\r\n        else if (d instanceof EventExecutionDialog_1.RE.EventExecutionDialog)\r\n            this._dialogNavigator.push(new REEventExecutionDialogVisual_1.REEventExecutionDialogVisual());\r\n        // AI 用の Dialog を開いた時など、UI を伴わないものもある\r\n        //return undefined;\r\n    };\r\n    REVisual_Manager.prototype.closeDialog = function (context) {\r\n        this._dialogNavigator.clear();\r\n        //if (this._dialogVisual) {\r\n        //    this._dialogVisual.onClose();\r\n        //    this._dialogVisual = null;\r\n        //}\r\n    };\r\n    return REVisual_Manager;\r\n}());\r\nexports.REVisual_Manager = REVisual_Manager;\r\n\n\n//# sourceURL=webpack:///./ts/visual/REVisual_Manager.ts?");

/***/ }),

/***/ "./ts/visual/dialogs/FootingDialogVisual.ts":
/*!**************************************************!*\
  !*** ./ts/visual/dialogs/FootingDialogVisual.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RE = void 0;\r\nvar Common_1 = __webpack_require__(/*! ts/Common */ \"./ts/Common.ts\");\r\nvar REDialogVisual_1 = __webpack_require__(/*! ../REDialogVisual */ \"./ts/visual/REDialogVisual.ts\");\r\nvar Window_ActionCommand_1 = __webpack_require__(/*! ../windows/Window_ActionCommand */ \"./ts/visual/windows/Window_ActionCommand.ts\");\r\nvar RE;\r\n(function (RE) {\r\n    var FootingDialogVisual = /** @class */ (function (_super) {\r\n        __extends(FootingDialogVisual, _super);\r\n        function FootingDialogVisual(targetEntity, actions) {\r\n            var _this = _super.call(this) || this;\r\n            _this._targetEntity = targetEntity;\r\n            _this._actions = actions;\r\n            return _this;\r\n        }\r\n        FootingDialogVisual.prototype.onCreate = function () {\r\n            var _this = this;\r\n            var y = 100;\r\n            var cw = 200;\r\n            this._entityNameWindow = new Window_Help(new Rectangle(0, y, Graphics.boxWidth - cw, 100));\r\n            this._entityNameWindow.setText(\"階段\");\r\n            this.addWindow(this._entityNameWindow);\r\n            this._commandWindow = new Window_ActionCommand_1.Window_ActionCommand(new Rectangle(Graphics.boxWidth - cw, y, 200, 200), this._actions);\r\n            this._actions.forEach(function (x, i) {\r\n                var _a;\r\n                (_a = _this._commandWindow) === null || _a === void 0 ? void 0 : _a.setHandler(\"index:\" + i, function () { return _this.doAction(i); });\r\n            });\r\n            this._commandWindow.setHandler(\"cancel\", function () { return _this.pop(); });\r\n            this.addWindow(this._commandWindow);\r\n        };\r\n        FootingDialogVisual.prototype.doAction = function (index) {\r\n            var entity = this.dialogContext().causeEntity();\r\n            Common_1.assert(entity);\r\n            this.dialogContext().postAction(this._actions[index], entity, this._targetEntity);\r\n            this.doneDialog(true);\r\n        };\r\n        return FootingDialogVisual;\r\n    }(REDialogVisual_1.REDialogVisualWindowLayer));\r\n    RE.FootingDialogVisual = FootingDialogVisual;\r\n})(RE = exports.RE || (exports.RE = {}));\r\n\n\n//# sourceURL=webpack:///./ts/visual/dialogs/FootingDialogVisual.ts?");

/***/ }),

/***/ "./ts/visual/dialogs/REEventExecutionDialogVisual.ts":
/*!***********************************************************!*\
  !*** ./ts/visual/dialogs/REEventExecutionDialogVisual.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.REEventExecutionDialogVisual = void 0;\r\nvar REDialogVisual_1 = __webpack_require__(/*! ../REDialogVisual */ \"./ts/visual/REDialogVisual.ts\");\r\nvar REEventExecutionDialogVisual = /** @class */ (function (_super) {\r\n    __extends(REEventExecutionDialogVisual, _super);\r\n    function REEventExecutionDialogVisual() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    REEventExecutionDialogVisual.prototype.onCreate = function () {\r\n        console.log(\"REEventExecutionDialogVisual.onCreate\");\r\n        var model = this.dialogContext().dialog();\r\n        var event = $gameMap.event(model.rmmzEventId());\r\n        event.start();\r\n    };\r\n    REEventExecutionDialogVisual.prototype.onUpdate = function (context) {\r\n        console.log(\"REEventExecutionDialogVisual.onUpdate\");\r\n        // マップ遷移後にもイベント実行を続けることもあるので、\r\n        // $gameMap.event() は参照せずに $gameMap.isEventRunning() で実行中かを判断する。\r\n        if (!$gameMap.isEventRunning()) {\r\n            this.doneDialog(true);\r\n        }\r\n    };\r\n    return REEventExecutionDialogVisual;\r\n}(REDialogVisual_1.REDialogVisualWindowLayer));\r\nexports.REEventExecutionDialogVisual = REEventExecutionDialogVisual;\r\n\n\n//# sourceURL=webpack:///./ts/visual/dialogs/REEventExecutionDialogVisual.ts?");

/***/ }),

/***/ "./ts/visual/sequels/AttackSequel.ts":
/*!*******************************************!*\
  !*** ./ts/visual/sequels/AttackSequel.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.VAttackSequel = void 0;\r\nvar Vector2_1 = __webpack_require__(/*! ts/math/Vector2 */ \"./ts/math/Vector2.ts\");\r\nvar Helpers_1 = __webpack_require__(/*! ts/system/Helpers */ \"./ts/system/Helpers.ts\");\r\nvar REVisualSequel_1 = __webpack_require__(/*! ../REVisualSequel */ \"./ts/visual/REVisualSequel.ts\");\r\nvar VAttackSequel = /** @class */ (function (_super) {\r\n    __extends(VAttackSequel, _super);\r\n    function VAttackSequel() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    VAttackSequel.prototype.onUpdate = function (visual, context) {\r\n        var entity = visual.entity();\r\n        var offset = Helpers_1.Helpers.dirToTileOffset(entity.dir);\r\n        visual.setPosition(Vector2_1.Vector2.add(context.startPosition(), Vector2_1.Vector2.mul(offset, 0.5)));\r\n        console.log(\"!!!!!!VAttackSequel\");\r\n        if (context.frameCount() > 30) {\r\n            visual.resetPosition();\r\n            context.end();\r\n        }\r\n    };\r\n    return VAttackSequel;\r\n}(REVisualSequel_1.REVisualSequel));\r\nexports.VAttackSequel = VAttackSequel;\r\n\n\n//# sourceURL=webpack:///./ts/visual/sequels/AttackSequel.ts?");

/***/ }),

/***/ "./ts/visual/sequels/CollapseSequel.ts":
/*!*********************************************!*\
  !*** ./ts/visual/sequels/CollapseSequel.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.VCollapseSequel = void 0;\r\nvar REVisualSequel_1 = __webpack_require__(/*! ../REVisualSequel */ \"./ts/visual/REVisualSequel.ts\");\r\nvar VCollapseSequel = /** @class */ (function (_super) {\r\n    __extends(VCollapseSequel, _super);\r\n    function VCollapseSequel() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    VCollapseSequel.prototype.onUpdate = function (visual, context) {\r\n        var effectDuration = 24 - context.frameCount();\r\n        /*\r\n        const sprite = visual.rmmzSprite();\r\n        if (sprite) {\r\n            sprite.blendMode = PIXI.BLEND_MODES.ADD;\r\n            sprite.setBlendColor([255, 128, 128, 128]);\r\n            sprite.opacity *= effectDuration / (effectDuration + 1);\r\n        }\r\n        */\r\n        if (effectDuration <= 0) {\r\n            console.log(\"!!!!!!VCollapseSequel\");\r\n            context.end();\r\n        }\r\n    };\r\n    return VCollapseSequel;\r\n}(REVisualSequel_1.REVisualSequel));\r\nexports.VCollapseSequel = VCollapseSequel;\r\n\n\n//# sourceURL=webpack:///./ts/visual/sequels/CollapseSequel.ts?");

/***/ }),

/***/ "./ts/visual/windows/Window_ActionCommand.ts":
/*!***************************************************!*\
  !*** ./ts/visual/windows/Window_ActionCommand.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Window_ActionCommand = void 0;\r\nvar REData_1 = __webpack_require__(/*! ts/data/REData */ \"./ts/data/REData.ts\");\r\n/**\r\n * [足元]\r\n */\r\nvar Window_ActionCommand = /** @class */ (function (_super) {\r\n    __extends(Window_ActionCommand, _super);\r\n    function Window_ActionCommand(rect, actions) {\r\n        var _this = _super.call(this, rect) || this;\r\n        // Window_Command を利用する場合、コマンドリストは makeCommandList() で生成するべき。\r\n        // しかしこのメソッドはベースのコンストラクタからも呼ばれるため、先に this._actions を初期化することができない。\r\n        // そのためここで設定後、refresh() することでコマンドリストを再構築している。\r\n        _this._actions = actions;\r\n        _this.refresh();\r\n        return _this;\r\n    }\r\n    ;\r\n    Window_ActionCommand.prototype.makeCommandList = function () {\r\n        var _this = this;\r\n        if (this._actions) {\r\n            this._actions.forEach(function (x, i) {\r\n                _this.addCommand(REData_1.REData.actions[x].displayName, \"index:\" + i, true, undefined);\r\n            });\r\n            this.addCommand(TextManager.command(22), \"cancel\", true, undefined);\r\n        }\r\n    };\r\n    ;\r\n    Window_ActionCommand.prototype.processOk = function () {\r\n        console.log(\"processOk\");\r\n        _super.prototype.processOk.call(this);\r\n    };\r\n    ;\r\n    return Window_ActionCommand;\r\n}(Window_Command));\r\nexports.Window_ActionCommand = Window_ActionCommand;\r\n\n\n//# sourceURL=webpack:///./ts/visual/windows/Window_ActionCommand.ts?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ })

/******/ });