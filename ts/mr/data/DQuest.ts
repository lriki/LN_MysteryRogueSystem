import { DQuestId } from "./DCommon";

export class DQuest {
    public readonly id: DQuestId;
    public readonly key: string;
    public title: string;
    public readonly tasks: DQuestTask[];

    public constructor(id: DQuestId, key: string) {
        this.id = id;
        this.key = key;
        this.title = "null";
        this.tasks = [];
    }

    /*
    ランダムクエストはどうする？
    ----------
    全パターンを DQuest として登録しておく。
    例えばお届け物クエストで完全ランダムにしてしまうと、王様とかストーリーのキーNPCを対象にしてしまうことがある。
    ストーリーのタイミングによっては会えないケースもあるので、理不尽なクエストになってしまう。
    あるていどコントロールできるようにしたいとろこだが、それはタイトルによって条件がかなり異なる。
    そのため、発生しうるパターンはあらかじめ登録しておき、そのなかからランダムにチョイスすることにしてみる。

    Entityの出現位置はどうする？
    ----------
    ツクールのイベントとして、個々のマップエディタで指定できるようにした方がよいだろう。
    これは時刻や天候によって変わるものと同様に扱う方が混乱が少ないと思う。
    マップ上で Key に応じた Entity の出現場所を「マーク」するためのイベントを用意しておく。
    マーカーは @MR-Spawner とは別にしたほうがよさそう。 @MR-Spawner は既に役割がかなり深く決まっているので、仕様変更したくない。
    @MR-UniqueSpawner とかにするか。

    会話システムのアップデート
    ----------
    会話の最後に、相手に対してクエストが発生していれば、その選択肢を表示するような仕組みを作る必要がある。

    ### イベントの記述箇所
    会話のイベント実行内容を実装するのは、Prefab 側がよいだろう。何らかの理由で遠いマップに飛ばされても、クエストの発生は保証される。

    ### イベントの記述ページ
    これも、クエスト固有のページとして用意したほうが良いだろう。
    選択肢は RMMZ 標準の選択肢コマンドとは少し振る舞いが違う。
    - 選択肢が変動する。
    - 選択肢がひとつもなければ、「さようなら」も表示しない。
    ということで、クエスト会話用ページの先頭に注釈で発生条件を示し、書いていくようにしてみる。

    ### MR-AddPostTalkCommand と MR-ShowPostTalkDialog を使う方式は？
    これを使うのは、現在の会話の文脈で、独自の選択肢を表示したいときに使う。
    例えばあらかじめ MR-AddPostTalkCommand しておくと、MR-ShowPostTalkDialog したときに、
    - それらのコマンド
    - 有効なクエスト用の選択肢
    がまとめて表示される。


    実装 - お届け物クエスト、特定アイテムの納品
    ----------
    - 期限がある
    - 特定の Unique Actor へアイテムを届ける
    - 報酬
    - PostConversation の選択肢は、特定のアイテムを持っていない場合、グレー表示したい。
    - 選択肢項目名は、イベントページの注釈で指定したほうが良いだろう。
    - クエスト完了はプラグインコマンドを呼び出すことで行う。その時、完了ウィンドウや報酬を表示する。
    
    実装 - 対象 Entity と会話するだけ
    ----------
    お届け物クエストの会話イベントを流用できるだろう。

    実装 - 特定フロアへ向かって固定発生モンスターを盗伐する
    ----------
    モンスターを捕まえたりして、マップ上からいなくなってしまった場合は？
    モンスターの壺で仲間にしたり、閉じ込めの壺で一時的に捕まえたり…。
    
    真にEntityが戦闘不能となったときをトリガーとするなら、それを追跡できるようにしなければならない。
    それ自体はタグのような機能を使えば可能ではあるが…。
    → 例えば、NonUniqueな Entity だと、持ち帰りの巻物でフロアを抜けたときに、Entity は消えることとなり、それだけでクエスト完了ともなってしまう。
    → 発生マップ外に連れ出して、そこで倒したとしても、実行したいイベントをどこに書く？という問題もある。
        - Prefabに書く場合、どのクエストで、どのマップで、何番目に発生したモンスターなのか、といった情報で if を組む必要があり、かなり複雑になる。
        - コモンイベントだとちょっと情報が離れすぎて管理が難しくなりそう。
        やっぱり Spawner に書きたいところ。

    一応、直接マップ上に居なくても、親 Entity を辿れば、どこにいるかはわかる。

    戦闘不能を原因として Map から除かれたことをトリガーと出来ないか？
    → その場合、ねだやしの巻物のような「強制消滅」によって除かれた場合、トリガーとならない。

    万能な方法は難しそう。
    その中でも、特に設定にあたり、イベントの作成が簡単なものを優先してみると、
    - 何らかの理由で「倒された」ときに、 Spawner のイベントリストを実行する。その中から、プラグインコマンドを実行し、クエストを進行させる。
    のがベターだろう。

    そうすると重要なのは、
    - なにをもって「倒された」とするのか
    - それに該当しない場合は、クエストを「失敗」にする手段も提供する

    やはりシンプルなのは、「マップから除かれた」ハンドライベントに、その「原因」を渡すことだろうか。
    一般的な GUI ツールキットの DialogResult みたいになりそう。

    ### ランダムマップにおいて
    固定マップと同じように条件付き Spawner を使えば良いだろう。


    実装 - 専用マップへ移動して殲滅戦
    ----------
    ボスマップと同様でいいかも。

    期限
    ----------
    - 特定の日時まで
    - 請けてから一定時間経過
    - 特定のメインクエストが完了するまで

    これらを RMMZのイベントで実現するのはちょっと大変かも。OnTimer 的なモノを作る？作ったとして、どうやってハンドリングする？コモンイベント？

    ラベルを利用するのは現実的か？
    → アリだと思う。でも Quest と Chronous は無理に分離してコモンイベントで結び付けようとすると、かえって複雑になってしまうかも。


    Prefab のイベントページを Behavior スクリプトとする？
    ----------
    ラベルを使えば疑似的な関数を表現できる。

    ```
    ラベル: MRQuery-GetPostTalkCommands
        if (プラグインコマンド: MR.isQuestTaskActive("kQuestTask_薬草の採取_1")
            MR-AddPostTalkCommand("薬草について…", "OnExecutePostTalkCommand_薬草")

    ラベル: OnExecutePostTalkCommand_薬草
        if (...)
            MR-CompleteQuestTask("kQuestTask_薬草の採取_1")
        if (...)
            MR-FailQuest("kQuest_薬草の採取")
    ```

    受託待ちクエストの発生やデイリークエストの発生はどうする？
    ----------
    World 全体を通して使用できる Behavior が要るかも。

    メインクエストのような１回のみ発生するものであれば事前定義でもよい気がするが、
    ランダムデイリー(地域ごとの発生最大数つき)はどうだろう？

    ### ランダムデイリー
    - Randomと地域名のタグを振っておく。
    - マップごとにイベントを配置するとマップ外からの実行が大変なので、コモンイベントにする。
    ```
    ラベル: MRQuery-OnAdvanceDay
        MRQuery-AbandonQuestFromTags("Random,地域名")   # 現在発生しているクエストを終了
        MRQuery-OpenQuestFromTags("Random,地域名", 4)  # 最大4つ
    ```


    */
}


export class DQuestTask {
    public readonly key: string;

    public constructor(key: string) {
        this.key = key;
    }
}


