declare module 'MysteryRogueSystem/test/abilities/enemy/Division.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/abilities/enemy/Flock.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/abilities/enemy/ItemImitator.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/abilities/item/Arrow.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/abilities/item/ScrollCommon.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/abilities/item/Staff.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/activity/PickAndPut.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/activity/Shortcut.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/activity/Stumble.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/activity/Throw.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/Activity.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/ai/CharacterAI.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/ai/Escape.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/Basic.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/Combat.test' {
  import "./Extension";
  import "../ts/mr/lively/Extensions";

}
declare module 'MysteryRogueSystem/test/concretes/dialogs/FeetDialog.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/dialogs/ItemListDialog.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/enemy/ArrowShooter.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/enemy/GoldThief.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/enemy/GrabFooter.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/enemy/ItemThief.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/enemy/LevelDowner.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/enemy/PanicToRoom.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/enemy/PowerDowner.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/enemy/RatedRandom.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/enemy/Rust.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/enemy/SelfExplosion.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/enemy/SleepMagician.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/enemy/WarpMagician.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/enemy/X2Speed1Attack.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/arrow/IronArrow.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/arrow/PenetrationArrow.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/arrow/WoodArrow.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/food/Food.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/Gold.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/grass/AntiPoisonGrass.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/grass/FullRecoveryGrass.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/grass/Herb.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/grass/Hypericum.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/grass/LevelUpGrass.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/grass/PoisonGrass.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/grass/PowerGrass.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/grass/RevivalGrass.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/grass/SleepGrass.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/grass/VisibleGrass.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/grass/WarpGrass.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/grass/すばやさ草.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/grass/まどわし草.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/grass/混乱草.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/grass/火炎草.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/grass/目つぶし草.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/Plating.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/pots/PreservationPot.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/ring/AwakeStepRing.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/ring/HungryGuardRing.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/ring/HungryRing.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/ring/PoisonGuardRing.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/ring/PowerRing.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/ring/SilentStepRing.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/ring/SkillGuardRing.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/ring/SleepGuardRing.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/ring/TrapGuardRing.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/ring/VisibleRing.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/ring/WarpRing.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/scroll/ChangeToFoodScroll.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/scroll/DispelScroll.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/scroll/EnemyVisitorScroll.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/scroll/EscapeScroll.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/scroll/InSightDamageScroll.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/scroll/ItemVisitorScroll.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/scroll/MagicChargeScroll.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/scroll/MapVisitorScroll.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/scroll/ParalysisScroll.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/scroll/PlatingScroll.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/scroll/ReinforcementScroll.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/scroll/RestartScroll.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/scroll/Sanctuary.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/scroll/TrapScroll.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/shield/ElementGuardShield.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/shield/LeatherShield.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/shield/PoisonGuardShield.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/staff/ChangeEntityInstance.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/staff/ConfusionStaff.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/staff/DamageStaff.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/staff/DeathStaff.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/staff/DivisionStaff.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/staff/DoubleDamageStaff.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/staff/HalfDamageStaff.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/staff/InvisibleStaff.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/staff/KnockbackStaff.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/staff/SealStaff.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/staff/SleepStaff.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/staff/SpeedDownStaff.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/staff/SpeedUpStaff.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/staff/StumbleStaff.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/staff/WarpStaff.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/weapon/DragonKiller.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/item/識別の巻物.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/states/Anger.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/states/Seal.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/states/ShallowSleep.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/states/かなしばり.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/states/からぶり.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/states/くちなし.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/states/まどわし.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/states/混乱.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/states/目つぶし.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/states/透明.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/states/速度変化.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/trap/ArrowTrap.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/trap/FloorTransferTrap.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/trap/Landmine.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/trap/LegHoldTrap.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/trap/Pitfall.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/trap/PoisonArrowTrap.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/trap/RustTrap.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/trap/StumbleTrap.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/concretes/trap/WarpTrap.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/Database.test' {
  import "./Extension";

}
declare module 'MysteryRogueSystem/test/Dialog.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/effects/CollideEffects.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/effects/Escape.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/Equipment.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/ExitPoint.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/Extension' {
  import "ts/mr/lively/Extensions";
  export {};
  global {
      interface String {
          format(...args: any[]): string;
      }
  }

}
declare module 'MysteryRogueSystem/test/floorgen/Preset.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/floorgen/RandomMap.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/Item.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/map/Limitation.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/map/RandomSpawnLocation.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/map/WaterBlock.test' {
  import "./../Extension";

}
declare module 'MysteryRogueSystem/test/Map.test' {
  import "./Extension";

}
declare module 'MysteryRogueSystem/test/projectiles/Breath.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/projectiles/Item.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/projectiles/MagicBullet.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/Recorder.test' {
  import "./Extension";
  import "../ts/mr/lively/Extensions";

}
declare module 'MysteryRogueSystem/test/Shop.test' {
  import "./Extension";

}
declare module 'MysteryRogueSystem/test/SpeedLevel.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/State.test' {
  import "./Extension";

}
declare module 'MysteryRogueSystem/test/Survival.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/system/BDash.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/system/DeathResult.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/system/Gameover.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/system/Identify.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/system/Inventory.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/system/ItemStacking.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/system/Leveling.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/system/Parameters.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/system/Property.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/system/SaveLoad.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/system/TaskContext.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/system/Visibility.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/system/Warehouse.test' {
  export {};

}
declare module 'MysteryRogueSystem/test/TestEnv' {
  import { LandExitResult } from "ts/mr/data/MRData";
  import { FMap } from "ts/mr/floorgen/FMapData";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SSequelSet } from "ts/mr/system/SSequel";
  import { SIntegration } from "ts/mr/system/SIntegration";
  import "./Extension";
  import { LFloorId } from "ts/mr/lively/LFloorId";
  import { LMap } from "ts/mr/lively/LMap";
  import { DStateId } from "ts/mr/data/DState";
  import { SDialogContext } from "ts/mr/system/SDialogContext";
  import { SDialog } from "ts/mr/system/SDialog";
  import { DEntityId } from "ts/mr/data/DEntity";
  import { LBlock } from "ts/mr/lively/LBlock";
  import { DEventId } from "ts/mr/data/predefineds/DBasicEvents";
  import { DLandId } from "ts/mr/data/DCommon";
  global {
      interface Number {
          clamp(min: number, max: number): number;
      }
  }
  export class TestEnv {
      static integration: TestEnvIntegration;
      static UnitTestLandId: DLandId;
      static FloorId_DefaultNormalMap: LFloorId;
      static FloorId_FlatMap50x50: LFloorId;
      static FloorId_UnitTestFlatMap50x50: LFloorId;
      static FloorId_CharacterAI: LFloorId;
      static FloorId_RandomMapFloor: LFloorId;
      static StateId_debug_MoveRight: DStateId;
      static StateId_Sleep: DStateId;
      static StateId_CertainDirectAttack: DStateId;
      static EntityId_Herb: DEntityId;
      static EntityId_Weapon1: DEntityId;
      static EntityId_Shield1: DEntityId;
      static EntityId_SleepTrap: DEntityId;
      private static _databaseFiles;
      static sequelSets: SSequelSet[];
      static activeSequelSet: SSequelSet;
      static setupDatabase(): void;
      static setupPlayer(floorId: LFloorId, mx?: number, my?: number, dir?: number): LEntity;
      static createReflectionObject(floorId: LFloorId, mx: number, my: number): LEntity;
      static performFloorTransfer(): void;
      private static loadRmmzDatabase;
      private static setGlobal;
      private static loadDataFile;
      private static loadMapData;
      static newGame(): void;
      static padZero(v: number, length: number): string;
      private static onLoad;
      private static isMapObject;
      private static extractArrayMetadata;
      private static extractMetadata;
  }
  export interface SIntegrationRecord {
      type: string;
  }
  export class TestEnvIntegration extends SIntegration {
      skillEmittedCount: number;
      sequelFlushCount: number;
      records: SIntegrationRecord[];
      exitResult: LandExitResult;
      onEventPublished(eventId: DEventId, args: any, handled: boolean): void;
      onReserveTransferMap(mapId: number): void;
      onEntityLocated(entity: LEntity): void;
      onLocateRmmzEvent(eventId: number, x: number, y: number): void;
      onLoadFixedMapData(map: FMap): void;
      onLoadFixedMapEvents(): void;
      onUpdateBlock(block: LBlock): void;
      onRefreshGameMap(map: LMap): void;
      onFlushEffectResult(entity: LEntity): void;
      onFlushSequelSet(sequelSet: SSequelSet): void;
      onCheckVisualSequelRunning(): boolean;
      onOpenDialog(model: SDialog): void;
      onDialogClosed(context: SDialogContext, dialog: SDialog): void;
      onUpdateDialog(context: SDialogContext): void;
      onEntityEnteredMap(entity: LEntity): void;
      onEntityLeavedMap(entity: LEntity): void;
      onEntityReEnterMap(entity: LEntity): void;
      onSetLandExitResult(result: LandExitResult): void;
  }

}
declare module 'MysteryRogueSystem/test/TestJsonEx' {
  export class TestJsonEx {
      static maxDepth: number;
      static stringify(object: any): string;
      static parse(json: string): any;
      private static _encode;
      private static _decode;
      private static _createInstance;
  }

}
declare module 'MysteryRogueSystem/test/TestUtils' {
  import { LActivity } from "ts/mr/lively/activities/LActivity";
  import { LEntity } from "ts/mr/lively/LEntity";
  export class TestUtils {
      static submitActivity(activity: LActivity): void;
      static testCommonFood(item: LEntity): void;
      static testCommonGrassBegin(actor: LEntity, item: LEntity): void;
      static testCommonGrassEnd(actor: LEntity, item: LEntity): void;
      static testCommonScrollBegin(actor: LEntity, item: LEntity): void;
      static testCommonScrollEnd(actor: LEntity, item: LEntity): void;
      static testCommonArrow(item: LEntity): void;
  }

}
declare module 'MysteryRogueSystem/test/Trap.test' {
  export {};

}
declare module 'MysteryRogueSystem/ts/@types/rmmz/rmmz' {
  import "./rmmz_data.ts";

}
declare module 'MysteryRogueSystem/ts/@types/rmmz/rmmz_data' {
  interface IDataSound {
      name: string;
      pan: number;
      pitch: number;
      volume: number;
  }
  interface IDataTrait {
      code: number;
      dataId: number;
      value: number;
  }
  interface IDataActor {
      id: number;
      battlerName: string;
      characterIndex: number;
      characterName: string;
      classId: number;
      equips: number[];
      faceIndex: number;
      faceName: string;
      traits: IDataTrait[];
      initialLevel: number;
      maxLevel: number;
      name: string;
      nickname: string;
      note: string;
      profile: string;
      meta: any;
  }
  interface IDataClass {
      id?: number;
      expParams?: number[];
      traits?: IDataTrait[];
      learnings: {
          level: number;
          note: string;
          skillId: number;
      }[];
      name: string;
      note?: string;
      params?: number[][];
      meta?: any;
  }
  interface IDataEffect {
      code: number;
      dataId: number;
      value1: number;
      value2: number;
  }
  interface IDataDamage {
      critical: boolean;
      elementId: number;
      formula: string;
      type: number;
      variance: number;
  }
  interface IDataSkill {
      id: number;
      animationId: number;
      damage: IDataDamage;
      description: string;
      effects: IDataEffect[];
      hitType: number;
      iconIndex: number;
      message1: string;
      message2: string;
      mpCost: number;
      name: string;
      note: string;
      occasion: number;
      repeats: number;
      requiredWtypeId1: number;
      requiredWtypeId2: number;
      scope: number;
      speed: number;
      stypeId: number;
      successRate: number;
      tpCost: number;
      tpGain: number;
      messageType: number;
      meta: any;
  }
  interface IDataAllItem {
      id: number;
      description: string;
      name: string;
      note: string;
      iconIndex: number;
      price: number;
      meta: any;
  }
  interface IDataItem extends IDataAllItem {
      animationId: number;
      consumable: boolean;
      damage: IDataDamage;
      effects: IDataEffect[];
      hitType: number;
      itypeId: number;
      occasion: number;
      repeats: number;
      scope: number;
      speed: number;
      successRate: number;
      tpGain: number;
  }
  interface IDataEquipItem extends IDataAllItem {
      etypeId: number;
      traits: IDataTrait[];
      params: number[];
  }
  interface IDataWeapon extends IDataEquipItem {
      animationId?: number;
      wtypeId?: number;
  }
  interface IDataArmor extends IDataEquipItem {
      atypeId?: number;
  }
  interface IDataAction {
      conditionParam1?: number;
      conditionParam2?: number;
      conditionType?: number;
      rating: number;
      skillId: number;
  }
  interface IDataDropItem {
      kind: number;
      dataId: number;
      denominator: number;
  }
  interface IDataEnemy {
      id: number;
      actions: IDataAction[];
      battlerHue: number;
      battlerName: string;
      dropItems: IDataDropItem[];
      exp: number;
      traits: IDataTrait[];
      gold: number;
      name: string;
      note: string;
      params: number[];
      meta: any;
  }
  interface IDataPage {
      conditions?: {
          actorHP?: number;
          actorId?: number;
          actorValid?: boolean;
          enemyHp?: number;
          enemyIndex?: number;
          enemyValid?: boolean;
          switchId?: number;
          switchValid?: boolean;
          turnA?: number;
          turnB?: number;
          turnEnding?: boolean;
          turnValid?: boolean;
      };
      list: {
          code: number;
          indent: number;
          parameters: string[];
      }[];
      span?: number;
  }
  interface IDataTroop {
      id: number;
      members: {
          enemyId: number;
          x: number;
          y: number;
          hidden: boolean;
      }[];
      name: string;
      pages: IDataPage[];
      meta: any;
  }
  interface IDataState {
      id: number;
      autoRemovalTiming: number;
      chanceByDamage: number;
      iconIndex: number;
      maxTurns: number;
      message1: string;
      message2: string;
      message3: string;
      message4: string;
      minTurns: number;
      motion: number;
      name: string;
      note: string;
      overlay: number;
      priority: number;
      releaseByDamage: boolean;
      removeAtBattleEnd: boolean;
      removeByDamage: boolean;
      removeByRestriction: boolean;
      removeByWalking: boolean;
      restriction: number;
      stepsToRemove: number;
      traits: IDataTrait[];
      meta: any;
  }
  interface IDataTileset {
      id: number;
      flags: number[];
      mode: number;
      name: string;
      note: string;
      tilesetNames: string[];
      meta: any;
  }
  interface IDataList {
      code: number;
      indent: number;
      parameters: any[];
  }
  interface IDataCommonEvent {
      id?: number;
      list?: IDataList[];
      name: string;
      switchId: number;
      trigger: number;
      meta?: any;
  }
  interface IDataAdvanced {
      gameId: number;
      screenWidth: number;
      screenHeight: number;
      uiAreaWidth: number;
      uiAreaHeight: number;
      numberFontFilename: string;
      fallbackFonts: string;
      fontSize: number;
      mainFontFilename: string;
  }
  interface IVehicle {
      bgm?: IDataSound;
      characterIndex?: number;
      characterName?: string;
      startMapId?: number;
      startX?: number;
      startY?: number;
  }
  interface IDataSystem {
      advanced?: IDataAdvanced;
      airship?: IVehicle;
      armorTypes?: string[];
      attackMotions?: {
          type?: number;
          weaponImageId?: number;
      }[];
      battleBgm?: IDataSound;
      battleback1Name?: string;
      battleback2Name?: string;
      battlerHue?: number;
      battlerName?: string;
      battleSystem?: number;
      boat?: IVehicle;
      currencyUnit: string;
      defeatMe?: IDataSound;
      editMapId?: number;
      elements: string[];
      equipTypes?: string[];
      gameTitle?: string;
      gameoverMe?: IDataSound;
      itemCategories?: boolean[];
      locale?: string;
      magicSkills?: number[];
      menuCommands?: boolean[];
      optAutosave?: boolean;
      optDisplayTp?: boolean;
      optDrawTitle?: boolean;
      optExtraExp?: boolean;
      optFloorDeath?: boolean;
      optFollowers?: boolean;
      optKeyItemsNumber?: boolean;
      optSideView?: boolean;
      optSlipDeath?: boolean;
      optTransparent?: boolean;
      partyMembers: number[];
      ship?: IVehicle;
      skillTypes?: string[];
      sounds?: IDataSound[];
      startMapId: number;
      startX: number;
      startY: number;
      switches?: string[];
      terms: {
          basic: string[];
          commands: string[];
          params: string[];
          messages: {
              alwaysDash?: string;
              commandRemember?: string;
              touchUI?: string;
              bgmVolume?: string;
              bgsVolume?: string;
              meVolume?: string;
              seVolume?: string;
              possession: string;
              expTotal: string;
              expNext: string;
              saveMessage: string;
              loadMessage: string;
              file?: string;
              autosave?: string;
              partyName?: string;
              emerge?: string;
              preemptive?: string;
              surprise?: string;
              escapeStart?: string;
              escapeFailure?: string;
              victory?: string;
              defeat?: string;
              obtainExp?: string;
              obtainGold?: string;
              obtainItem?: string;
              levelUp?: string;
              obtainSkill?: string;
              useItem?: string;
              criticalToEnemy?: string;
              criticalToActor?: string;
              actorDamage?: string;
              actorRecovery?: string;
              actorGain?: string;
              actorLoss?: string;
              actorDrain?: string;
              actorNoDamage?: string;
              actorNoHit?: string;
              enemyDamage?: string;
              enemyRecovery?: string;
              enemyGain?: string;
              enemyLoss?: string;
              enemyDrain?: string;
              enemyNoDamage?: string;
              enemyNoHit?: string;
              evasion?: string;
              magicEvasion?: string;
              magicReflection?: string;
              counterAttack?: string;
              substitute?: string;
              buffAdd?: string;
              debuffAdd?: string;
              buffRemove?: string;
              actionFailure?: string;
          };
      };
      testBattlers?: {
          actorId?: number;
          equips?: number[];
          level?: number;
      }[];
      testTroopId?: number;
      title1Name?: string;
      title2Name?: string;
      titleBgm?: IDataSound;
      titleCommandWindow?: {
          background?: number;
          offsetX?: number;
          offsetY?: number;
      }[];
      variables: string[];
      versionId?: number;
      victoryMe?: IDataSound;
      weaponTypes?: string;
      windowTone?: number[];
      meta?: any;
  }
  interface IDataMapInfo {
      id: number;
      expanded: boolean;
      name: string;
      order: number;
      parentId: number;
      scrollX: number;
      scrollY: number;
      meta: any;
  }
  interface IDataEncounterList {
      troopId?: number;
      weight?: number;
      regionSet?: number[];
  }
  interface IDataMapEventPage {
      conditions?: {
          actorId?: number;
          actorValid?: boolean;
          itemId?: number;
          itemValid?: boolean;
          selfSwitchCh?: string;
          selfSwitchValid: boolean;
          switch1Id?: number;
          switch1Valid?: boolean;
          switch2Id?: number;
          switch2Valid?: boolean;
          variableId?: number;
          variableValid?: boolean;
          variableValue?: number;
      };
      directionFix: boolean;
      image: {
          tileId: number;
          characterName: string;
          direction: number;
          pattern: number;
          characterIndex: number;
      };
      list: IDataList[];
      moveFrequency?: number;
      moveRoute?: {
          list?: {
              code?: number;
              parameters?: number[];
          }[];
          repeat?: boolean;
          skippable?: boolean;
          wait?: boolean;
      };
      moveSpeed?: number;
      moveType?: number;
      priorityType?: number;
      stepAnime: boolean;
      through?: boolean;
      trigger?: number;
      walkAnime: boolean;
  }
  interface IDataMapEvent {
      id: number;
      name: string;
      note: string;
      pages: IDataMapEventPage[];
      x: number;
      y: number;
  }
  interface IDataMap {
      autoplayBgm: boolean;
      autoplayBgs: boolean;
      battleback1Name: string;
      battleback2Name: string;
      bgm: IDataSound;
      bgs: IDataSound;
      disableDashing: boolean;
      displayName: string;
      encounterList: IDataEncounterList[];
      encounterStep: number;
      height: number;
      note: string;
      parallaxLoopX: boolean;
      parallaxLoopY: boolean;
      parallaxName: string;
      parallaxShow: boolean;
      parallaxSx: number;
      parallaxSy: number;
      scrollType: number;
      specifyBattleback: boolean;
      tilesetId: number;
      width: number;
      data: number[];
      events: (IDataMapEvent | null)[];
      meta: any;
  }
  interface IDataAnimation {
      id: number;
      name: string;
      displayType: number;
      effectName: string;
      flashTimings: unknown[];
      offsetX: number;
      offsetY: number;
      rotation: {
          x: number;
          y: number;
          z: number;
      };
      scale: number;
      soundTimings: unknown[];
      speed: number;
      timings: unknown[];
  }
  var $dataActors: IDataActor[];
  var $dataClasses: IDataClass[];
  var $dataSkills: IDataSkill[];
  var $dataItems: IDataItem[];
  var $dataWeapons: IDataWeapon[];
  var $dataArmors: IDataArmor[];
  var $dataEnemies: IDataEnemy[];
  var $dataTroops: IDataTroop[];
  var $dataStates: IDataState[];
  var $dataAnimations: IDataAnimation[];
  var $dataTilesets: IDataTileset[];
  var $dataCommonEvents: IDataCommonEvent[];
  var $dataSystem: IDataSystem;
  var $dataMapInfos: (IDataMapInfo | undefined)[];
  var $dataMap: IDataMap;

}
declare module 'MysteryRogueSystem/ts/extensions/index' {
  export function registerExtensions(): void;

}
declare module 'MysteryRogueSystem/ts/extensions/THExtensions' {
  import { MRDataExtension } from "ts/mr/data/MRDataExtension";
  import { MRGameExtension } from "ts/mr/lively/MRGameExtension";
  import { MRSystemExtension } from "ts/mr/system/MRSystemExtension";
  import { MRVisualExtension } from "ts/mr/view/MRVisualExtension";
  export class THDataExtension extends MRDataExtension {
  }
  export class THGameExtension extends MRGameExtension {
  }
  export class THSystemExtension extends MRSystemExtension {
  }
  export class THVisualExtension extends MRVisualExtension {
  }

}
declare module 'MysteryRogueSystem/ts/main' {
  import "./mr/lively/Extensions";
  import "./mr/rmmz/DataManager";
  import "./mr/rmmz/Game_CharacterBase";
  import "./mr/rmmz/Game_Player";
  import "./mr/rmmz/Game_Event";
  import "./mr/rmmz/Game_Map";
  import "./mr/rmmz/Game_Interpreter";
  import "./mr/rmmz/Game_Message";
  import "./mr/rmmz/PrefabEvent";
  import "./mr/view/ui/Window_Base";
  import "./mr/data/MRData";
  import "./mr/data/MRDataManager";
  import "./mr/data/DTextManager";
  import "./mr/lively/internal";
  import "./mr/lively/LEntity";
  import "./mr/lively/LMap";
  import "./mr/lively/LSystem";
  import "./mr/system/internal";
  import "./mr/system/SEntityFactory";
  import "./mr/rmmz/Scene_Boot";
  import "./mr/rmmz/Scene_Title";
  import "./mr/rmmz/Scene_Map";
  import "./mr/rmmz/Scene_Save";
  import "./mr/rmmz/Scene_Load";
  import "./mr/rmmz/Tilemap";
  import "./mr/rmmz/Sprite_Character";
  import "./mr/rmmz/Spriteset_Base";
  import "./mr/rmmz/Spriteset_Map";
  import "./mr/rmmz/Window_MapName";
  import "./mr/rmmz/PluginCommands";
  import "./mr/rmmz/JsonEx";
  import "./mr/ConsoleCommands";
  import "./extensions/index";
  export * from "MysteryRogueSystem/ts/mr/data/index";

}
declare module 'MysteryRogueSystem/ts/mr/Common' {
  import './lively/Extensions';
  export function assert(condition: any, msg?: string): asserts condition;
  export function tr(text: string, ...keys: any[]): string;
  export function tr2(text: string): string;
  export class Log {
      static _enabled: boolean;
      static d(text: string): void;
      static postCommand(text: string): void;
      static doCommand(text: string): void;
  }
  export class TypeStore {
      static typeInfos: {
          fullName: string;
          friendlyName: string;
          function: Function;
      }[];
      static register(constructor: Function): void;
      static createInstance(name: string): any;
  }
  export function MRSerializable(constructor: Function): void;

}
declare module 'MysteryRogueSystem/ts/mr/ConsoleCommands' {
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/data/DAbility' {
  export type DAbilityId = number;
  export interface DReaction {
      command: string;
      script: string;
  }
  export interface DAbility {
      id: DAbilityId;
      key: string;
      reactions: DReaction[];
  }
  export function DAbility_Default(): DAbility;

}
declare module 'MysteryRogueSystem/ts/mr/data/DActor' {
  import { DActorId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  /**
   * Actor はゲームシナリオ全体を通して存在する一意の登場人物を表すデータ構造。
   *
   * ツクールの Actor とほぼ同義で、そこからインポートして使う。
   * ただし、必ずしも味方であるとは限らない。
   */
  export class DActor {
      /** ID (0 is Invalid). */
      id: DActorId;
      rmmzActorId: number;
      /** 初期配置フロア */
      /** 初期配置 X */
      initialX: number;
      /** 初期配置 Y */
      initialY: number;
      initialLevel: number;
      maxLevel: number;
      actionCommands: DActorId[];
      constructor(id: DActorId);
      setup(data: IDataActor): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DClass' {
  export type DClassId = number;
  export interface DClassLearningSkill {
      level: number;
      note: string;
      skillId: number;
  }
  export class DClass {
      /** ID (0 is Invalid). */
      id: DClassId;
      /** Name */
      name: string;
      /** IDataClass.expParams */
      expParams: number[];
      /** IDataClass.params -> mhp,mmp,atk,def,mat,mdf,agi,luk (DParamId とは関係ない点に注意) */
      params: number[][];
      traits: IDataTrait[];
      learnings: DClassLearningSkill[];
      constructor(id: DClassId);
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DCommand' {
  import { DCommandId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  /**
   */
  export class DCommand {
      /** ID (0 is Invalid). */
      id: DCommandId;
      /** Name. */
      name: string;
      constructor(id: DCommandId, name: string);
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DCommon' {
  export type DActorId = number;
  export type DParameterId = number & {
      readonly brand?: unique symbol;
  };
  export type DEntityCategoryId = number & {
      readonly brand?: unique symbol;
  };
  /** 属性データのインデックス。 RMMZ の ElementId と等しい。 */
  export type DElementId = number & {
      readonly brand?: unique symbol;
  };
  export type DSkillId = number & {
      readonly brand?: unique symbol;
  };
  export type DSpecialEffectId = number & {
      readonly brand?: unique symbol;
  };
  export type DRaceId = number;
  export type DTerrainShapeId = number;
  export type DTerrainSettingId = number;
  export type DTerrainPresetId = number;
  export type DActionId = DSkillId;
  export type DCommandId = number;
  export type DEffectId = number & {
      readonly brand?: unique symbol;
  };
  export type DEntityTemplateId = number & {
      readonly brand?: unique symbol;
  };
  /** Animation データのインデックス。 RMMZ の AnimationId と等しい。 */
  export type DAnimationId = number & {
      readonly brand?: unique symbol;
  };
  export type DLandId = number;
  /** DMap のインデックス。 RMMZ の MapId と等しい。 */
  export type DMapId = number;
  export class DSubComponentEffectTargetKey {
      path: string;
      kindId: DEntityCategoryId;
      tags: string[];
      constructor();
      static make(path: string, kindId?: DEntityCategoryId | undefined, tags?: string[] | undefined): DSubComponentEffectTargetKey;
      clone(): DSubComponentEffectTargetKey;
  }
  export interface DSubEntityFindKey {
      kindId: DEntityCategoryId;
      key: DSubComponentEffectTargetKey | undefined;
  }
  export enum DColorIndex {
      Default = 0
  }
  export enum DBlockLayerKind {
      /** 地形情報。壁・水路など。 */
      Terrain = 0,
      /** 地表に落ちているもの。アイテム・ワナ・階段など。 */
      Ground = 1,
      /** ユニット。PC・仲間・モンスター・土偶など。 */
      Unit = 2,
      /** 発射物。矢、魔法弾、吹き飛ばされたUnitなど。 */
      Projectile = 3,
      /** お店のセキュリティシステムなど、非表示だが Entity として存在するもの。 */
      System = 4,
      Top = 4
  }
  export enum DBlockLayerScope {
      TopOnly = 0,
      All = 1
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DDataImporter' {
  import { DMap } from "MysteryRogueSystem/ts/mr/data/DMap";
  export class DDataImporter {
      static importMapData(mapData: DMap, data: IDataMapInfo, parent1: IDataMapInfo, parent2: IDataMapInfo | undefined): void;
      private static findLand;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DEffect' {
  import { DSubEntityFindKey, DBlockLayerKind, DBlockLayerScope, DEntityCategoryId, DRaceId, DElementId, DEffectId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DParameterId } from "ts/mr/data/DCommon";
  import { DFlavorEffect, IFlavorEffectProps } from "MysteryRogueSystem/ts/mr/data/DFlavorEffect";
  import { DSpecialEffectRef, ISpecialEffectProps } from "MysteryRogueSystem/ts/mr/data/DSpecialEffect";
  export enum DParameterEffectApplyType {
      /** なし */
      None = 0,
      /** ダメージ */
      Damage = 1,
      /** 回復 */
      Recover = 2,
      /** 吸収 */
      Drain = 3
  }
  export enum DValuePoint {
      Actual = 0,
      Minimum = 1,
      Growth = 2
  }
  export class DParameterQualifying {
      _parameterId: DParameterId;
      /** IDataSkill.damage.type  */
      applyType: DParameterEffectApplyType;
      applyTarget: DValuePoint;
      elementIds: DElementId[];
      formula: string;
      /** 分散度 (%) */
      variance: number;
      /** メッセージを出さないようにする。 */
      silent: boolean;
      conditionFormula?: string | undefined;
      fallback: boolean;
      alliesSideGainMessage?: string | undefined;
      alliesSideLossMessage?: string | undefined;
      opponentGainMessage?: string | undefined;
      opponentLossMessage?: string | undefined;
      constructor(paramId: DParameterId, formula: string, applyType: DParameterEffectApplyType);
      withApplyTarget(value: DValuePoint): this;
      withElementId(value: number): this;
      withVariance(value: number): this;
      withSilent(value?: boolean): this;
      withConditionFormula(value: string): this;
      withFallback(value?: boolean): this;
      clone(): DParameterQualifying;
      copyFrom(src: DParameterQualifying): void;
  }
  export interface DOtherEffectQualifying {
      key: string;
  }
  export enum LStateLevelType {
      AbsoluteValue = 0,
      RelativeValue = 1
  }
  export enum DRmmzEffectScope {
      /** なし */
      None = 0,
      /** 敵,単体 */
      Opponent_Single = 1,
      /** 敵,全体 */
      Opponent_All = 2,
      /** 敵,ランダム,1 */
      Opponent_Random_1 = 3,
      /** 敵,ランダム,2 */
      Opponent_Random_2 = 4,
      /** 敵,ランダム,3 */
      Opponent_Random_3 = 5,
      /** 敵,ランダム,4 */
      Opponent_Random_4 = 6,
      /** 味方,単体,生存 */
      Friend_Single_Alive = 7,
      /** 味方,全体,生存 */
      Friend_All_Alive = 8,
      /** 味方,単体,戦闘不能 */
      Friend_Single_Dead = 9,
      /** 味方,全体,戦闘不能 */
      Friend_All_Dead = 10,
      /** 使用者 */
      User = 11,
      /** 味方,単体,無条件 */
      Friend_Single_Unconditional = 12,
      /** 味方,全体,無条件 */
      Friend_All_Unconditional = 13,
      /** 敵と味方,全体 */
      Everyone = 14
  }
  export enum DEffectHitType {
      Certain = 0,
      Physical = 1,
      Magical = 2
  }
  export enum DEffectFieldScopeRange {
      Performer = 0,
      Front1 = 1,
      StraightProjectile = 2,
      ReceiveProjectile = 3,
      PointProjectile = 4,
      Selection = 5,
      Around = 6,
      AroundAndCenter = 7,
      Center = 8,
      Room = 9,
      Map = 10
  }
  export enum DEffectFieldScopeArea {
      Room = 0,
      Floor = 1
  }
  export enum DEffectScopeTargetFactionFlags {
      Friend = 1,
      Nature = 2,
      Hostile = 4,
      All = 7
  }
  export class DEffectFieldScope {
      area: DEffectFieldScopeArea;
      range: DEffectFieldScopeRange;
      length: number;
      projectilePrefabKey: string;
      layers: DBlockLayerKind[];
      layerScope: DBlockLayerScope;
      factions: DEffectScopeTargetFactionFlags;
      constructor();
  }
  export enum DBuffMode {
      Strength = "strength",
      Weakness = "weakness"
  }
  export enum DBuffType {
      Add = 0,
      Mul = 1
  }
  export enum DBuffLevelOp {
      Set = 0,
      Add = 1
  }
  export interface DParamBuff {
      paramId: DParameterId;
      type: DBuffType;
      levelType: DBuffLevelOp;
      level: number;
      turn: number;
  }
  export interface DEffectConditions {
      kindId: DEntityCategoryId;
      /** 判定する RaceId。 0 の場合は対象外。 */
      raceId: DRaceId;
      applyRating: number;
      fallback: boolean;
  }
  export class DEffect {
      readonly id: DEffectId;
      readonly key: string;
      subEntityFindKey: DSubEntityFindKey;
      conditions: DEffectConditions;
      /** @see {@link IEffectProps.critical} */
      critical: boolean;
      /**
        * IDataSkill.successRate
        * IDataItem.successRate
        * 整数値。0~100
        */
      successRate: number;
      hitType: DEffectHitType;
      /**
        * ターゲット側アニメーション。
        * なお、ユーザー側アニメーションは Effect ではなく Item や Skill 側に付く点に注意。
        * Item が複数の Effect を持つときでも、ユーザー側は Item 自体に対応する見た目の動作をとる。
        *
        * undefined はデフォルトのアニメーションを使う。
        * null はアニメーションを再生しないことを示す。
        */
      flavorEffect: DFlavorEffect | undefined | null;
      /**
        * IDataSkill.damage
        * IDataItem.damage
        */
      parameterQualifyings: DParameterQualifying[];
      /**
       * パラメータ変化以外のすべてのエフェクト。
       * これらを実現するにはコードで頑張る必要がある。
       * ほとんどの特殊効果はこれを持つ必要があるはず。
       * コアスクリプトだと EFFECT_XXXX に相当する。
       *
       * @deprecated see effectBehaviors
       */
      otherEffectQualifyings: DOtherEffectQualifying[];
      effectBehaviors: DSpecialEffectRef[];
      /**
       * IDataSkill.effects
       * IDataItem.effects
       */
      rmmzSpecialEffectQualifyings: IDataEffect[];
      /**
       * ステート追加。単に追加するだけなら specialEffectQualifyings から指定することも可能。
       * こちらはレベルと共に指定できる。
       */
      buffQualifying: DParamBuff[];
      constructor(id: DEffectId, key: string);
      applyProps(props: IEffectProps): void;
      copyFrom(src: DEffect): void;
      hasAnyValidEffect(): boolean;
      hasCondition(): boolean;
  }
  export enum DSkillCostSource {
      /** スキルの使用者 */
      Actor = 0,
      /** スキルの発生元となった Entity。杖を振ったときは、振った人が Actor, 杖アイテムが Item. */
      Item = 1
  }
  export enum DParamCostType {
      Decrease = 0,
      Increase = 1
  }
  export interface DParamCost {
      type: DParamCostType;
      value: number;
  }
  export class DEmittorCost {
      /** Cost [DSkillCostSource][DParameterId] */
      paramCosts: DParamCost[][];
      constructor();
      setParamCost(source: DSkillCostSource, paramId: DParameterId, paramCost: DParamCost): void;
  }
  export class DEffectSet {
      /** 使用者に対して与える効果 */
      selfEffectId: DEffectId;
      /**
       *  対象への効果が成功したときのみ、使用者に与える効果。
       * v0.5.0時点ではもろはの杖しか使っていないが、他にもしあわせ草の武器印の効果等に使える。
       */
      succeededSelfEffect: DEffect | undefined;
      /** 対象に対して与える効果。matchConditions を判定して、最終的に適用する Effect を決める */
      effectIds: DEffectId[];
      constructor(sourceKey: string);
      get selfEffect(): DEffect;
      effects(): readonly DEffect[];
      effect(index: number): DEffect;
      clearEffects(): void;
      setEffect(index: number, value: DEffect): void;
      addEffect(value: DEffect): void;
      copyFrom(src: DEffectSet): void;
      hitType(): DEffectHitType;
  }
  export interface IEffectProps {
      conditions?: IEffectConditionsProps;
      /**
       * 対象へダメージを与えるときにクリティカル判定を行うかかどうか。
       *
       * 前方3方向など複数攻撃対象がいる場合は個別にクリティカルが発生することになる。
       * 攻撃の発生元での会心判定は Action として行うこと。
       *
       * IDataSkill.damage.critical
       */
      critical?: boolean;
      /**
       * パラメータへのダメージ・回復効果のリスト。
       */
      parameterDamages?: IParameterDamageEffectProps[];
      /**
       * パラメータへのバフ・デバフ効果のリスト。
       */
      parameterBuffs?: IParameterBuffEffectProps[];
      /**
       * 特殊効果のリスト。
       */
      specialEffects?: ISpecialEffectProps[];
      /**
       * この Effect が発生するときに再生する FlavorEffect。
       */
      flavorEffect?: IFlavorEffectProps;
  }
  export interface IEffectConditionsProps {
      targetCategoryKey?: string;
      /** 判定する RaceId。 0 の場合は対象外。 */
      targetRaceKey?: string;
      /** EnemyAction と同じ整数。0 はレート無し。 */
      rating?: number;
      fallback?: boolean;
  }
  /**
   * パラメータへのダメージ・回復効果。
   */
  export interface IParameterDamageEffectProps {
      parameterKey: string;
      /**
       * Effect を適用する条件式。
       *
       * ダメージ計算式と同様のオペランドが使用できます。 `a.hp < 100` とすると、対象の HP が 100 未満のときに効果が発生します。
       * 省略した場合は常に効果が発生します。
       */
      conditionFormula?: string;
      /**
       * true を指定すると、いずれの条件式にもマッチしない場合、効果が発生します。
       */
      conditionFallback?: boolean;
      /**
       * どのパラメータ要素に対して効果を与えるかを指定します。(default: actual)
       *
       * - actual: 現在値
       * - growth: 成長値 (最大値の算出基準)
       */
      point?: ("actual" | "growth");
      type?: ("damage" | "recover" | "drain");
      /**
       * ダメージ計算式。
       */
      formula: string;
      silent?: boolean;
  }
  /**
   * パラメータへのバフ・デバフ効果。
   */
  export interface IParameterBuffEffectProps {
      parameterKey: string;
      type: ("constant" | "ratio");
      /** (省略した場合は add) */
      levelOp?: ("add" | "set");
      level: number;
      turn: number;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DElement' {
  import { DElementId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  export class DElement {
      readonly id: DElementId;
      readonly key: string;
      name: string;
      constructor(id: number, key: string);
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DEmittor' {
  import { DEffectFieldScope, DEffectSet, DEmittorCost } from "MysteryRogueSystem/ts/mr/data/DEffect";
  export type DEmittorId = number;
  /**
   * RMMZ の Skill と Item の共通パラメータ
   */
  export class DEmittor {
      readonly id: DEmittorId;
      readonly key: string;
      /**
       * Cost は Emittor が持つ。
       * 杖から出る魔法弾がイメージしやすいかも。
       * 新種道具を考えると、魔法弾には複数の Effect が込められているが、
       * 使用回数は魔法弾1つにつき1つ減る。
       */
      costs: DEmittorCost;
      /**
       * 効果適用範囲
       *
       * Skill が持つべきではないのか？
       * ----------
       * RMMZのスコープと同じ名前を使ってるから紛らわしいかも。
       * DSkill.rmmzEffectScope のコメントと併せて参照してほしいが、
       * こちらの scope は「実際に盤面上のどの範囲に効果を出すか」を決めるものである。
       *
       * ゾワゾワの巻物などが分かりやすいか。これは使う(読む)ことで Performer の周囲8マスに効果を発動する。Ornament は発生しない直接適用。
       * 薬草など草は、使う(飲む)ことで、Performer 自身に効果を適用する。
       * 矢は使う(撃つ)ことで、スタックを減らし投射する。
       * 壺は、使う=入れたアイテムを消費or[押す]で詰め物を消費、と考えると抽象化しやすいかも。ユニークな効果が多いのでBehavior実装多めになるけど。
       *
       * 本当は Item と Effect を分離してエディタで設定できる方が、実は自然なのかもしれない。新種道具とか考えると特に。
       *
       * 内部的にはもしかして Effect を ID や Key で参照できるようにした方がいいかも？
       * ↓
       * アリかもしれない。RMMZのSkillとItem の Effect 部分を固有のIDを持つデータとして取り出しておく。
       * 今は Item(火炎草など) は ブレスSkill を参照しているが、実際に欲しいのはその中にある Effect.
       * SkillやItemは主に Effect 発動の前段となる、発動条件を定義するために主に使う。あとは発動時メッセージなど。Effect の入れ物と考えたほうがいいかも。
       */
      scope: DEffectFieldScope;
      /** 発動側アニメーションID */
      selfAnimationId: number;
      targetAreaAnimationId: number;
      /** 発動側 Sequel ID */
      selfSequelId: number;
      effectSet: DEffectSet;
      constructor(id: DEmittorId, key: string);
      applyProps(props: IEmittorProps): void;
      copyFrom(src: DEmittor): void;
  }
  export interface IEmittorProps {
      targetEffectKeys?: string[];
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DEnemy' {
  import { DEntity, DEntityId } from "MysteryRogueSystem/ts/mr/data/DEntity";
  export type DEnemyId = number;
  export class DDropItem {
      entityId: DEntityId;
      denominator: number;
      gold: number;
      constructor();
      static makeFromRmmzDropItemList(data: IDataDropItem[], gold: number): DDropItem[];
      static makeFromRmmzDropItem(data: IDataDropItem): DDropItem;
      static makeFromRmmzDropGold(gold: number): DDropItem;
  }
  /**
   * モンスターデータ。
   *
   * RMMZ の Enemy と同じ意味のデータだが、味方勢力に属することもあるので "Enemy" という言葉の意味とちょっと違くなる。
   * ひとまず "Monster" という言葉を採用。
   * ↑
   * やっぱりナシ。
   * ツクールと連携するので、Enemy という名前の方がデータの対応がわかりやすい。
   */
  export class DEnemy {
      /** ID (0 is Invalid). */
      id: DEnemyId;
      entityId: DEntityId;
      /** 取得経験値 */
      exp: number;
      /** @deprecated Dentity.selfTraits に統合していいかも？ */
      traits: IDataTrait[];
      actions: IDataAction[];
      dropItems: DDropItem[];
      constructor(id: DEnemyId, entityId: DEntityId);
      entity(): DEntity;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DEntity' {
  import { DActor } from "MysteryRogueSystem/ts/mr/data/DActor";
  import { DClassId } from "MysteryRogueSystem/ts/mr/data/DClass";
  import { DActionId, DElementId, DRaceId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DEmittorId, DEmittor } from "MysteryRogueSystem/ts/mr/data/DEmittor";
  import { DEnemy } from "MysteryRogueSystem/ts/mr/data/DEnemy";
  import { DEntityProperties } from "MysteryRogueSystem/ts/mr/data/DEntityProperties";
  import { DEquipment, DItem } from "MysteryRogueSystem/ts/mr/data/DItem";
  import { DPrefab, DPrefabId } from "MysteryRogueSystem/ts/mr/data/DPrefab";
  import { DStateId } from "MysteryRogueSystem/ts/mr/data/DState";
  import { DTroopId } from "MysteryRogueSystem/ts/mr/data/DTroop";
  import { ITraitProps } from "MysteryRogueSystem/ts/mr/data/DTraits";
  import { DFactionId } from "MysteryRogueSystem/ts/mr/data/MRData";
  export type DEntityId = number;
  export enum DIdentificationDifficulty {
      Clearly = 0,
      NameGuessed = 1,
      Obscure = 2
  }
  export interface DEntityNamePlate {
      name: string;
      stackedName: string;
      iconIndex: number;
  }
  export class DReaction {
      /**
       * Entity が反応する Action.
       * 例えば "Eat" があれば、その Entity は食べることができる。
       */
      private _actionId;
      /**
       * この Reaction に反応する Emittor。
       *
       * 複数指定可能。例えば火炎草は、次の2つが登録される。
       * - 使用者に対する FP 回復効果
       * - 目の前の別エンティティに対するダメージ効果
       *
       * ひとつも登録されていない場合は何も起こらないが、Behavior への通知は行われる。
       * これによって、 Emittor に依らない特殊効果をコードで実装することもできる。
       *
       * Emittor と Reaction は違うもの？
       * ----------
       * 同一にはしない。1つの Emittor は、複数の Reaction に反応することができる。
       * これは例えば、アイテムを使った時と投げ当てた時に同じ効果を起こすということを表現するため。
       * ただ、v0.7.0 時点では、吹き飛ばしの杖が吹き飛ばしスキルの効果を参照しているだけなので、十分に活用できているとは言い難い。
       * 草系アイテムは使った時と投げ合当てた時で同様の効果を起こすが、食べた時はFPも回復するので、今は cloneEmittor して使っている。
       * いずれにしても、Reaction は Emittor と Action(コマンド) を追加情報とともに紐づけるものであるが、
       * Emittor は Action(コマンド) とは全く別物であるため、くっつけないほうがよいだろう。
       */
      private _emittorIds;
      primariyUse: boolean;
      overrideDisplayCommandName: string | undefined;
      constructor(actionId: DActionId);
      get actionId(): DActionId;
      addEmittor(emittor: DEmittor): void;
      hasEmittor(): boolean;
      emittorIds(): readonly DEmittorId[];
      emittors(): DEmittor[];
  }
  export interface DEntityAutoAdditionState {
      stateId: DStateId;
      condition: string;
  }
  export interface DCounterAction {
      conditionAttackType: DElementId | undefined;
      emitSelf: boolean;
  }
  export interface DRange {
      minValue: number;
      maxValue: number;
  }
  /**
   * [2021/6/22] Database 修正について
   * ----------
   * これまでは Prefab の方が偉かった (インスタンス化するときは PrefabID を使った) が、EntityData の方を偉くしてみる。
   *
   * - 固定のお店を作るときはツクールの [お店の処理] を使いたいが、ここで指定するのは ItemData(EntityData) である。Prefab との関連付けが少し手間。
   *   - お店に限らず、イベントからアイテムIDとして情報をもらうときに、REシステムのほとんどの個所で Prefab を要求していることがツクールとマッチしていない。
   * - 変化の壺や合成の壺などは ItemData として生成物のリストをユーザーが作れるようにしたい。
   *   でもそうすると、処理の中で何らかの新しい Entity をインスタンス化する必要があるときに、Prefab を探しに行くのが手間。
   * - アイテム擬態ステートを作るときに CharacterImage を得るときも、結局 EntityData(Item) から Prefab まで辿る必要があり、ItemData -> Prefab の参照が必要になった。
   *
   * 基本的に、EntityData と Prefab は 1:1 である。この2つが双方向の参照を持たざるを得なくなったことで、
   * インスタンス化時にはどちらを指定しても問題はなくなった。
   * どちらでもよいなら、エディタから指定しやすい方を使うのがよいだろう。
   *
   * NOTE: このような仕組みにすると、EntityData と Prefab は 1:n でも良くなる。
   * Prefab は見た目をコントロールするものとみなせるので、例えば同種のアイテムなどは共通の Prefab を使っても構わない。
   * 当初は Prefab の方が偉かったが、Prefab は View の機能なので、Data に対して View が優先されるのはやっぱりちょっと不自然だろう。
   */
  export class DEntity {
      id: DEntityId;
      prefabId: DPrefabId;
      entity: DEntityProperties;
      entityTemplateKey: string | undefined;
      display: DEntityNamePlate;
      description: string;
      identificationDifficulty: DIdentificationDifficulty;
      identificationReaction: DActionId;
      /** 買い値（販売価格） */
      sellingPrice2: number;
      /** 売り値 (買取価格) */
      purchasePrice: number;
      /** 祝福・呪い・封印状態になるか。 */
      allowModifierState: boolean;
      actor: DActor | undefined;
      itemData: DItem | undefined;
      equipment: DEquipment | undefined;
      enemy: DEnemy | undefined;
      classId: DClassId;
      raceIds: DRaceId[];
      /** この Entity 自身に対する Trait */
      selfTraits: IDataTrait[];
      /** 装備したときに、装備者に対して適用する Trait */
      equipmentTraits: IDataTrait[];
      /** 持っているだけで affestTraits の効果があるか */
      isTraitCharmItem: boolean;
      /** デフォルトの勢力。 */
      factionId: DFactionId;
      /**
       * 各基本パラメータ。Enemy のパラメータや、Item の使用回数など。
       * Index は rmmz の params とは異なるので注意。
       */
      idealParams: (number | undefined)[];
      /**
       * スタック数の初期値。
       * Entity 生成時の DEntityCreateInfo.stackCount が指定されている場合はそちらにオーバーライドされる。
       */
      initialStackCount: DRange | undefined;
      /** この Entity が受け付ける Action のリスト */
      reactions: DReaction[];
      /**
       * 元々 DItem が持っていたが、例えば Entity が何かと衝突したときに発動する効果を定義する、というのは、モンスターの特殊能力でも使いたい。
       * 例えば衝突したら相手にノックバック効果を与えるモンスターもある。
       *
       * TODO: reactions とまとめられないか考えたいところ。
       */
      /**
       * RMMZ エディタで指定され Item の効果
       */
      private _mainEmittorId;
      /**
       * 自動追加ステート。
       * これによって、HPが少なくなったら逃げ出したり、自爆したりといったコントロールを行う。
       */
      autoAdditionStates: DEntityAutoAdditionState[];
      majorActionDeclines: number;
      /**
       * 強化下限・上限。これらは DParam の情報ではなく Entity データごとに固有のもの。
       * 原作では +値がそのまま攻撃力等に反映されるが、タイトルによっては +値*10 とか、マイナス方向にも有効とかいろいろ考えられる。
       */
      upgradeMin: number;
      upgradeMax: number;
      /** 飛翔体としての移動を終了するとき、地面に落ちずに消滅するか */
      volatilityProjectile: boolean;
      counterActions: DCounterAction[];
      shortcut: boolean;
      constructor(id: DEntityId);
      get isValidKey(): boolean;
      prefab(): DPrefab;
      actorData(): DActor;
      item(): DItem;
      enemyData(): DEnemy;
      equippedTraits(): readonly IDataTrait[];
      charmedTraits(): readonly IDataTrait[];
      addReaction(actionId: DActionId, emittor?: DEmittor, primaryUse?: boolean): DReaction;
      findReaction(actionId: DActionId): DReaction | undefined;
      getReaction(actionId: DActionId): DReaction;
      setMainEmittor(emittor: DEmittor): void;
      mainEmittor(): DEmittor;
      makeDisplayName(stackCont: number): string;
      verify(): void;
      applyProps(props: IEntityProps): void;
  }
  export class DEntityCreateInfo {
      entityId: DEntityId;
      stateIds: DStateId[];
      debugName: string;
      stackCount: number | undefined;
      override: boolean;
      gold: number;
      constructor();
      static makeSingle(entityId: DEntityId, stateIds?: DStateId[], debugName?: string): DEntityCreateInfo;
      withStackCount(value: number): this;
  }
  export class DEntitySpawner2 extends DEntityCreateInfo {
      troopId: DTroopId;
      overrideEvent: IDataMapEvent | undefined;
      keeper: boolean;
      xName: string | undefined;
      /**
       * 出現率
       *
       * デフォルトは 100。RMMZ だと 1~9 で指定することが多いが、
       * 原作に従って細かく指定したい場合、もっと少ない出現率を指定したいこともあるためこのようにしている。
       * https://oyasen20.tripod.com/torneco_obtainable.html
       */
      rate: number;
      constructor();
      entityData(): DEntity;
      static makeFromEventData(event: IDataMapEvent, rmmzMapId: number): DEntitySpawner2 | undefined;
      static makeFromEventPageData(event: IDataMapEvent, page: IDataMapEventPage, rmmzMapId: number): DEntitySpawner2 | undefined;
  }
  export interface IEntityProps {
      reactions?: IReactionProps[];
      /**
       * ModifierState (祝福、呪い、封印) になりえるかを指定します。 (default: false)
       */
      allowModifierState?: boolean;
      /**
       * 未識別状態の名前をどのように表示するか。
       *
       * - "clearly" : 未識別状態にはならない (デフォルト)
       * - "named"   : 未識別状態でも名前を表示する。強化値や使用回数は表示しない。主に装備品が該当する。
       * - "obscure" : 未識別の場合、仮名を表示する。
       */
      identificationDifficulty?: ("clearly" | "named" | "obscure");
      /**
       * どの Action に反応して識別状態となるかを、 Action の key で指定します。
       */
      identificationActionKey?: string;
      /**
       * この Entity 自身に付加するトレイトのリスト。
       */
      selfTraits: ITraitProps[];
      /**
       * この Entity を装備アイテムとして装備した時に、装備者に対して付加するトレイトのリスト。
       */
      equipmentTraits: ITraitProps[];
  }
  export interface IReactionProps {
      actionKey: string;
      emittorKeys?: string[];
      commandName?: string;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DEntityCategory' {
  import { DEntityCategoryId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DEntity } from "MysteryRogueSystem/ts/mr/data/DEntity";
  /**
   * Entity の種別
   *
   * ソートキーなどで使われる。
   * 持ち物一覧のアイコンと考えるとわかりやすい。
   *
   * アイテム化け能力をもつモンスターなどにより、適宜オーバーライドされることはあるが、
   * Entity 1つに対して一意の表現となる。
   * 「武器かつ盾」といった表現はできない。そういった場合は、どちらかに分類しなければならない。
   *
   * 勢力を表すものではない点に注意。例えば種別 "Monster" は、敵にも味方にもなれる。
   *
   *
   *
   */
  export class DEntityCategory {
      /** ID (0 is Invalid). */
      readonly id: DEntityCategoryId;
      /** key. */
      readonly key: string;
      /** Name. */
      displayName: string;
      constructor(id: DEntityCategoryId, key: string);
      static isMonster(entity: DEntity): boolean;
      static isTrap(entity: DEntity): boolean;
      static isEntryPoint(entity: DEntity): boolean;
      static isExitPoint(entity: DEntity): boolean;
      static isOrnament(entity: DEntity): boolean;
      static isItem(entity: DEntity): boolean;
      applyProps(props: IEntityCategoryProps): void;
  }
  export interface IEntityCategoryProps {
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DEntityProperties' {
  import { DEntityCategoryId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  export enum DItemEquipmentSide {
      Right = 0,
      Left = 1
  }
  export interface DItemEquipmentImage {
      name: string;
      side: DItemEquipmentSide;
  }
  export interface DEntityProperties {
      /** MR-Key */
      key: string;
      kindId: DEntityCategoryId;
      behaviors: DBehaviorInstantiation[];
      commandNames: string[];
      reactionNames: string[];
      abilityNames: string[];
      capacity?: string;
      equipmentImage: DItemEquipmentImage;
      meta_prefabName: string;
  }
  export interface DBehaviorInstantiation {
      name: string;
      args?: any[] | undefined;
  }
  export function DEntityProperties_Default(): DEntityProperties;
  /** @deprecated DMetadataParser */
  export function parseMetaToEntityProperties(meta: any | undefined): DEntityProperties;
  export function parseMetadata_Behavior(meta: string[]): DBehaviorInstantiation[];

}
declare module 'MysteryRogueSystem/ts/mr/data/DEntityTemplate' {
  import { DEntityTemplateId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DEntity } from "MysteryRogueSystem/ts/mr/data/DEntity";
  export class DEntityTemplate {
      readonly id: DEntityTemplateId;
      readonly key: string;
      private _props;
      constructor(id: DEntityTemplateId, key: string, props: IEntityTemplateProps);
      get props(): IEntityTemplateProps;
      resetProps(props: IEntityTemplateProps): void;
      applyTo(entity: DEntity): void;
      private applyTo_Weapon;
      private applyTo_Shield;
      private applyTo_Armor;
      private applyTo_Accessory;
      private applyTo_Grass;
      private applyTo_Food;
  }
  export interface IEntityTemplateProps_Null {
      type: "null";
  }
  export interface IEntityTemplateProps_Weapon {
      type: "Weapon";
  }
  export interface IEntityTemplateProps_Shield {
      type: "Shield";
  }
  export interface IEntityTemplateProps_Armor {
      type: "Armor";
  }
  export interface IEntityTemplateProps_Accessory {
      type: "Accessory";
  }
  export interface IEntityTemplateProps_Grass {
      type: "Grass";
      /** FPの回復量 */
      recoverFP: number;
  }
  export interface IEntityTemplateProps_Food {
      type: "Food";
  }
  export type IEntityTemplateProps = IEntityTemplateProps_Weapon | IEntityTemplateProps_Shield | IEntityTemplateProps_Accessory | IEntityTemplateProps_Armor | IEntityTemplateProps_Grass | IEntityTemplateProps_Food | IEntityTemplateProps_Null;

}
declare module 'MysteryRogueSystem/ts/mr/data/DEquipmentPart' {
  export type DEquipmentPartId = number;
  /**
   * 装備部位。slot の種類を表す。
   *
   * RMMZ の装備タイプからインポートしてくるが、RMMZ のとは少し使い勝手が異なるので注意。
   * 例えば二刀流を実現する装備スロットは、「武器」「盾」という考え方ではなく、「右手」「左手」という考え方をする。
   *
   * 装備スロットのシステム上は、武器や盾は PrimaryHand, SecondaryHand どちらに装備してもかまわない。
   * 装備可能かの制御は Trait で行う。
   * そのため極端な話、腕をもう一本生やして武器を持たせたり、頭にドリルをつけたりするのも可能。
   *
   */
  export interface DEquipmentPart {
      /** ID (0 is Invalid). */
      id: DEquipmentPartId;
      /** Name. */
      name: string;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DEquipmentType' {
  export type DEquipmentTypeId = number;
  export interface DEquipmentType {
      /** ID (0 is Invalid). */
      id: DEquipmentTypeId;
      /** Name. */
      name: string;
  }
  export const DEquipmentType_Default: DEquipmentType;

}
declare module 'MysteryRogueSystem/ts/mr/data/DFaction' {
  export enum DFactionType {
      /** 中立的. */
      Neutral = "Neutral",
      /** 友好的. または操作中の Unit. */
      Friendly = "Friendly",
      /** 敵対的. */
      Hostile = "Hostile"
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DFlavorEffect' {
  import { DSequelId } from "MysteryRogueSystem/ts/mr/data/DSequel";
  export class DSound implements IDataSound {
      name: string;
      pan: number;
      pitch: number;
      volume: number;
      constructor(options: ISound);
  }
  export interface ISound {
      name: string;
      pan?: number;
      pitch?: number;
      volume?: number;
  }
  export class DFlavorEffect {
      /** ログ表示テキスト (%1=self, %2=パラメータ名, %3=変化量の絶対値, %4=古い値, %5=新しい値) */
      text: string[];
      /** 再生する効果音 */
      sound: DSound | undefined;
      /** 再生するアニメーションの ID */
      rmmzAnimationId: number;
      /** 再生するモーションの ID */
      motionId: DSequelId;
      constructor(options?: IFlavorEffectProps);
      static fromRmmzAnimationId(rmmzAnimationId: number): DFlavorEffect;
  }
  export interface IFlavorEffectProps {
      /** ログ表示テキスト (%1=self, %2=パラメータ名, %3=変化量の絶対値, %4=古い値, %5=新しい値) */
      text?: string | string[] | undefined;
      /** 再生する効果音 */
      sound?: ISound | undefined;
      /** 再生するアニメーションの ID */
      animationId?: number;
      /** 再生するモーションの ID */
      motionId?: DSequelId;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DHelper' {
  import { DLandId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DRmmzEffectScope } from "MysteryRogueSystem/ts/mr/data/DEffect";
  export interface DConstructionExpr {
      name: string;
      args: any[];
  }
  export class DHelpers {
      static TILE_ID_E: number;
      static TILE_ID_A5: number;
      static TILE_ID_A1: number;
      static TILE_ID_A2: number;
      static TILE_ID_A3: number;
      static TILE_ID_A4: number;
      static TILE_ID_MAX: number;
      static VanillaLandId: number;
      static isVanillaLand(landId: DLandId): boolean;
      static getMapTopTile(mapData: IDataMap, x: number, y: number): number;
      static isTileA3(tileId: number): boolean;
      static isTileA4(tileId: number): boolean;
      static isAutotile(tileId: number): boolean;
      static getAutotileKind(tileId: number): number;
      static autotileKindToTileId(autotileKind: number): number;
      static isWallSideAutoTile(autotileKind: number): boolean;
      static stringToEnum<T>(value: string | undefined, pattern: {
          [key: string]: T;
      }): T;
      private static checkItemScope;
      static isForOpponent(itemScope: DRmmzEffectScope): boolean;
      static isForAliveFriend(itemScope: DRmmzEffectScope): boolean;
      static isForDeadFriend(itemScope: DRmmzEffectScope): boolean;
      static isForFriend(itemScope: DRmmzEffectScope): boolean;
      static isSingle(itemScope: DRmmzEffectScope): boolean;
      static countSomeTilesRight_E(mapData: IDataMap, x: number, y: number): number;
      private static extractMetadataRegex;
      static extractMetadata(data: any): void;
      static makeRmmzMapDebugName(mapId: number): string;
      static isNode(): boolean;
      static parseConstructionExpr(expr: string): DConstructionExpr;
      static parseDisplayName(name: string): string;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DIdentifyer' {
  export class DIdentifyer {
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DItem' {
  import { DEntity, DEntityId } from "MysteryRogueSystem/ts/mr/data/DEntity";
  import { DEquipmentPartId } from "MysteryRogueSystem/ts/mr/data/DEquipmentPart";
  export type DItemDataId = number;
  /**
   * ひとまず Item, Weapon Armor をまとめて表現してみる。
   *Item を装備するようなケースは無いが、装備品をアイテムとして扱うことはよくある。
   *（矢や杖を "セット" してショートカットキーで使えるようにすることはある）
   *食べられる武器、投げると特殊な効果を発揮する武器、アイテムを入れることができる盾、武器として使える両手盾など。
   *また合成印の素材は、装備品だけではなくあらゆるアイテムが対象となる。
   *
   *
   * [2021/5/19] Effect に対してタグのように Activity を振る案
   * ----------
   * - 火炎草のように飲んだ時と投げ当てた時で効果が変わるもの。飲んだ時は FP も回復する。
   * - さらに、これを新種道具の効果として継承できるようにしたい。
   *
   * "火炎草" というひとつの Ability より、
   * "飲むとブレススキルを発動する", "投げ当てると炎ダメージを与える" 2つの Ability に分けた方がいいかも。
   *
   * 草を飲むことによる FP 回復は Ability ではなく、草アイテム固有の Effect.
   * なので、"火炎草" アイテムの設定は
   * - ダメージ: なし
   * - <RE-Action:Eat=Effect(Param FP +5)>
   * - <RE-Ability: k飲むとブレススキルを発動する>
   * - <RE-Ability: k投げ当てると炎ダメージを与える>
   *
   * [2021/6/3] Effect と Action は分類するべきかも
   * ----------
   * - Effect は何かしらの動作や状況変化をうけて発動する効果。
   *   - 単にスキル効果を発動するもの
   *   - 吹き飛ばしのようにスクリプト側で制御する動作を開始するもの
   *
   * Effect は RMMZ エディタ上ではスキルとして作成するのがいいかも。
   * - パラメータダメージはツクール標準で設定。
   * - 拡張パラメータは Note で設定。
   * - 吹き飛ばし効果やブレスは Note で、「ActionEffect」 みたいな名前で設定。
   *
   * これを考慮すると「飲むとブレススキルを発動するAbility」は、
   * - <RE-Action:Eat=Effect(PerformSkill, kSkill_炎ブレス)>
   *
   * 「kSkill_炎ブレス」は、
   * - <RE-Motion: ブレス>
   * だけでいいかな。射程目の前だけだし。
   *
   * [2021/6/3] Projectile
   * ----------
   * 魔法弾、ドラゴン草、矢、大砲の弾、石、"技"による弾
   *
   * これら、もしかしたら「射程」の一部と考えたほうがよいのかも？
   *
   * 通常攻撃や火炎草は目の前に効果を発動する。
   * 矢弾は Projectile を出現させる。
   * Projectile は何らかの Item である。
   * 炎や魔法弾も Item である。
   * 極端な話、キャッチしてインベントリに入れることもできる。
   *
   * Scope { range: "straight", length: "inf", projectile: "pブレス" }  # スキル
   * Scope { range: "straight", length: 10, projectile: "self" }     # 矢弾アイテム
   *
   * 矢弾アイテムの場合は、自身を Projectile として打ち出す。
   * スタックされているアイテムの場合、1つだけマップ上に出現させるような処理になる。
   *
   */
  export class DItem {
      /** ID (0 is Invalid). */
      id: DItemDataId;
      entityId: DEntityId;
      constructor(id: DItemDataId, entityId: DEntityId);
      entityData(): DEntity;
  }
  export interface DEquipmentParam {
      value: number;
      upgradeRate: number;
  }
  export class DEquipment {
      /** このアイテム(装備品) を装備できる部位 */
      equipmentPart: DEquipmentPartId;
      /** 他の占有部位。両手武器は、ここに Shield が入る。 */
      equipmentOccupancyParts: DEquipmentPartId[];
      /** 装備したときに適用する parameters. (Index is DParameterId) */
      parameters: (DEquipmentParam | undefined)[];
      targetRmmzAnimationId: number;
      constructor();
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DItemEffect' {
  export class DItemEffect {
      static EFFECT_RECOVER_HP: number;
      static EFFECT_RECOVER_MP: number;
      static EFFECT_GAIN_TP: number;
      static EFFECT_ADD_STATE: number;
      static EFFECT_REMOVE_STATE: number;
      static EFFECT_ADD_BUFF: number;
      static EFFECT_ADD_DEBUFF: number;
      static EFFECT_REMOVE_BUFF: number;
      static EFFECT_REMOVE_DEBUFF: number;
      static EFFECT_SPECIAL: number;
      static EFFECT_GROW: number;
      static EFFECT_LEARN_SKILL: number;
      static EFFECT_COMMON_EVENT: number;
      static SPECIAL_EFFECT_ESCAPE: number;
      static HITTYPE_CERTAIN: number;
      static HITTYPE_PHYSICAL: number;
      static HITTYPE_MAGICAL: number;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DItemShop' {
  export type DItemShopTypeId = number;
  export interface DItemShopType {
      id: DItemShopTypeId;
      name: string;
      bgm: IDataSound;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DLand' {
  import { DLandId, DMapId, DTerrainPresetId, DTerrainSettingId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DEntitySpawner2 } from "MysteryRogueSystem/ts/mr/data/DEntity";
  import { DEntityCategory } from "MysteryRogueSystem/ts/mr/data/DEntityCategory";
  import { DMap } from "MysteryRogueSystem/ts/mr/data/DMap";
  export enum DFloorClass {
      FloorMap = 0,
      EventMap = 1
  }
  export interface DAppearanceTableEntity {
      startFloorNumber: number;
      lastFloorNumber: number;
      spawiInfo: DEntitySpawner2;
  }
  export interface DAppearanceTableEvent {
      startFloorNumber: number;
      lastFloorNumber: number;
      rmmzEventId: number;
  }
  export interface DAppearanceTableSet {
      /** すべての Entity と出現範囲 */
      entities: DAppearanceTableEntity[];
      maxFloors: number;
      /** Event のテーブル。 [フロア番号][] */
      events: DAppearanceTableEvent[][];
      /** 階段など、RESystem によって特別扱いされるもの。 [フロア番号0~][] */
      system: DAppearanceTableEntity[][];
      /** Enemy のテーブル。初期配置の他、ターン経過によって出現する。 [フロア番号0~][]  */
      enemies: DAppearanceTableEntity[][];
      /** Trap のテーブル。Item とは出現率が別管理なので、分けておく。 [フロア番号0~][]  */
      traps: DAppearanceTableEntity[][];
      /** Item のテーブル。Trap とは出現率が別管理なので、分けておく。 [フロア番号0~][] */
      items: DAppearanceTableEntity[][];
      /** Shop のテーブル。Item と、店主が含まれている。 [フロア番号0~][] */
      shop: DAppearanceTableEntity[][];
  }
  export class DFloorStructures {
  }
  export interface DFloorMonsterHousePattern {
      name: string;
      rating: number;
  }
  export class DTerrainSettingRef {
      terrainSettingsId: DTerrainSettingId;
      rating: number;
      constructor(terrainSettingsId: DTerrainSettingId, rating: number);
  }
  export interface DFloorInfo {
      key: string;
      template: string | undefined;
      displayName: string | undefined;
      fixedMapName: string;
      /** false の場合は通常の RMMZ マップ。Entity は登場せず、Event を非表示にすることもない。 */
      /** true の場合、アイテムを置いたり投げたりできない。[捨てる] ができるようになる。一般的な拠点マップを示す。 */
      safetyActions: boolean;
      /** true の場合、ターン経過で満腹度が減ったりする。 */
      bgmName: string;
      bgmVolume: 90;
      bgmPitch: number;
      presetId: DTerrainPresetId;
  }
  export enum DLandIdentificationLevel {
      /** 未識別 */
      Unknown = 0,
      /** 種別識別済み */
      Kind = 1,
      /** 個体識別済み */
      Entity = 2
  }
  export enum DLandForwardDirection {
      /** フロア数が増えるごとに、上の階へ向かう */
      Uphill = 0,
      /** フロア数が増えるごとに、下の階へ向かう */
      Downhill = 1,
      /** 概念的な上下移動を伴わない */
      Flat = 2
  }
  /** Land を抜けた時のステータスに対するルール */
  export enum DLandExitStatusRule {
      /** グローバル設定を継承する */
      Default = 0,
      /** 無し */
      None = 1,
      /** 永続パラメータを含めて、全てのパラメータをリセットする */
      Initialize = 2
  }
  /** Land を抜けた時のインベントリに対するルール */
  export enum DLandExitInventoryRule {
      /** グローバル設定を継承する */
      Default = 0,
      /** 無し */
      None = 1,
      /** 持ち物を全て削除する */
      Initialize = 2
  }
  export class DLandRule {
      enteredStatus: DLandExitStatusRule;
      enteredInventory: DLandExitInventoryRule;
      conqueredStatus: DLandExitStatusRule;
      conqueredInventory: DLandExitInventoryRule;
      abandonedStatus: DLandExitStatusRule;
      abandonedInventory: DLandExitInventoryRule;
      constructor();
  }
  /**
   * ダンジョンや町ひとつ分。
   */
  export class DLand {
      /** ID (0 is Invalid). */
      id: number;
      name: string;
      /** Land の生成元になった、対応するツクール MapId (MR-Land:). */
      rmmzMapId: number;
      /** EventTable MapId. */
      eventTableMapId: number;
      /** ItemTable MapId. */
      itemTableMapId: number;
      /** EnemeyTable MapId. */
      enemyTableMapId: number;
      /** TrapTable MapId. */
      trapTableMapId: number;
      shopTableMapId: number;
      appearanceTable: DAppearanceTableSet;
      /** @MR-Floor から読み取った Floor 情報 */
      floorInfos: DFloorInfo[];
      /** Land に含まれるフロア ([0] is Invalid) 要素数は MRData.MAX_DUNGEON_FLOORS だが、最大フロア数ではないため注意。 */
      floorIds: DMapId[];
      fixedMapIds: DMapId[];
      /** (index: DEntityKindId) */
      identifiedKinds: (DLandIdentificationLevel | undefined)[];
      forwardDirection: DLandForwardDirection;
      private _eventMapIds;
      /**
       * 主にシステムの都合で行先が明示されずに、Land から "出される" ときの移動先となるマップ。
       * ゲームオーバーや "脱出の巻物" などでダンジョンから抜けるときに参照される。
       * このマップは通過点として演出や遷移先の指定のみ利用する。REシステム管理下のマップではない。
       */
      private _exitEventMapIndex;
      private _isWorld;
      constructor(id: DLandId, isWorld: boolean);
      toDebugName(): string;
      validate(): void;
      get isVanillaLand(): boolean;
      get isWorldLand(): boolean;
      get eventMapIds(): readonly DMapId[];
      get exitMapId(): DMapId;
      get exitMapData(): DMap;
      getFloorClass(mapData: DMap): DFloorClass;
      findFixedMapByName(name: string): DMap | undefined;
      addEventMap(map: DMap): void;
      addEventMapAsExitMap(map: DMap): void;
      import(mapData: IDataMap): void;
      private parseLandIdentificationLevel;
      checkIdentifiedKind(kind: DEntityCategory): boolean;
      checkIdentifiedEntity(kind: DEntityCategory): boolean;
      static buildFloorTable(mapData: IDataMap): DFloorInfo[];
      static buildAppearanceTableSet(mapData: IDataMap, rmmzMapId: number, maxFloors: number): DAppearanceTableSet;
      static buildSubAppearanceTable(land: DLand, mapData: IDataMap, rmmzMapId: number, tableSet: DAppearanceTableSet, table: DAppearanceTableEntity[][]): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DMap' {
  import { DMapId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  export enum REFloorMapKind {
      Land = 0,
      TemplateMap = 1,
      FixedMap = 2,
      ShuffleMap = 3,
      RandomMap = 4
  }
  /**
   * マップデータ。RMMZ の MapInfo 相当で、その ID と一致する。
   * FloorInfo と似ているが、こちらは RMMZ Map に対する直接の追加情報を意味する。
   */
  export class DMap {
      /** ID (0 is Invalid). */
      id: DMapId;
      /** Parent Land. */
      landId: number;
      /** RMMZ mapID. (0 is RandomMap) */
      mapId: number;
      /** マップ生成 */
      mapKind: REFloorMapKind;
      exitMap: boolean;
      /** 明示的な MRセーフティマップであるか */
      safetyMap: boolean;
      /** 非REシステムマップにおいて、RMMZオリジナルのメニューを使うか。(つまり、一切 RE システムと関係ないマップであるか) */
      defaultSystem: boolean;
      /** 明示的に RMMZ 標準マップとするか */
      eventMap: boolean;
      constructor(id: DMapId);
      get name(): string;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DMonsterHouse' {
  export type DMonsterHouseTypeId = number;
  export interface DMonsterHouseType {
      id: DMonsterHouseTypeId;
      name: string;
      bgm: IDataSound;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DParameter' {
  import { DParameterId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DValuePoint } from "MysteryRogueSystem/ts/mr/data/DEffect";
  import { DFactionType } from "MysteryRogueSystem/ts/mr/data/DFaction";
  import { DFlavorEffect, IFlavorEffectProps } from "MysteryRogueSystem/ts/mr/data/DFlavorEffect";
  export type DXParamId = number;
  export type DSParamId = number;
  export enum DParameterType {
      Normal = 0,
      Dependent = 1
  }
  export enum DParamMessageValueSource {
      Relative = 0,
      Absolute = 1
  }
  export interface DParamMessage {
      condition: string;
      message: string;
  }
  export enum DValueAddition {
      /** 増減なし・効果なし */
      None = 0,
      /** 増加・回復 */
      Gain = 1,
      /** 減少・ダメージ */
      Loss = 2
  }
  /**
   * 発動する FlavorEffect と、その発動条件のセット
   */
  export class DParameterFlavorEffect {
      /** 発動条件となる対象勢力 */
      looksFaction: DFactionType;
      /** 発動条件となる適用対象 */
      point: DValuePoint;
      /** 発動条件となる値の増減 */
      addition: DValueAddition;
      /** 発動条件式 (value=新しい値, old=古い値, min=最小値, max=最大値)。 undefined の場合は式を評価せず、true とみなす。 */
      conditionFormula: string | undefined;
      /** 発動する効果 */
      flavorEffect: DFlavorEffect;
      constructor(options?: IParameterFlavorEffect);
  }
  /**
   * Unit(Battler) が持つパラメータ
   *
   * Property との違いは、戦闘ダメージなどに関係するものを集めたものである、という点。すべて number で表される。
   *
   * 拡張パラメータ
   * ----------
   * 拡張パラメータはレベルアップに伴い成長することは '無い'。
   * 最低限必要なのは "満腹度"。
   *
   * サバイバル的な拡張を想定すると、
   * - 水分
   * - 疲労度
   *
   * あとこれらのターン経過による増減量を決めるためのパラメータ。
   *
   * - ハラヘリ速度 (SParam) ※SParam は非ダメ側のパラメータと考えるのが良い。ターン経過で World から受ける満腹度へのダメージを抑える、と考える。
   * - HP 回復速度 (SParam)
   *
   *
   * [2022/9/2] SecondaryParameter
   * ----------
   * DependentParameter 検討中に見つかった問題解決。
   * DependentParameter は当初、DParameter とは別のデータ構造として作った。
   * しかし運用を始めた時に、2つの異なるデータとして分けなければならないのが面倒だと感じた。というより、間違えやすい。
   *
   * 例えば
   * - 特定のパラメータに対する攻撃をガードする
   * - 特定のパラメータに対する攻撃を固定ダメージ化する
   * - 特定のパラメータに対する攻撃によって、ステートの解除判定を行う
   * - 特定のパラメータに対するバフ
   * - メッセージその他…
   *
   * データとしては別物であるが、運用上は同じものとして扱いたい。
   * そうしないと、どのパラメータがどのパラメータに依存しているのか、というのを把握するのが難しくなる。
   *
   *
   *
   *
   * [2021/5/17] パラメータは誰が持つ？(特に拡張パラメータ)
   * ----------
   * HPと満腹度。
   * Entity に持たせるか、BattlerBehavior と SurvivorBehavior に分けて持たせるか。
   *
   * ひとまずは BattlerBehavior でいいかな… 明確に分ける理由が無い。メモリ使用量くらい。
   * 拡張パラメータも含め、すべてのパラメータは "ダメージ計算処理" が適用される仕組みになるので、
   * その辺が共通化できる BattlerBehavior に持たせるのが都合いいかも。
   *
   *
   *
   * [2021/5/16]
   * ----------
   * エディタからの任意パラメータ追加はいったん見送ろう。
   * まだシステムがばっちり固まってるわけじゃないので、仕様が決めきれない。
   *
   * 一応のアイデアとしては、パラメータが 0 になったら何かステートを付加して、ペナルティはそっちで付ける、とか。
   *
   *
   */
  export class DParameter {
      /** ID (0 is Invalid). */
      readonly id: DParameterId;
      /** Name */
      readonly key: string;
      readonly code: string;
      type: DParameterType;
      displayName: string;
      displayNameMaximum: string;
      /** RMMZ 標準パラメータであるか。敵味方にかかわらず、すべての Battler はこのパラメータインスタンスを持つ。0 は HP. -1 が無効値。 */
      battlerParamId: number;
      /** 拡張パラメータの時の、初期値 */
      initialIdealValue: number;
      /** 初期値。undefined の場合、Ideal.
       * Level なら 1, Exp なら 0, HP なら Ideal など。 */
      initialValue: number | undefined;
      minEffortLimit: number;
      maxEffortLimit: number;
      minLimit: number;
      maxLimit: number;
      /** [全回復] の対象とするか */
      recoverTarget: boolean;
      magnification: number;
      addBuffCoe: number;
      mulBuffCore: number;
      /** @deprecated */
      selfGainMessage: string | undefined;
      /** @deprecated */
      selfLossMessage: string | undefined;
      /** @deprecated */
      targetGainMessage: string | undefined;
      /** @deprecated */
      targetLossMessage: string | undefined;
      messageValueSource: DParamMessageValueSource;
      /** @deprecated */
      friendlySideMessages: DParamMessage[];
      /** @deprecated */
      opponentSideMessages: DParamMessage[];
      parameterFlavorEffects: DParameterFlavorEffect[];
      allowDamage: boolean;
      static makeBuiltin(id: DParameterId, code: string, displayName: string, displayNameMaximun: string, battlerParamId: number, initialIdealValue: number, minLimit: number, maxLimit: number, recoverTarget: boolean): DParameter;
      constructor(id: DParameterId, key: string, displayName: string);
      makeDisplayValue(value: number): number;
      getParameterFlavorEffectByLooksFaction(value: DFactionType): DParameterFlavorEffect[];
      addFlavorEffect(options: IParameterFlavorEffect): DParameterFlavorEffect;
      addTextFlavorEffect(looksFaction: DFactionType, applyTarget: DValuePoint, addition: DValueAddition, text: string): DParameterFlavorEffect;
  }
  export interface IParameterProps {
      /** パラメータの識別子です。ダメージ計算式での "a.atk" のように、. に続けて指定できる、パラメータの名前です。英数字とする必要があります。 */
      /** パラメータの表示名です。 GUI に表示する名前です。 */
      name?: string;
      flavorEffects?: IParameterFlavorEffect[];
  }
  export interface IParameterFlavorEffect {
      looksFaction?: DFactionType;
      point?: DValuePoint;
      addition?: DValueAddition;
      conditionFormula?: string;
      flavorEffect: IFlavorEffectProps;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DPrefab' {
  import { DStateId } from "MysteryRogueSystem/ts/mr/data/DState";
  export type DPrefabId = number;
  export enum DSystemPrefabKind {
      Unknown = 0,
      EntryPoint = 1,
      ExitPoint = 2
  }
  export interface DPrefabActualImage {
      characterName: string;
      direction: number;
      pattern: number;
      characterIndex: number;
      directionFix: boolean;
      stepAnime: boolean;
      walkAnime: boolean;
  }
  export interface DPrefabOverrideImage {
      characterName?: string;
      characterIndex?: number;
      direction?: number;
      pattern?: number;
      directionFix?: boolean;
      stepAnime?: boolean;
      walkAnime?: boolean;
  }
  export interface DPrefabStateImage {
      stateId: DStateId;
      characterName: string;
      characterIndex: number;
  }
  export interface DPrefabPageInfo {
      stateId: DStateId;
      rmmzEventPageIndex: number;
  }
  export enum DPrefabMoveType {
      Fix = 0,
      Random = 1
  }
  /**
   * DPrefab
   *
   * [2021/4/19] DPrefabKind といった enum で Enemy, Trap, Item などを分類していたのだが、厳しくなってきた。
   * 基本として真に種類を表すのは DItem など別のデータ構造の Kind フィールドなので、こちら側で種類を持つとデータの多重管理になる。
   * また、たくさんある Item の種類をどのくらいの粒度で interface 分けするべきなのかも手探り状態。（Item と Trap は DItem にまとめるか？分けるか？）
   * そのため Prefab 側で kind を持つのはやめて、メソッドでラップする。
   */
  export class DPrefab {
      id: DPrefabId;
      key: string;
      image: DPrefabActualImage;
      subPages: DPrefabPageInfo[];
      stateImages: DPrefabStateImage[];
      /** DownSequel のイメージ */
      downImage: DPrefabOverrideImage;
      moveType: DPrefabMoveType;
      rmmzMapId: number;
      rmmzEventData: IDataMapEvent;
      constructor(id: DPrefabId);
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DPreset' {

}
declare module 'MysteryRogueSystem/ts/mr/data/DPseudonymous' {
  import { DEntityCategoryId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DEntityCategory } from "MysteryRogueSystem/ts/mr/data/DEntityCategory";
  export class DPseudonymous {
      private _names;
      constructor();
      setup(data: any): void;
      kinds(): DEntityCategory[];
      nameList(kindId: DEntityCategoryId): string[] | undefined;
      getNameList(kindId: DEntityCategoryId): string[];
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DRace' {
  import { DRaceId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  export class DRace {
      id: DRaceId;
      key: string;
      name: string;
      traits: IDataTrait[];
      constructor(id: DRaceId);
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DSequel' {
  export type DSequelId = number;
  /**
   * DSequel
   *
   * シミュレーション進行中に発生した、VisualAction を、View に伝えるためのデータ構造。
   * これ自体が具体的なスプライトの動作を定義するわけではない。
   * 「歩行」を再生するべき、「攻撃」を再生するべき、といったタイミングで作られる。
   *
   * なお、歩行は複数アクターが並列で再生できる仕組みを作るのには、イベント発生タイミングを直接 View が
   * 購読してアニメ開始する方法では不可能。（Schedular が View の visualRunning() を監視している都合上不可能）
   * なので、アニメ再生系のイベントは一度キューに入れておいて、全アクターの歩行の処理が完了したら
   * 一斉にアニメーションさせるような流れを組む必要がある。
   * そのキューに入れる単位が DSequel.
   */
  export interface DSequel {
      /** ID (0 is Invalid). */
      id: DSequelId;
      /** Name */
      name: string;
      parallel: boolean;
      /** 一度の Flush で複数あるとき、マージするか */
      fluidSequence: boolean;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DSkill' {
  import { DSkillId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DRmmzEffectScope } from "MysteryRogueSystem/ts/mr/data/DEffect";
  import { DEmittor, DEmittorId } from "MysteryRogueSystem/ts/mr/data/DEmittor";
  import { DFlavorEffect, IFlavorEffectProps } from "MysteryRogueSystem/ts/mr/data/DFlavorEffect";
  export class DSkill {
      /** ID (0 is Invalid). */
      readonly id: DSkillId;
      readonly key: string;
      isActivity: boolean;
      /** Name */
      name: string;
      priority: number;
      /**
       * エディタで指定される Scope.
       *
       * この情報は実際の効果範囲を示すものではなく、AIなどで使用する参考情報となる。
       * つまり、効果の実態がダメージなのか回復なのか、や、投げて使うのか食べ使うのか、といった
       * 実際の振る舞いは関係なしに、「普通に使うときは敵味方どちらを対象とするか？」を指定する。
       */
      rmmzEffectScope: DRmmzEffectScope;
      emittorId: DEmittorId;
      /** スキル発動者に対する FlavorEffect */
      flavorEffect: DFlavorEffect | undefined;
      constructor(id: DSkillId, key: string);
      emittor(): DEmittor;
      setFlavorEffect(options: IFlavorEffectProps): void;
      applyProps(props: ISkillProps): void;
  }
  export interface ISkillProps {
      /**
       * この Skill を発動するときに再生する FlavorEffect。
       */
      flavorEffect?: IFlavorEffectProps;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DSpecialEffect' {
  import { DSpecialEffectId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DEntityId } from "MysteryRogueSystem/ts/mr/data/DEntity";
  export class DSpecialEffect {
      readonly id: DSpecialEffectId;
      readonly key: string;
      constructor(id: DSpecialEffectId, key: string);
      static makeSpecialEffectRef(props: ISpecialEffectProps): DSpecialEffectRef;
  }
  export interface DSpecialEffectRef {
      specialEffectId: DSpecialEffectId;
      entityId?: DEntityId;
      dataId?: number;
      value?: any;
  }
  export interface ISpecialEffectProps_RandomWarp {
      code: "RandomWarp";
  }
  export interface ISpecialEffectProps_Unknown {
      code: "Unknown";
      dataKey: any;
      value: any;
  }
  export type ISpecialEffectProps = ISpecialEffectProps_RandomWarp | ISpecialEffectProps_Unknown;

}
declare module 'MysteryRogueSystem/ts/mr/data/DState' {
  import { DEntityCategoryId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DBehaviorInstantiation } from "MysteryRogueSystem/ts/mr/data/DEntityProperties";
  import { DParameterId } from "ts/mr/data/DCommon";
  import { DSequelId } from "MysteryRogueSystem/ts/mr/data/DSequel";
  import { DStateGroupId } from "MysteryRogueSystem/ts/mr/data/DStateGroup";
  export type DStateId = number;
  export enum DAutoRemovalTiming {
      /** [RMMZ] なし */
      None = 0,
      /** [RMMZ] 行動終了時 */
      AfterAction = 1,
      /** [RMMZ] ターン終了時 */
      TurnEnd = 2,
      ActualParam = 3,
      /** ダメージを "与えようとされたか" */
      DamageTesting = 4,
      FloorTransfer = 5
  }
  export interface DAutoRemoval_None {
      kind: DAutoRemovalTiming.None;
  }
  export interface DAutoRemoval_AfterAction {
      kind: DAutoRemovalTiming.AfterAction;
  }
  export interface DAutoRemoval_TurnEnd {
      kind: DAutoRemovalTiming.TurnEnd;
      /** 継続ターン数 Min */
      minTurns: number;
      /** 継続ターン数 Max */
      maxTurns: number;
  }
  export interface DAutoRemoval_ActualParam {
      kind: DAutoRemovalTiming.ActualParam;
      formula: string;
  }
  export interface DAutoRemoval_DamageTesting {
      kind: DAutoRemovalTiming.DamageTesting;
      paramId: DParameterId;
  }
  export interface DAutoRemoval_FloorTransfer {
      kind: DAutoRemovalTiming.FloorTransfer;
  }
  export type DAutoRemoval = DAutoRemoval_None | DAutoRemoval_AfterAction | DAutoRemoval_TurnEnd | DAutoRemoval_ActualParam | DAutoRemoval_DamageTesting | DAutoRemoval_FloorTransfer;
  export enum DStateRestriction {
      None = 0,
      /** [RMMZ] 敵を攻撃 */
      AttcakToOpponent = 1,
      /** [RMMZ] 誰かを攻撃 */
      AttackToOther = 2,
      /** [RMMZ] 味方を攻撃 */
      AttcakToFriend = 3,
      /** [RMMZ] 行動できない */
      NotAction = 4,
      /** 暗闇 */
      Blind = 5
  }
  export namespace DStateRestriction {
      function fromRmmzRestriction(value: number): DStateRestriction.None | DStateRestriction.AttcakToOpponent | DStateRestriction.AttackToOther | DStateRestriction.AttcakToFriend | DStateRestriction.NotAction;
  }
  export interface DStateMatchConditions {
      kindId: DEntityCategoryId;
  }
  export interface DStateDamageRemovel {
      paramId: DParameterId;
      chance: number;
  }
  export class DStateEffect {
      /** このステートが Match の子効果として定義される際の有効化条件 */
      matchConditions: DStateMatchConditions;
      /** Restriction */
      restriction: DStateRestriction;
      traits: IDataTrait[];
      behaviors: DBehaviorInstantiation[];
      /**
       * 自動解除の定義。
       */
      autoRemovals: DAutoRemoval[];
      /** ダメージを実際に受けた時の解除判定 (ミスしたときは解除判定しない) */
      damageRemovels: DStateDamageRemovel[];
      constructor();
  }
  export interface DStateApplyConditions {
      kindIds: DEntityCategoryId[];
  }
  export enum DStateIntentions {
      None = 0,
      Positive = 1,
      Negative = 2
  }
  export class DState {
      /** ID (0 is Invalid). */
      id: DStateId;
      key: string;
      /** Name */
      displayName: string;
      iconIndex: number;
      displayNameIcon: boolean;
      intentions: DStateIntentions;
      priority: number;
      message1: string;
      message2: string;
      message3: string;
      message4: string;
      stateGroupKeys: string[];
      stateGroupIds: DStateGroupId[];
      deadState: boolean;
      autoAdditionCondition: string | undefined;
      effect: DStateEffect;
      submatchStates: DStateId[];
      /** このステートが付加されているときの Idle Sequel。 */
      idleSequel: DSequelId;
      applyConditions: DStateApplyConditions;
      constructor(id: DStateId);
      import(data: IDataState): void;
  }
  /** @deprecated */
  export function makeStateBehaviorsFromMeta(meta: any | undefined): string[];

}
declare module 'MysteryRogueSystem/ts/mr/data/DStateGroup' {
  export type DStateGroupId = number;
  export class DStateGroup {
      id: DStateGroupId;
      name: string;
      key: string;
      exclusive: boolean;
      constructor(id: DStateGroupId);
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DSystem' {
  import { DSkillId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DEntityId } from "MysteryRogueSystem/ts/mr/data/DEntity";
  import { DFlavorEffect } from "MysteryRogueSystem/ts/mr/data/DFlavorEffect";
  import { DStateId } from "MysteryRogueSystem/ts/mr/data/DState";
  import { DFactionId } from "MysteryRogueSystem/ts/mr/data/MRData";
  export interface DSystemFactions {
      /** Player (RMMZ Actor:1) の属する勢力 */
      player: DFactionId;
      /** Enemy の属する勢力 */
      enemy: DFactionId;
      neutral: DFactionId;
  }
  export interface DSystemStates {
      bless: DStateId;
      curse: DStateId;
      seal: DStateId;
      plating: DStateId;
  }
  export interface DSystemSkills {
      move: DSkillId;
      normalAttack: DSkillId;
  }
  /**
   * MR システムをの基本的な動作に必要な定義済みデータを管理します。
   */
  export class DSystem {
      factions: DSystemFactions;
      trapTargetFactionId: DFactionId;
      skills: DSystemSkills;
      states: DSystemStates;
      floorRoundLimit: number;
      /** 出現テーブルが何もないときに Enemy の Spawn が要求されたときに生成する Entity */
      fallbackEnemyEntityId: DEntityId;
      /** 出現テーブルが何もないときに Item の Spawn が要求されたときに生成する Entity */
      fallbackItemEntityId: DEntityId;
      fallbackGoldEntityId: DEntityId;
      initialPartyMembers: DEntityId[];
      readonly bareHandsFlavorEffect: DFlavorEffect;
      constructor();
      link(testMode: boolean): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DTemplateMap' {
  import { DMapId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  /** 0 is invalid. */
  export type DBlockVisualPartIndex = number;
  /** 0 is invalid. */
  export type DTemplateMapId = number;
  export enum DBlockVisualPartType {
      /** 床 */
      Floor = 0,
      /** 床の装飾 */
      FloorDecoration = 1,
      /** あぜ道 */
      Footpath = 2,
      /** あぜ道の装飾 */
      FootpathDecoration = 3,
      /** 通路 */
      Passageway = 4,
      /** 通路の装飾 */
      PassagewayDecoration = 5,
      /** 水路 */
      Water = 6,
      /** 水路の装飾 */
      WaterDecoration = 7,
      /** 店の床 */
      ShopFloor = 8,
      /** 店の床の装飾 */
      ShopFloorDecoration = 9,
      /** 壁 */
      Wall = 10,
      /** 壁の装飾 */
      WallDecoration = 11,
      /** 壊れない壁 */
      HardWall = 12
  }
  export enum DBlockVisualPartTileType {
      Normal = 0,
      Autotile = 1
  }
  export enum DBlockVisualPartPlacementType {
      Random = 0
  }
  export class DBlockVisualPart {
      index: DBlockVisualPartIndex;
      type: DBlockVisualPartType;
      tileType: DBlockVisualPartTileType;
      tiles: number[];
      height: number;
      placementType: DBlockVisualPartPlacementType;
      constructor(index: number);
  }
  export class DTemplateMap {
      id: DTemplateMapId;
      name: string;
      mapId: DMapId;
      parts: DBlockVisualPart[];
      partIndex: DBlockVisualPartIndex[][];
      tilesetId: number;
      wallHeadAutoTileKind: number;
      wallEdgeAutoTileKind: number;
      floorAutoTileKind: number;
      itemShopFloorAutoTileKind: number;
      constructor(id: DTemplateMapId);
      import(mapData: IDataMap): void;
      toTemplateMapPartType(type: string): DBlockVisualPartType;
      toTemplateMapPartPlacementType(type: string): DBlockVisualPartPlacementType;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DTerrainPreset' {
  import { DTerrainPresetId as DFloorPresetId, DTerrainSettingId, DTerrainShapeId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DFloorMonsterHousePattern, DTerrainSettingRef } from "MysteryRogueSystem/ts/mr/data/DLand";
  export enum DSectorConnectionPreset {
      Default = 0,
      C = 1,
      H = 2
  }
  export enum FGenericRandomMapWayConnectionMode {
      /** 区画の辺に通路を繋げる。通路が部屋を回り込んだり、全体的に長くなるためクロスが多くなったり、予測しづらく複雑なマップを生成する。 */
      SectionEdge = 0,
      /** 部屋の辺に通路を繋げる。通路の回り込みは無くなり、部屋の基準点間の最短距離を結ぶようになる。部屋から通路が伸びる方向にはほぼ必ず部屋があるため、予測しやすく難易度の低いマップとなる。 */
      RoomEdge = 1
  }
  export interface DForceTerrainRoomShape {
      typeName: string;
  }
  export interface DTerrainStructureDef {
      typeName: string;
      rate: number;
  }
  export interface DForceTerrainStructure {
      typeName: string;
      rate: number;
  }
  export interface DTerrainShopDef {
      typeName: string;
      rate: number;
  }
  export interface DTerrainMonsterHouseDef {
      typeName: string;
      rate: number;
  }
  export class DTerrainShape {
      id: DTerrainShapeId;
      key: string;
      width: number;
      height: number;
      divisionCountX: number;
      divisionCountY: number;
      roomCountMin: number;
      roomCountMax: number;
      wayConnectionMode: FGenericRandomMapWayConnectionMode;
      connectionPreset: DSectorConnectionPreset;
      forceRoomShapes: DForceTerrainRoomShape[];
      constructor(id: DTerrainShapeId);
  }
  export interface DTerrainShapeRef {
      dataId: DTerrainShapeId;
      rate: number;
  }
  /**
   *
   *
   *
   * [2022/2/21] Structure を Preset で指定する必要があるのか？FloorInfo 側で指定したほうが良いのではないか？
   * ----------
   * 必須ではない。これはどちらかというと、設定を楽にするため。
   *
   * - そのフロアは、通常マップか大部屋の2種類をとりえる。
   * - 大部屋となった場合は確定でモンスターハウス。
   *
   * このような条件の場合、次のように書くことができる。
   *
   * ```
   * @MR-Floor
   *     presets: [
   *         ["kTerrainSetting_Default", 5],
   *         ["kTerrainSetting_GreatHallMonsterHouse", 5],
   *     ]
   * ```
   *
   * もし Structure を Preset で持たない場合、次のように書く必要があるだろう。
   *
   * ```
   * @MR-Floor
   *     presets: [
   *         {
   *             key: "kTerrainSetting_Default",
   *             rate: 5,
   *         },
   *         {
   *             key: "kTerrainSetting_GreatHallMonsterHouse",
   *             rate: 5,
   *             forceStructures: ["MonsterHouse"]
   *         },
   *     ]
   * ```
   *
   * 当然ながら、ツクールの注釈には入りきらない。
   *
   * またシレン2中腹の井戸のように、定期的に大部屋モンスターハウスが発生するような場合、上記全く同じ設定をたくさんのフロア情報に記述する必要がある。
   * 設定を変更したいときに全フロア見直すのはかなり大変。
   * 例えば次のような Preset を作るのが良いだろう。
   *
   * - kTerrainPreset_中腹の井戸_Default
   * - kTerrainPreset_中腹の井戸_大部屋モンスターハウス
   *
   * [2022/2/21] @MR-Floor での指定を、もう一段グループ化したい
   * ----------
   *
   * ```
   * @MR-Floor
   *     terrain: "kTerrainPresets_Default"
   * ```
   *
   * 前項のままだと、アルファベットマップをランダム選択するときに、@MR-Floor にそれぞれの Preset を書かなければならなくなる。
   * 次のようなのを用意できるといいかも。
   *
   * - kTerrainPresets_ダンジョンA_低層
   * - kTerrainPresets_ダンジョンA_中層
   * - kTerrainPresets_ダンジョンA_深層
   */
  export class DTerrainSetting {
      id: DTerrainSettingId;
      key: string;
      shapeRefs: DTerrainShapeRef[];
      structureDefs: DTerrainStructureDef[];
      forceStructures: DForceTerrainStructure[];
      shopDefs: DTerrainShopDef[];
      monsterHouseDefs: DTerrainMonsterHouseDef[];
      constructor(id: DTerrainSettingId);
  }
  export class DFloorPreset {
      id: DFloorPresetId;
      key: string;
      terrains: DTerrainSettingRef[];
      monsterHouses: DFloorMonsterHousePattern[];
      constructor(id: DFloorPresetId);
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DTextManager' {
  export class DTextManager {
      static score: string;
      static basic(basicId: number): string;
      static param(paramId: number): string;
      static command(commandId: number): string;
      static message(messageId: string): string;
      static get level(): string;
      static get exp(): string;
      static get save(): string;
      static get obtainExp(): string;
      static get levelUp(): string;
      static get actorDamage(): string;
      static get actorRecovery(): string;
      static get actorDrain(): string;
      static get actorNoDamage(): string;
      static get actorGain(): string;
      static get actorLoss(): string;
      static get actorNoHit(): string;
      static get enemyDamage(): string;
      static get enemyRecovery(): string;
      static get enemyDrain(): string;
      static get enemyNoDamage(): string;
      static get enemyGain(): string;
      static get enemyLoss(): string;
      static get enemyNoHit(): string;
      static get buffAdd(): string;
      static get debuffAdd(): string;
      static get buffRemove(): string;
      static get actionFailure(): string;
      static get currencyUnit(): string;
      static weaponStrength(): string;
      static shieldStrength(): string;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DTraits' {
  export type DTraitId = number;
  /**
   * コアスクリプトの Trait は number だけで識別されるものであるが、
   * RE としてはメモ欄を使った指定を行う際の名前検索などで Trait というデータ自体に若干属性が必要になる。
   *
   * NOTE: Behavior と Trait は違うもの？
   * ----------
   * ひとまず、違うものにしてみる。
   * Behavior に対して Trait は静的なデータ。特に単なるフラグを表したい時に使う。
   * よく見え状態、透視状態、ワナ回避状態、ハラヘラズ状態、ワナ師状態、など。
   * ちなみにこれらは、例えばワナ回避状態であれば、そういった状態を処理できるフローは Behavior に実装され、
   * 実際にその条件を通るかは Trait を持っているかどうか、に依る。
   * - Behavior は "資質"
   * - Trait はその資質を発動させる "鍵"
   * みたいに考えるとよさそう。
   * ただ、よく見え状態やワナ師状態などは必ずしも個々のEntityの Behavior だけで解決できるものではない。
   * そういったものモノある点に注意。
   * それでもまぁ、例えば "勢力の資質" とか "パーティの資質" とかで考えるといいかも。
   */
  export class DTrait {
      /** ID (0 is Invalid). */
      id: DTraitId;
      /** Key */
      key: string;
      constructor(id: DTraitId, key: string);
      /** @deprecated DMetadataParser */
      static parseTraitMetadata(meta: any): IDataTrait[];
      private static parseDataId;
      static makeTraitData(props: ITraitProps): IDataTrait;
  }
  export interface ITraitProps_DeathVulnerableElement {
      /** DeathVulnerableElement1 */
      code: "DeathVulnerableElement";
      elementKey: string;
      stateKey: string;
  }
  export interface ITraitProps_RaceRate {
      /** RaceRate1 */
      code: "RaceRate";
      raceKey: string;
      value: number;
  }
  export interface ITraitProps_SurvivalParameterLossRate {
      /** SurvivalParameterLossRate1 */
      code: "SurvivalParameterLossRate";
      /** パラメータ Key. */
      parameterKey: string;
      /** 率 (double) */
      value: number;
  }
  export interface ITraitProps_ParameterDamageRate {
      /** ParameterDamageRate1 */
      code: "ParameterDamageRate";
      /** パラメータ Key. */
      parameterKey: string;
      /** 率 (double) */
      value: number;
  }
  export interface ITraitProps_SkillGuard {
      /** SkillGuard1 */
      code: "SkillGuard";
      /** スキル Key. */
      skillKey: string;
  }
  export interface ITraitProps_Unknown {
      code: "Unknown";
      dataKey: any;
      value: any;
  }
  export type ITraitProps = ITraitProps_DeathVulnerableElement | ITraitProps_RaceRate | ITraitProps_SurvivalParameterLossRate | ITraitProps_ParameterDamageRate | ITraitProps_SkillGuard | ITraitProps_Unknown;

}
declare module 'MysteryRogueSystem/ts/mr/data/DTroop' {
  import { DEntityId } from "MysteryRogueSystem/ts/mr/data/DEntity";
  export type DTroopId = number;
  export class DTroop {
      id: DTroopId;
      key: string;
      members: DEntityId[];
      constructor(id: DTroopId);
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/DValidationHelper' {
  export class DValidationHelper {
      static makeDataName(typeName: string, id: number, dataName: string): string;
      static makeRmmzTroopName(rmmzTrppoId: number): string;
      static makeRmmzEnemyName(rmmzEnemyId: number): string;
      static makeRmmzMapName(mapId: number): string;
      static makeRmmzEventName(event: IDataMapEvent): string;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/importers/DAttributeReader' {
  import { DTroopId } from "MysteryRogueSystem/ts/mr/data/DTroop";
  export interface RmmzLandAttribute {
      identifications?: string[];
  }
  /** @deprecated */
  export interface RmmzStructuresMetadata {
  }
  export interface RmmzFloorRawAttribute {
      template?: string;
      displayName?: string;
      fixedMap?: string;
      safety?: boolean;
      bgm?: any[];
      preset?: string;
  }
  export interface RmmzEventPrefabAttribute {
      stateImages?: any[];
  }
  export interface RmmzEventPrefabSubPageAttribute {
      state?: string;
  }
  export interface RmmzSpawnerAttribute {
      entity: string;
      states: string[];
      troopId: DTroopId;
      stackCount: number | undefined;
      override: boolean;
      overrideEvent: boolean;
      keeper: boolean;
      gold: number;
      rate: number;
  }
  export interface RmmzREEventAttribute {
      trigger?: string;
      condition_state?: string;
  }
  export interface RmmzMRTemplatePartAttribute {
      type?: string;
      height?: number;
      placement?: string;
  }
  export interface RmmzMRTroopAttribute {
      key: string;
  }
  export interface RmmzEventListItem {
      code: number;
      indent: number;
      parameters: string[];
  }
  export class DAnnotationReader {
      static findFirstAnnotationFromEvent(annotation: string, event: IDataMapEvent): string | undefined;
      static findFirstAnnotationFromPage(annotation: string, list: RmmzEventListItem[]): string | undefined;
      static tryGetAnnotationFromEvent(annotation: string, event: IDataMapEvent, rmmzMapId: number): any | undefined;
      static readLandMetadata(event: IDataMapEvent): RmmzLandAttribute | undefined;
      /** @deprecated */
      static readStructuresMetadata(event: IDataMapEvent): RmmzStructuresMetadata | undefined;
      static readPrefabMetadata(event: IDataMapEvent, rmmzMapId: number): RmmzEventPrefabAttribute | undefined;
      static readPrefabSubPageMetadata(page: IDataMapEventPage): RmmzEventPrefabSubPageAttribute | undefined;
      static readEntityMetadataFromPage(page: IDataMapEventPage): RmmzSpawnerAttribute | undefined;
      static readFloorMetadataFromPage(page: IDataMapEventPage): RmmzFloorRawAttribute | undefined;
      static readREEventMetadataFromPage(page: IDataMapEventPage): RmmzREEventAttribute | undefined;
      static readTemplatePartAttributeFromPage(page: IDataMapEventPage): RmmzMRTemplatePartAttribute | undefined;
      static readTroopAttributeFromPage(page: IDataPage): RmmzMRTroopAttribute | undefined;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/importers/DFloorPresetImporter' {
  export class DFloorPresetImporter {
      private _db;
      constructor(script: string);
      private import;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/importers/DMetadataParser' {
  import { DBehaviorInstantiation } from "MysteryRogueSystem/ts/mr/data/DEntityProperties";
  export class DMetadata {
      key: string;
      entityTemplateKey: string | undefined;
      effectKey: string | undefined;
      emittorKey: string | undefined;
      type: string;
      category: string;
      capacity: string | undefined;
      /** MR-Behavior */
      behaviors: DBehaviorInstantiation[];
      /** MR-Trait */
      traits: IDataTrait[];
      races: string[];
      constructor();
  }
  export class DMetadataParser {
      static parse(meta: any | undefined): DMetadata;
      private static parseMetadata_Behavior;
      private static parseTraitDataId;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/importers/DSetupScripEvaluator' {
  import { DSetupScriptDatabase } from "MysteryRogueSystem/ts/mr/data/importers/DSetupScript";
  import { IEffectProps, IParameterBuffEffectProps, IParameterDamageEffectProps } from "MysteryRogueSystem/ts/mr/data/DEffect";
  import { IFlavorEffectProps } from "MysteryRogueSystem/ts/mr/data/DFlavorEffect";
  import { IEmittorProps } from "MysteryRogueSystem/ts/mr/data/DEmittor";
  import { IEntityProps, IReactionProps } from "MysteryRogueSystem/ts/mr/data/DEntity";
  import { IEntityTemplateProps } from "MysteryRogueSystem/ts/mr/data/DEntityTemplate";
  import { IEntityCategoryProps } from "MysteryRogueSystem/ts/mr/data/DEntityCategory";
  import { ISpecialEffectProps } from "MysteryRogueSystem/ts/mr/data/DSpecialEffect";
  import { ITraitProps } from "MysteryRogueSystem/ts/mr/data/DTraits";
  global {
      function EntityCategory(props: IEntityCategoryProps): IEntityCategoryProps;
      function Effect(props: IEffectProps): IEffectProps;
      function ParameterDamage(props: IParameterDamageEffectProps): IParameterDamageEffectProps;
      function ParameterBuff(props: IParameterBuffEffectProps): IParameterBuffEffectProps;
      function SpecialEffect(props: ISpecialEffectProps): ISpecialEffectProps;
      function Trait(props: ITraitProps): ITraitProps;
      function FlavorEffect(props: IFlavorEffectProps): IFlavorEffectProps;
      function Emittor(props: IEmittorProps): IEmittorProps;
      function Entity(props: IEntityProps): IEntityProps;
      function Reaction(props: IReactionProps): IReactionProps;
      function EntityTemplate(props: IEntityTemplateProps): IEntityTemplateProps;
  }
  export function evalScript(obj: DSetupScriptDatabase, script: string): void;

}
declare module 'MysteryRogueSystem/ts/mr/data/importers/DSetupScript' {
  import { DEntity, IEntityProps } from "MysteryRogueSystem/ts/mr/data/DEntity";
  import { DParameter } from "MysteryRogueSystem/ts/mr/data/DParameter";
  import { DSkill, ISkillProps } from "MysteryRogueSystem/ts/mr/data/DSkill";
  import { IEffectProps } from "MysteryRogueSystem/ts/mr/data/DEffect";
  import { IEmittorProps } from "MysteryRogueSystem/ts/mr/data/DEmittor";
  import { IEntityTemplateProps } from "MysteryRogueSystem/ts/mr/data/DEntityTemplate";
  import { IEntityCategoryProps } from "MysteryRogueSystem/ts/mr/data/DEntityCategory";
  export interface DSParameters {
      setup: (parameter: DParameter) => void;
  }
  export interface DSetupAction {
      setup: (skill: DSkill) => void;
  }
  export interface DSEntity {
      setup: (entity: DEntity) => void;
  }
  export class DSetupScriptDatabase {
      parameters: {
          [key: string]: DSParameters;
      };
      entityCategories: {
          [key: string]: IEntityCategoryProps;
      };
      entityTemplates: {
          [key: string]: IEntityTemplateProps;
      };
      entities3: {
          [key: string]: DSEntity;
      };
      actions: {
          [key: string]: ISkillProps;
      };
      effects: {
          [key: string]: IEffectProps;
      };
      emittors: {
          [key: string]: IEmittorProps;
      };
      entities: {
          [key: string]: IEntityProps;
      };
      constructor();
      mergeFrom(other: DSetupScriptDatabase): void;
  }
  export var db: DSetupScriptDatabase | undefined;
  export function setDB(v: DSetupScriptDatabase | undefined): void;
  export class DSetupScript {
      private _mainDB;
      constructor();
      addScript(script: string): void;
      registerData(): void;
      setupData(): void;
      private createEntityCategories;
      private setupEntityCategories;
      private createEffects;
      private setupEffects;
      private createEmittors;
      private setupEmittors;
      private createActions;
      private setupActions;
      private createEntityTemplates;
      private setupEntityTemplates;
      private createEntities;
      private setupEntities;
      setupItem(entity: DEntity): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/importers/DTerrainSettingImporter' {
  export class DTerrainSettingImporter {
      private _db;
      constructor(script: string);
      private import;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/index' {
  export * from "MysteryRogueSystem/ts/mr/data/DEffect";
  export * from "MysteryRogueSystem/ts/mr/data/DFaction";
  export * from "MysteryRogueSystem/ts/mr/data/DFlavorEffect";
  export * from "MysteryRogueSystem/ts/mr/data/DParameter";
  export * from "MysteryRogueSystem/ts/mr/data/importers/DSetupScript";
  export * from "MysteryRogueSystem/ts/mr/data/importers/DSetupScripEvaluator";
  export * from "MysteryRogueSystem/ts/mr/data/DTextManager";
  export * from "MysteryRogueSystem/ts/mr/data/MRData";
  export * from "MysteryRogueSystem/ts/mr/data/MRBasics";

}
declare module 'MysteryRogueSystem/ts/mr/data/MRBasics' {
  import { DClassId } from "MysteryRogueSystem/ts/mr/data/DClass";
  import { DElementId, DSpecialEffectId as DSpecialEffectId, DTerrainPresetId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DBasicActions } from "MysteryRogueSystem/ts/mr/data/predefineds/DBasicActions";
  import { DBasicCommands } from "MysteryRogueSystem/ts/mr/data/predefineds/DBasicCommands";
  import { BasicEntityKinds } from "MysteryRogueSystem/ts/mr/data/predefineds/DBasicEntityKinds";
  import { DBasicEvents } from "MysteryRogueSystem/ts/mr/data/predefineds/DBasicEvents";
  import { DBasicItemShops } from "MysteryRogueSystem/ts/mr/data/predefineds/DBasicItemShops";
  import { DBasicMonsterHouses } from "MysteryRogueSystem/ts/mr/data/predefineds/DBasicMonsterHouses";
  import { DBasicParameters, DBasicSParams, DBasicXParams } from "MysteryRogueSystem/ts/mr/data/predefineds/DBasicParameters";
  import { DBasicPrefabs } from "MysteryRogueSystem/ts/mr/data/predefineds/DBasicPrefabs";
  import { BasicSequels } from "MysteryRogueSystem/ts/mr/data/predefineds/DBasicSequels";
  import { DBasicStates } from "MysteryRogueSystem/ts/mr/data/predefineds/DBasicStates";
  import { DBasicTraits } from "MysteryRogueSystem/ts/mr/data/predefineds/DBasicTraits";
  export interface DBasicVariables {
      result: number;
      landExitResult: number;
      landExitResultDetail: number;
  }
  export interface DBasicElements {
      explosion: DElementId;
  }
  export interface DBasicSpecialEffects {
      itemSteal: DSpecialEffectId;
      goldSteal: DSpecialEffectId;
      levelDown: DSpecialEffectId;
      randomWarp: DSpecialEffectId;
      stumble: DSpecialEffectId;
      transferToNextFloor: DSpecialEffectId;
      transferToLowerFloor: DSpecialEffectId;
      trapProliferation: DSpecialEffectId;
      /** @deprecated SubComponent の検索ができるようになったので、それで対応する。SpecialEffect 内で実装する場合、EffectResult を自分で表示するような使実装が必要になる。 */
      dispelEquipments: DSpecialEffectId;
      changeInstance: DSpecialEffectId;
      restartFloor: DSpecialEffectId;
      clarification: DSpecialEffectId;
      division: DSpecialEffectId;
      removeStatesByIntentions: DSpecialEffectId;
      performeSkill: DSpecialEffectId;
  }
  export enum DClarificationType {
      Unit = 0,
      Item = 1,
      Trap = 2,
      Terrain = 3,
      Sight = 4
  }
  /**
   * ゲームシステムとして重要な定義済みデータを保持する
   */
  export class MRBasics {
      static variables: DBasicVariables;
      static elements: DBasicElements;
      static events: DBasicEvents;
      static actions: DBasicActions;
      static commands: DBasicCommands;
      static entityCategories: BasicEntityKinds;
      static states: DBasicStates;
      static params: DBasicParameters;
      static xparams: DBasicXParams;
      static sparams: DBasicSParams;
      static monsterHouses: DBasicMonsterHouses;
      static itemShops: DBasicItemShops;
      static prefabs: DBasicPrefabs;
      static sequels: BasicSequels;
      static effectBehaviors: DBasicSpecialEffects;
      static traits: DBasicTraits;
      static defaultEnemyClass: DClassId;
      static defaultTerrainPresetId: DTerrainPresetId;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/MRData' {
  import { LBehavior } from "ts/mr/lively/behaviors/LBehavior";
  import { DState } from "MysteryRogueSystem/ts/mr/data/DState";
  import { DSystem } from "MysteryRogueSystem/ts/mr/data/DSystem";
  import { DSkill } from "MysteryRogueSystem/ts/mr/data/DSkill";
  import { DClass } from "MysteryRogueSystem/ts/mr/data/DClass";
  import { DItem, DItemDataId } from "MysteryRogueSystem/ts/mr/data/DItem";
  import { DLand } from "MysteryRogueSystem/ts/mr/data/DLand";
  import { DEntityCategory } from "MysteryRogueSystem/ts/mr/data/DEntityCategory";
  import { DSequel, DSequelId } from "MysteryRogueSystem/ts/mr/data/DSequel";
  import { DEnemy, DEnemyId } from "MysteryRogueSystem/ts/mr/data/DEnemy";
  import { DEquipmentPart } from "MysteryRogueSystem/ts/mr/data/DEquipmentPart";
  import { DActor } from "MysteryRogueSystem/ts/mr/data/DActor";
  import { DAbility } from "MysteryRogueSystem/ts/mr/data/DAbility";
  import { DMonsterHouseType } from "MysteryRogueSystem/ts/mr/data/DMonsterHouse";
  import { DTemplateMap } from "MysteryRogueSystem/ts/mr/data/DTemplateMap";
  import { DPrefab } from "MysteryRogueSystem/ts/mr/data/DPrefab";
  import { DTrait } from "MysteryRogueSystem/ts/mr/data/DTraits";
  import { DParameter } from "MysteryRogueSystem/ts/mr/data/DParameter";
  import { DEntity, DEntityId } from "MysteryRogueSystem/ts/mr/data/DEntity";
  import { DTroop } from "MysteryRogueSystem/ts/mr/data/DTroop";
  import { DStateGroup } from "MysteryRogueSystem/ts/mr/data/DStateGroup";
  import { DPseudonymous } from "MysteryRogueSystem/ts/mr/data/DPseudonymous";
  import { DItemShopType } from "MysteryRogueSystem/ts/mr/data/DItemShop";
  import { MRDataExtension } from "MysteryRogueSystem/ts/mr/data/MRDataExtension";
  import { DEmittor, DEmittorId } from "MysteryRogueSystem/ts/mr/data/DEmittor";
  import { DElement } from "MysteryRogueSystem/ts/mr/data/DElement";
  import { DRace } from "MysteryRogueSystem/ts/mr/data/DRace";
  import { DFloorPreset, DTerrainSetting, DTerrainShape } from "MysteryRogueSystem/ts/mr/data/DTerrainPreset";
  import { DCommand } from "MysteryRogueSystem/ts/mr/data/DCommand";
  import { DEffect } from "MysteryRogueSystem/ts/mr/data/DEffect";
  import { DParameterId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DMap } from "MysteryRogueSystem/ts/mr/data/DMap";
  import { DEntityTemplate, IEntityTemplateProps } from "MysteryRogueSystem/ts/mr/data/DEntityTemplate";
  import { DSpecialEffect } from "MysteryRogueSystem/ts/mr/data/DSpecialEffect";
  export type DFactionId = number;
  /**
   * 勢力
   */
  export interface REData_Faction {
      /** ID (0 is Invalid). */
      id: DFactionId;
      /** Name */
      name: string;
      /** 行動順 */
      schedulingOrder: number;
      hostileBits: number;
      friendBits: number;
  }
  export enum LandExitResult {
      /** 冒険中 */
      Challenging = 100,
      /** ゴールに到達した。最後のフロアを抜けたか、戻り状態で最初のフロアを抜けたとき。 */
      Goal = 200,
      /** 脱出の巻物などによって冒険を中断した。 */
      Escape = 300,
      /** ゲームオーバーによって Land から出された。 */
      Gameover = 400,
      /** 冒険をあきらめた（メニューから） */
      Abandoned = 401,
      /** 制約付きのハードコアモードなど、ダンジョン内でセーブせずにゲームを終えたらゲームオーバー扱いする。 */
      InvalidSuspend = 402
  }
  /** Database */
  export class MRData {
      static readonly MAX_DUNGEON_FLOORS = 100;
      static testMode: boolean;
      static NormalAttackSkillId: number;
      static ext: MRDataExtension;
      static system: DSystem;
      static elements: DElement[];
      static equipmentParts: DEquipmentPart[];
      static entityKinds: DEntityCategory[];
      static classes: DClass[];
      static races: DRace[];
      static actors: DEntityId[];
      static enemies: DEntityId[];
      static lands: DLand[];
      static maps: DMap[];
      static templateMaps: DTemplateMap[];
      static factions: REData_Faction[];
      static commands: DCommand[];
      static sequels: DSequel[];
      static parameters: DParameter[];
      static effectBehaviors: DSpecialEffect[];
      static skills: DSkill[];
      static items: DEntityId[];
      static traits: DTrait[];
      static states: DState[];
      static stateGroups: DStateGroup[];
      static abilities: DAbility[];
      static monsterHouses: DMonsterHouseType[];
      static itemShops: DItemShopType[];
      static prefabs: DPrefab[];
      static entities: DEntity[];
      static entityTemplates: DEntityTemplate[];
      static troops: DTroop[];
      static emittors: DEmittor[];
      static effects: DEffect[];
      static terrainShapes: DTerrainShape[];
      static terrainSettings: DTerrainSetting[];
      static floorPresets: DFloorPreset[];
      static pseudonymous: DPseudonymous;
      static itemDataIdOffset: number;
      static weaponDataIdOffset: number;
      static armorDataIdOffset: number;
      static _behaviorFactories: (() => LBehavior)[];
      static reset(): void;
      static newElement(key: string): DElement;
      static getElement(pattern: string): DElement;
      static newEntityCategory(key: string, displayName?: string): number;
      static findEntityCategory(pattern: string): DEntityCategory | undefined;
      static getEntityCategory(pattern: string): DEntityCategory;
      static newClass(name: string): number;
      static newRace(): DRace;
      static findRace(pattern: string): DRace | undefined;
      static getRace(pattern: string): DRace;
      static newTemplateMap(): DTemplateMap;
      static newCommand(name: string): DCommand;
      static addSequel(name: string): DSequelId;
      static addParams(key: string, displayName: string): DParameter;
      static getParameter(key: DParameterId | string): DParameter;
      static newEntity(): DEntity;
      static findEntity(pattern: string): DEntity | undefined;
      static getEntity(pattern: string): DEntity;
      static newEntityTemplate(key: string, props: IEntityTemplateProps): DEntityTemplate;
      static findEntityTemplate(pattern: string): DEntityTemplate | undefined;
      static getEntityTemplate(pattern: string): DEntityTemplate;
      static newPrefab(): DPrefab;
      static newMap(): DMap;
      static findMap(pattern: string): DMap | undefined;
      static getMap(pattern: string): DMap;
      static newEffect(key: string): DEffect;
      static cloneEffect(src: DEffect): DEffect;
      static findEffect(pattern: string): DEffect | undefined;
      static getEffect(pattern: string): DEffect;
      static newEmittor(key: string): DEmittor;
      static cloneEmittor(src: DEmittor): DEmittor;
      static findEmittor(pattern: string): DEmittor | undefined;
      static getEmittor(pattern: string): DEmittor;
      static getEmittorById(id: DEmittorId): DEmittor;
      static newTerrainShape(key: string): DTerrainShape;
      static findTerrainShape(pattern: string): DTerrainShape | undefined;
      static getTerrainShape(pattern: string): DTerrainShape;
      static newTerrainSetting(key: string): DTerrainSetting;
      static findTerrainSetting(pattern: string): DTerrainSetting | undefined;
      static getTerrainSetting(pattern: string): DTerrainSetting;
      static newFloorPreset(key: string): DFloorPreset;
      static findFloorPreset(pattern: string): DFloorPreset | undefined;
      static getFloorPreset(pattern: string): DFloorPreset;
      static newActor(): [DEntity, DActor];
      static actorEntity(id: DEnemyId): DEntity;
      static actorData(id: DEnemyId): DActor;
      static findActor(pattern: string): DActor | undefined;
      static getActor(pattern: string): DActor;
      static newEffectBehavior(key: string): DSpecialEffect;
      static findSpecialEffect(pattern: string): DSpecialEffect | undefined;
      static getSpecialEffect(pattern: string): DSpecialEffect;
      static newItem(): [DEntity, DItem];
      static itemEntity(id: DItemDataId): DEntity;
      static itemData(id: DItemDataId): DItem;
      static findItem(pattern: string): DItem | undefined;
      static getItem(pattern: string): DEntity;
      static getItemFromRmmzWeaponId(rmmzWeaponId: number): DEntity;
      static getItemFromRmmzArmorId(rmmzArmorId: number): DEntity;
      static newEnemy(): [DEntity, DEnemy];
      static enemyEntity(id: DEnemyId): DEntity;
      static enemyData(id: DEnemyId): DEnemy;
      static findEnemy(pattern: string): DEnemy | undefined;
      static getEnemy(pattern: string): DEnemy;
      static newTrait(key: string): DTrait;
      static getTrait(pattern: string): DTrait;
      static findPrefab(pattern: string): DPrefab | undefined;
      static getPrefab(pattern: string): DPrefab;
      static findState(pattern: string): DState | undefined;
      static getState(pattern: string): DState;
      static findMonsterHouse(pattern: string): DMonsterHouseType | undefined;
      static getMonsterHouse(pattern: string): DMonsterHouseType;
      static newSkillAsActivity(key: string, displayName: string, priority?: number): DSkill;
      static findSkill(pattern: string): DSkill | undefined;
      static getSkill(pattern: string): DSkill;
      static verify(): void;
      static findHelper<T>(list: T[], pattern: string, predicate: (x: T) => boolean): T | undefined;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/MRDataExtension' {
  export class MRDataExtension {
      onDatabaseLoaded(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/MRDataManager' {
  import { DMapId } from 'MysteryRogueSystem/ts/mr/data/DCommon';
  type NextFunc = () => void;
  export class MRDataManager {
      static testMode: boolean;
      static databaseMapId: number;
      private static _loadTasks;
      private static _currentTask;
      static load(): void;
      static isImportCompleted(): boolean;
      private static nextFunc;
      private static setupCommonData;
      private static loadData;
      private static importTerrainSettings;
      private static importFloorPreset;
      private static importLandAndFloors;
      private static importPseudonymous;
      private static importPrefabs;
      private static importLandDatabase;
      private static importTemplateMaps;
      static importSetupScript(next: NextFunc): void;
      private static beginLoadMapData;
      private static padZero;
      private static makeParameterQualifying;
      private static isDatabaseMap;
      static isLandMap(mapId: DMapId): boolean;
      static isRESystemMap(mapId: DMapId): boolean;
      private static _loadingDataFileCount;
      private static _loadedDataFileCount;
      private static loadDataFile;
      private static loadTextFile;
      private static onXhrLoad;
  }
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/data/MRSetup' {
  import { DEmittor } from "MysteryRogueSystem/ts/mr/data/DEmittor";
  import { DEntity } from "MysteryRogueSystem/ts/mr/data/DEntity";
  import { DPrefab } from "MysteryRogueSystem/ts/mr/data/DPrefab";
  import { DSkill } from "MysteryRogueSystem/ts/mr/data/DSkill";
  import { DState } from "MysteryRogueSystem/ts/mr/data/DState";
  import { DStateGroup } from "MysteryRogueSystem/ts/mr/data/DStateGroup";
  import { DRace } from "MysteryRogueSystem/ts/mr/data/DRace";
  import { DParameter } from "MysteryRogueSystem/ts/mr/data/DParameter";
  export class MRSetup {
      static setupParameter(data: DParameter): void;
      static setupPrefab(data: DPrefab): void;
      static setupRace(data: DRace): void;
      static setupActor(entity: DEntity): void;
      static setupDirectly_DItem(entity: DEntity): void;
      static setupDirectly_Skill(data: DSkill): void;
      static linkSkill(data: DSkill): void;
      static linkItem(entity: DEntity): void;
      static setupEnemy(entity: DEntity): void;
      static setupDirectly_State(data: DState): void;
      static setupDirectly_StateGroup(data: DStateGroup): void;
      private static setupItemCommon;
      static setupWeaponCommon(entity: DEntity): void;
      static setupShieldCommon(entity: DEntity): void;
      private static setupArrowCommon;
      private static setupRingCommon;
      static setupFoodCommon(entity: DEntity, fp?: number): void;
      static setupGrassCommon(entity: DEntity, fp?: number): [DEmittor, DEmittor];
      private static setupStaffCommon;
      private static setupScrollCommon;
      private static addVulnerableDeathExplosion;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/predefineds/DBasicActions' {
  import { DActionId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  export interface DBasicActions {
      DirectionChangeActionId: DActionId;
      /** 隣接タイルへの移動 */
      MoveToAdjacentActionId: DActionId;
      /**
       * 拾おうとしている・拾われようとしている・拾う・拾われた
       *
       * 壺に入れるのか、矢束に混ぜるのかなどの判断が必要になることがあるため、インベントリへの追加は actor が行う。
       */
      PickActionId: DActionId;
      /**
       * 置こうとしている・置かれようとしている・置く・置かれた
       *
       * Entity を Map に配置するのは actor 側にしてみる。(「撃つ」と同じ)
       * reactor 側で土偶オブジェクト化などが必要であれば、配置された状態から処理を始めることになる。
       */
      PutActionId: DActionId;
      /**
       * 交換
       *
       * [拾う][置く] とは区別する。お金を拾うとき、シレン5などでは [拾う] では所持金に加算されるが、[交換] ではアイテムと交換できる。
       * (SFC シレンではそうではないようだが http://twist.jpn.org/sfcsiren/index.php?%E3%82%AE%E3%82%BF%E3%83%B3%E6%8A%95%E3%81%92)
       */
      ExchangeActionId: DActionId;
      /**
       * 投げる
       */
      ThrowActionId: DActionId;
      /**
       * 放り投げる
       */
      FlungActionId: DActionId;
      /**
       * 撃つ
       *
       * 矢束の数を減らすなど、単なる「投げる」とは異なるので分ける必要がある。
       * シレン2だと、アメンジャはスタックされた矢をまとめて投げてくる。
       *
       * Projectile を作る必要があるが、そうしないと reactor は存在しないので、
       * 矢Entity のインスタンス化は actor 側で行う。
       *
       * インスタンス化された Entity は actor と同じブロックに配置され、例えば矢であればそこから 10回 移動する。
       */
      ShootActionId: DActionId;
      /**
       * 衝突しようとしている・衝突されようとしている・衝突する・衝突された
       *
       * 投げられたり撃たれた Projectile が、他の Entity にヒットしたとき。
       *
       * 草を投げ当てた時の効果発動とは分けている点に注意。
       * 例えば投げ与えられた装備品を装備する仲間キャラなどは、この Command をハンドリングする。
       * はね返しの盾なども同様。
       */
      /**
       * 効果を与えようとしている・効果を与えられようとしている・効果を与える・効果を与えられた
       *
       * 投げ当てた草等が実際に効果を発動するとき。
       * 命中判定などは済んだ後で発行されるコマンドなので、これをそのまま攻撃とみなして使うことはできないので注意。
       *
       * 投げ当てた時と飲んだ時で効果が違うアイテムがあるので、その場合は EffectContext も参照する必要がある。
       */
      AffectActionId: DActionId;
      /**
       * 転がす
       *
       * いまのところ大砲の弾専用。
       * 大砲の弾は投げることもできるし (ウルロイド)、撃ったり (オヤジ戦車) 吹き飛ばすこともできる (杖)。転がっている間はワナが起動する。
       * これらとは原因アクションを区別するために、「転がす」が必要となる。
       */
      RollActionId: DActionId;
      /**
       * 落ちようとしている・落ちられようとしている・落ちる・落ちられた
       *
       * actor: Projectile(矢) 等
       * reactor: Tile, Trap 等
       *
       * Projectile が地面に落ちるときや、モンスターに投げられたときなど。
       * 落下先の同一レイヤーに Entity がある場合は周囲に落ちる。落ちるところが無ければ消滅する。
       *
       * Trap に落下することもある。地雷や落とし穴であれば、周囲に落下はせず、ダメージを受けたり消滅する。
       * Trap に落下したときの Sequel 順序は 落下 > 起動音&発動中表示 > アイテム床へ落下 > ワナ効果発動
       *
       */
      FallActionId: DActionId;
      /**
       * 落ちようとしている・落ちられようとしている・落ちる・落ちられた
       *
       * actor: Projectile(矢) 等
       * reactor: Tile 等
       *
       * [Fall] と比べてこちらは Unit がアイテムをドロップした時の Action。
       * また、[Fall] で罠の上に落ちたアイテムが、さらに周囲の空いている Block へ落ちるときにも使用する。
       * 周辺がアイテムだらけでスペースがない場合は消滅する。
       */
      DropActionId: DActionId;
      /** 踏む */
      trample: DActionId;
      /** 捨てる */
      TrashActionId: DActionId;
      /** 進む () */
      ForwardFloorActionId: DActionId;
      /** 降りる */
      /** 登る */
      /** 戻る */
      BackwardFloorActionId: DActionId;
      /**
       * 装備しようとしている・装備されようとしている・装備する・装備された
       *
       */
      EquipActionId: DActionId;
      /**
       * (装備を)外そうとしている・外されようとしている・外す・外された
       *
       * 呪いのため外せないチェックは reactor(武器Entity) 側で行う。
       */
      EquipOffActionId: DActionId;
      /** 食べる */
      EatActionId: DActionId;
      /** 飲む (UI 表示名区別のため、[食べる] とは別定義。効果は同一でよさそう) */
      TakeActionId: DActionId;
      /** かじる (UI 表示名区別のため、[食べる] とは別定義。効果は同一でよさそう) */
      BiteActionId: DActionId;
      /** [43] 読む */
      ReadActionId: DActionId;
      /** [44] 振る */
      WaveActionId: DActionId;
      /** [45] 押す */
      PushActionId: DActionId;
      /** [46] 入れる */
      PutInActionId: DActionId;
      /** [47] 出す ※「みる（のぞく）」は Window 遷移のための UI アクションなので、CommandType ではない */
      PickOutActionId: DActionId;
      /**
       * 識別する
       *
       * 巻物や草を使ったとき、手封じの壺を使ったとき、拾ったときなど、状況に応じて識別が発生するタイミングは多くあるため、
       * 必要な時に識別できるように Command 化しておく。
       */
      IdentifyActionId: DActionId;
      /**
       * アイテムを渡す
       */
      talk: DActionId;
      collide: DActionId;
      dialogResult: DActionId;
      stumble: DActionId;
      dead: DActionId;
      performSkill: DActionId;
      AttackActionId: DActionId;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/predefineds/DBasicCommands' {
  import { DCommandId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  export interface DBasicCommands {
      testPickOutItem: DCommandId;
      /**
       * 指定したアイテムを保持できるかどうか（インベントリに格納可能か）をチェックする。
       */
      testPutInItem: DCommandId;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/predefineds/DBasicEntityKinds' {
  import { DEntityCategoryId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  export interface BasicEntityKinds {
      actor: DEntityCategoryId;
      WeaponKindId: DEntityCategoryId;
      ShieldKindId: DEntityCategoryId;
      armor: DEntityCategoryId;
      ArrowKindId: DEntityCategoryId;
      BraceletKindId: DEntityCategoryId;
      FoodKindId: DEntityCategoryId;
      grass: DEntityCategoryId;
      ScrollKindId: DEntityCategoryId;
      WandKindId: DEntityCategoryId;
      PotKindId: DEntityCategoryId;
      DiscountTicketKindId: DEntityCategoryId;
      BuildingMaterialKindId: DEntityCategoryId;
      TrapKindId: DEntityCategoryId;
      FigurineKindId: DEntityCategoryId;
      MonsterKindId: DEntityCategoryId;
      entryPoint: DEntityCategoryId;
      exitPoint: DEntityCategoryId;
      Ornament: DEntityCategoryId;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/predefineds/DBasicEvents' {
  import { LEntity } from "ts/mr/lively/LEntity";
  import { DSkillId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  export type DEventId = number;
  export interface RoomEventArgs {
      entity: LEntity;
      newRoomId: number;
      oldRoomId: number;
  }
  export interface WalkEventArgs {
      walker: LEntity;
      targetX: number;
      targetY: number;
  }
  export interface PutEventArgs {
      actor: LEntity;
  }
  export interface SkillEmittedArgs {
      performer: LEntity;
      targets: LEntity[];
      skillId: DSkillId;
  }
  export interface ItemRemovedFromInventoryArgs {
      item: LEntity;
  }
  export interface DBasicEvents {
      /** 何らかの Entity が部屋に侵入した */
      roomEnterd: DEventId;
      roomLeaved: DEventId;
      preWalk: DEventId;
      walked: DEventId;
      prePut: DEventId;
      effectReacted: DEventId;
      /**
       * スキル発動後。スキル自体の発動失敗 (MP切れ等) では発生しない。
       * 発動した場合はターゲットの有無・命中有無にかかわらず、このイベントが発生する。
       */
      skillEmitted: DEventId;
      itemRemovedFromInventory: DEventId;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/predefineds/DBasicFactions' {
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/data/predefineds/DBasicItems' {
  import { DItemDataId } from "MysteryRogueSystem/ts/mr/data/DItem";
  export interface BasicItems {
      /** ダンジョン突入時に自動的に追加される食糧アイテム */
      autoSupplyFood: DItemDataId;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/predefineds/DBasicItemShops' {
  import { DItemShopTypeId } from "MysteryRogueSystem/ts/mr/data/DItemShop";
  export interface DBasicItemShops {
      fixed: DItemShopTypeId;
      normal: DItemShopTypeId;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/predefineds/DBasicMonsterHouses' {
  import { DMonsterHouseTypeId } from "MysteryRogueSystem/ts/mr/data/DMonsterHouse";
  export interface DBasicMonsterHouses {
      fixed: DMonsterHouseTypeId;
      normal: DMonsterHouseTypeId;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/predefineds/DBasicParameters' {
  import { DParameterId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DSParamId, DXParamId } from "MysteryRogueSystem/ts/mr/data/DParameter";
  export interface DBasicParameters {
      hp: DParameterId;
      mp: DParameterId;
      atk: DParameterId;
      def: DParameterId;
      mat: DParameterId;
      mdf: DParameterId;
      agi: DParameterId;
      luk: DParameterId;
      tp: DParameterId;
      fp: DParameterId;
      pow: DParameterId;
      upgradeValue: DParameterId;
      remaining: DParameterId;
      capacity: DParameterId;
      gold: DParameterId;
      /**
       * レベル
       *
       * Level は IdealPlus で変動させる。IdealBase, Damage は常に 0 でなければならない。
       * Level にはバフを適用できる。例えば「一定ターンの間、レベルが半分になる」効果を実装できる。
       * しかしこのとき、次のレベルに必要な Exp を計算する際のレベル値を ActualValue から取得してしまうと、半減したレベルで計算してしまい、
       * 現在の Exp と次のレベルに必要な Exp の矛盾が発生してしまう。
       * このためバフ適用前の値である IdealValue からレベルを取得する必要がある。
       *
       * Parameter としては制限の多いものとなるが、 Parameter 扱いしておくことで増減やダメージ計算式のオペランドとして利用する際に
       * レベル専用の処理が不要となるため、値は汎用的に利用できるようになる。
       */
      level: DParameterId;
      /**
       * 経験値
       *
       * Exp は ActualValue で変動させる。IdelBase, IdealPlus は常に 0 でなければならない。
       * Param 扱いするのは、経験値を増加させるアイテムの実装を容易にするため。
       * 例えば「経験値を 500 与える」効果は、HP 等と同じように回復効果として設定できるようになり、 Exp 専用の処理は不要となる。
       */
      exp: DParameterId;
  }
  export interface DBasicXParams {
      hit: DXParamId;
      eva: DXParamId;
      cri: DXParamId;
      cev: DXParamId;
      mev: DXParamId;
      mrf: DXParamId;
      cnt: DXParamId;
      hrg: DXParamId;
      mrg: DXParamId;
      trg: DXParamId;
  }
  export interface DBasicSParams {
      tgr: DSParamId;
      grd: DSParamId;
      rec: DSParamId;
      pha: DSParamId;
      mcr: DSParamId;
      tcr: DSParamId;
      pdr: DSParamId;
      mdr: DSParamId;
      fdr: DSParamId;
      exr: DSParamId;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/predefineds/DBasicPrefabs' {
  import { DPrefabId } from "MysteryRogueSystem/ts/mr/data/DPrefab";
  export interface DBasicPrefabs {
      illusionActor: DPrefabId;
      illusionItem: DPrefabId;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/predefineds/DBasicProperties' {
  export interface EntityProperty {
      id: number;
      defaultValue: any;
  }
  export interface EntityProperties {
      /**
       * DEquipmentPartId[]
       */
      equipmentSlots: number;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/predefineds/DBasicSequels' {
  import { DSequelId } from "MysteryRogueSystem/ts/mr/data/DSequel";
  export interface BasicSequels {
      idle: number;
      /** 移動 */
      MoveSequel: number;
      /** 吹き飛ばされ移動 */
      blowMoveSequel: number;
      dropSequel: number;
      attack: number;
      /**
       * 倒されたとき
       *
       * Sequel はあくまで演出が目的なので、仮に CollapseSequel の発行を忘れたときでも
       * 演出が表示されないだけで Entity は消される等処理される。
       */
      CollapseSequel: number;
      /** デフォルトの行動制限状態 */
      commonStopped: number;
      /** 睡眠状態 (浅い眠り、特殊な浅い眠り、睡眠、バクスイ) */
      asleep: number;
      escape: DSequelId;
      earthquake2: DSequelId;
      useItem: DSequelId;
      explosion: DSequelId;
      down: DSequelId;
      warp: DSequelId;
      stumble: DSequelId;
      jump: DSequelId;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/predefineds/DBasicStates' {
  import { DStateId } from "MysteryRogueSystem/ts/mr/data/DState";
  /**
   * REシステムとして特定のタイミングで必要となる State を列挙する。
   */
  export interface DBasicStates {
      dead: DStateId;
      /** モンスター出現時に追加される仮眠ステータス */
      nap: DStateId;
      trapPerformed: DStateId;
      monsterHouseSleepStateId: DStateId;
  }

}
declare module 'MysteryRogueSystem/ts/mr/data/predefineds/DBasicTraits' {
  import { DTraitId } from "MysteryRogueSystem/ts/mr/data/DTraits";
  export interface DBasicTraits {
      TRAIT_ELEMENT_RATE: DTraitId;
      TRAIT_DEBUFF_RATE: DTraitId;
      TRAIT_STATE_RATE: DTraitId;
      TRAIT_STATE_RESIST: DTraitId;
      /**
       * Game_BattlerBase.TRAIT_PARAM
       * dataId: RMMZ ParameterId
       * value:
       */
      TRAIT_PARAM: DTraitId;
      TRAIT_XPARAM: DTraitId;
      TRAIT_SPARAM: DTraitId;
      TRAIT_ATTACK_ELEMENT: DTraitId;
      TRAIT_ATTACK_STATE: DTraitId;
      TRAIT_ATTACK_SPEED: DTraitId;
      TRAIT_ATTACK_TIMES: DTraitId;
      TRAIT_ATTACK_SKILL: DTraitId;
      TRAIT_STYPE_ADD: DTraitId;
      TRAIT_STYPE_SEAL: DTraitId;
      TRAIT_SKILL_ADD: DTraitId;
      TRAIT_SKILL_SEAL: DTraitId;
      TRAIT_EQUIP_WTYPE: DTraitId;
      TRAIT_EQUIP_ATYPE: DTraitId;
      TRAIT_EQUIP_LOCK: DTraitId;
      TRAIT_EQUIP_SEAL: DTraitId;
      TRAIT_SLOT_TYPE: DTraitId;
      TRAIT_ACTION_PLUS: DTraitId;
      TRAIT_SPECIAL_FLAG: DTraitId;
      TRAIT_COLLAPSE_TYPE: DTraitId;
      TRAIT_PARTY_ABILITY: DTraitId;
      _separator: DTraitId;
      /**
       * 直接攻撃を必中にする。（命中率・回避率にかかわらず）
       */
      CertainDirectAttack: DTraitId;
      CertainIndirectAttack: DTraitId;
      /** 物理的な関節攻撃を完全回避する。 */
      DodgePhysicalIndirectAttack: DTraitId;
      /** 物理的な間接攻撃が全く当たらなくなる。 */
      AwfulPhysicalIndirectAttack: DTraitId;
      /** 地獄耳 */
      UnitVisitor: DTraitId;
      /** 何らかのアクションを受けたらステート解除。(仮眠や金縛りの解除で使う) */
      StateRemoveByEffect: DTraitId;
      Stackable: DTraitId;
      /**
       * アイテム種別ごとの "使うとき" の練度。
       * 食べる・投げる・読む等。攻撃でも有効。
       *
       * dataId: DEntityKindId
       * value: 練度。1.0 で等倍
       */
      EffectProficiency: DTraitId;
      /**
       * アイテム種別ごとの "装備したとき" の練度。
       *
       *
       * dataId: DEntityKindId
       * value: 練度。1.0 で等倍
       */
      EquipmentProficiency: DTraitId;
      /**
       * Activity を禁止する。
       *
       * dataId: DActionId
       */
      SealActivity: DTraitId;
      /**
       * 特殊能力封印
       */
      SealSpecialAbility: DTraitId;
      Invisible: DTraitId;
      ForceVisible: DTraitId;
      ItemDropRate: DTraitId;
      /**
       * Fixed damage.
       * - dataId: DParamId
       * - value: DamageValue
       */
      FixedDamage: DTraitId;
      /** 必ず罠にかかる */
      DrawInTrap: DTraitId;
      /** 浅い眠りを必ず起こす。 */
      AwakeStep: DTraitId;
      /** 浅い眠りを起こさない。 */
      SilentStep: DTraitId;
      /**
       * 行動後に自動発動する効果
       * dataId: DSkillId
       * value:  発生率 (0.0~1.0)
       */
      SuddenSkillEffect: DTraitId;
      /**
       * サバイバルパラメータ自動減少率
       * dataId: DParamId
       * value:  率 (double)
       */
      SurvivalParamLossRate: DTraitId;
      /**
       * ダメージによるパラメータ減少率
       * dataId: DParamId
       * value:  率 (double)
       */
      ParamDamageRate: DTraitId;
      /**
       * スキル自体の無効化
       * dataId: SkillId
       */
      SkillGuard: DTraitId;
      /**
       * スキル自体の無効化
       * dataId: SkillId
       */
      /**
       * 罠にかからなくなる。浮遊とは意味が違うので注意。
       */
      DisableTrap: DTraitId;
      /**
       * 指定属性の回復効果に対する倍率
       */
      /**
       * 指定属性の回復効果に対する倍率
       * dataId: ElementId
       * value: 率 (1.0 = 100%)
       *
       * "回復" のみに適用される点に注意。
       * ダメージか回復か問わずに率を適用するという案もあり、実際そのようなプラグインもあるが、
       * 属性に対してはそもそも世界観のデザインと密接にかかわるところであり、RMMZ 標準では力不足であると言われている。
       *
       * でも "火属性の回復魔法" を使った相手が "火属性無効" だったときに回復量 0 はちょっとあんまりだろう。
       * 発動側の "火属性バフ" みたいなのは乗せてほしい。
       * しかしアンデッドへの回復効果をダメージとしたいとき、例えば "光属性の回復魔法" は弱点としたいことがある。
       * つまり耐性を考慮するのは、ダメージ率適用後、最終的に回復かダメージかが決まった後となる。
       *
       * で MR としてアンデッド回復をどう設定するべきかというと、
       * [ElementedRecoverRate, 無属性, -1.0]
       * で Trait を作る。
       *
       * ちなみに属性を問わない回復率は sparam の rec で指定できる。
       */
      ElementedRecoveryRate: DTraitId;
      /**
       * 種族に対するダメージ倍率。攻撃側に付く Trait.
       * dataId: RaceId
       * value: 率 (1.0 = 100%)
       */
      RaceRate: DTraitId;
      PhysicalProjectileReflector: DTraitId;
      /** 貫通 (このアイテムが投げられたときは貫通になる。銀の矢) */
      PenetrationItem: DTraitId;
      /** 貫通 (この人が投げるアイテムはすべて貫通になる。遠投の腕輪) */
      PenetrationThrower: DTraitId;
      /** 可能であれば (通常攻撃ではなく) スキルを使用する。 */
      UseSkillForced: DTraitId;
      /**
       * 指定の属性攻撃を受けた時に即死するか (戦闘不能ステートを付加するか)
       * dataId: DElementId
       * value: 付加する DStateId
       */
      DeathVulnerableElement: DTraitId;
  }

}
declare module 'MysteryRogueSystem/ts/mr/Diag' {
  export class Diag {
      static error(message: string): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/floorgen/data/FMapBlock' {
  import { DItemShopTypeId } from "ts/mr/data/DItemShop";
  import { DMonsterHouseTypeId } from "ts/mr/data/DMonsterHouse";
  import { DBlockVisualPartIndex } from "ts/mr/data/DTemplateMap";
  import { LTileShape } from "ts/mr/lively/LBlock";
  import { FBlockComponent, FRoomId, FSectorId } from "MysteryRogueSystem/ts/mr/floorgen/FMapData";
  export class FMapBlock {
      private _mx;
      private _my;
      private _tileShape;
      private _blockComponent;
      private _sectorId;
      private _roomId;
      private _doorway;
      private _continuation;
      private _shapeVisualPartIndex;
      private _decorationVisualPartIndex;
      private _fixedMapMonsterHouseTypeId;
      private _fixedMapItemShopTypeId;
      constructor(mx: number, my: number);
      get mx(): number;
      get my(): number;
      setTileShape(value: LTileShape): void;
      tileShape(): LTileShape;
      setComponent(value: FBlockComponent): void;
      component(): FBlockComponent;
      setFixedMapMonsterHouseTypeId(value: DMonsterHouseTypeId): void;
      fixedMapMonsterHouseTypeId(): DMonsterHouseTypeId;
      setFixedMapItemShopTypeId(value: DItemShopTypeId): void;
      fixedMapItemShopTypeId(): DItemShopTypeId;
      setSectorId(value: FSectorId): void;
      sectorId(): FSectorId;
      setRoomId(value: FRoomId): void;
      isRoom(): boolean;
      /**
       * 本質的なものとして通行可能であるか。
       * 例えば隠し通路 (通常攻撃で通路が姿を現す) の場合、tileKind は Wall であるが、Component は Passageway となる。
       */
      isPassagableComponent(): boolean;
      roomId(): FRoomId;
      setDoorway(value: boolean): void;
      isDoorway(): boolean;
      setContinuation(value: boolean): void;
      isContinuation(): boolean;
      get shapeVisualPartIndex(): DBlockVisualPartIndex;
      setShapeVisualPartIndex(value: DBlockVisualPartIndex): void;
      get decorationVisualPartIndex(): DBlockVisualPartIndex;
      setDecorationVisualPartIndex(value: DBlockVisualPartIndex): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/floorgen/data/FSector' {
  import { FAxis, FConnectionId, FDirection, FEdgePin, FMap, FRoom, FSectorEdge, FSectorId } from "MysteryRogueSystem/ts/mr/floorgen/FMapData";
  export class FSector {
      private _map;
      private _id;
      private _mx1;
      private _my1;
      private _mx2;
      private _my2;
      private _px;
      private _py;
      private _edges;
      private _roomShapeType;
      private _structureType;
      private _room;
      constructor(map: FMap, id: FSectorId);
      setRect(mx: number, my: number, mw: number, mh: number): void;
      /** ID. (0 is Dummy) */
      id(): FSectorId;
      /** 有効範囲内左上座標 (Map 座標系) */
      get mx1(): number;
      /** 有効範囲内左上座標 (Map 座標系) */
      get my1(): number;
      /** 有効範囲内右下座標 (Map 座標系) */
      get mx2(): number;
      /** 有効範囲内右下座標 (Map 座標系) */
      get my2(): number;
      px(): number;
      py(): number;
      get pivotMX(): number;
      get pivotMY(): number;
      width(): number;
      height(): number;
      setPivot(px: number, py: number): void;
      edge(d: FDirection): FSectorEdge;
      edges(): readonly FSectorEdge[];
      get roomShapeType(): string;
      set roomShapeType(value: string);
      get structureType(): string;
      set structureType(value: string);
      room(): FRoom | undefined;
      setRoom(room: FRoom | undefined): void;
      isRoomBesideX(mx: number): boolean;
      isRoomBesideY(my: number): boolean;
      GlobalToLocalX(gx: number): number;
      GlobalToLocalY(gy: number): number;
      contains(mx: number, my: number): boolean;
      hasAnyConnection(): boolean;
      getRoomCandidateRelativeRect(): [number, number, number, number];
  }
  export class FSectorAdjacency {
      private _edge1;
      private _edge2;
      constructor(edge1: FSectorEdge, edge2: FSectorEdge);
      edge1(): FSectorEdge;
      edge2(): FSectorEdge;
      hasPair(e1: FSectorEdge, e2: FSectorEdge): boolean;
      otherSide(edge: FSectorEdge): FSectorEdge;
      otherSideBySector(sector: FSector): FSectorEdge;
  }
  export class FSectorConnection {
      private _id;
      private _edge1;
      private _edge2;
      private _pin1;
      private _pin2;
      constructor(id: FConnectionId, edge1: FSectorEdge, edge2: FSectorEdge);
      id(): FConnectionId;
      edge1(): FSectorEdge;
      edge2(): FSectorEdge;
      pin1(): FEdgePin | undefined;
      pin2(): FEdgePin | undefined;
      alignedAxis(): FAxis;
      setConnectedPins(pin1: FEdgePin, pin2: FEdgePin): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/floorgen/FGenerator' {
  import { FMap } from "MysteryRogueSystem/ts/mr/floorgen/FMapData";
  /**
   * @deprecated
   */
  export class FMiddleSingleRoomGenerator {
      generate(map: FMap): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/floorgen/FGenericRandomMapGenerator' {
  import { DTerrainSetting } from "MysteryRogueSystem/ts/mr/data/DTerrainPreset";
  import { LRandom } from "MysteryRogueSystem/ts/mr/lively/LRandom";
  import { FMap } from "MysteryRogueSystem/ts/mr/floorgen/FMapData";
  /**
   * 床・壁・通路・区画情報 などマップの基本情報を生成するモジュール。
   *
   * 次のような要素はこのパスでは生成しない。
   * - アイテム
   * - 罠
   * - 階段
   * - 水路
   * - 壊せない壁
   * - 装飾
   * ...
   *
   * FloorGenerator は一度の map building で複数使われることがある。
   * 特に水路を生成する場合は「部屋を生成せず通路のみとする」モードで FloorGenerator を使い、
   * そうではないモードで生成したマップと合成する。
   *
   * このように各種障害や装飾の生成ソースとしても利用するため、データは GameMap とは独立する。
   *
   * https://github.com/marukrap/RoguelikeDevResources
   * http://www.roguebasin.com/index.php?title=Dungeon-Building_Algorithm
   */
  export class FGenericRandomMapGenerator {
      private _map;
      private _setting;
      private _shape;
      constructor(map: FMap, setting: DTerrainSetting);
      get random(): LRandom;
      generate(): void;
      private reportError;
      private makeSectors;
      private makeSectorAdjacency;
      private makeSectorConnections;
      private makeRoomShapeDefinitions;
      private makeStructureDefinitions;
      private makeRooms;
      private makePivots;
      private makeEdgePins;
      private makePinConnections;
      private makePassageWay;
      /**
       *
       * @param startX 始点座標 (PrimaryWai の端)
       * @param startY 始点座標 (PrimaryWai の端)
       * @param targetSector 終点となる Pivot を持つ Sector
       * @param relationship
       */
      private plotSecondaryWay;
      private makeBlocks;
  }

}
declare module 'MysteryRogueSystem/ts/mr/floorgen/FMapBuilder' {
  import { FMapBuildPass } from "MysteryRogueSystem/ts/mr/floorgen/passes/FMapBuildPass";
  import { FMap } from "MysteryRogueSystem/ts/mr/floorgen/FMapData";
  export class FMapBuilder {
      buildForRandomMap(data: FMap): void;
      buildForFixedMap(data: FMap): void;
  }
  export class FMapBuildPass_MakeRoomId extends FMapBuildPass {
      execute(map: FMap): void;
  }
  export class FMapBuildPass_ResolveRoomShapes extends FMapBuildPass {
      execute(map: FMap): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/floorgen/FMapData' {
  import { LFloorId } from "ts/mr/lively/LFloorId";
  import { LRandom } from "ts/mr/lively/LRandom";
  import { FStructure } from "MysteryRogueSystem/ts/mr/floorgen/FStructure";
  import { FSector, FSectorAdjacency, FSectorConnection } from "MysteryRogueSystem/ts/mr/floorgen/data/FSector";
  import { FMapBlock } from "MysteryRogueSystem/ts/mr/floorgen/data/FMapBlock";
  import { DTemplateMapId } from "MysteryRogueSystem/ts/mr/data/DTemplateMap";
  export enum FDirection {
      T = 0,
      B = 1,
      L = 2,
      R = 3
  }
  export enum FAxis {
      H = 0,
      V = 1
  }
  export type FSectorId = number;
  export type FRoomId = number;
  export type FConnectionId = number;
  export enum FBlockComponent {
      None = 0,
      Room = 1,
      Passageway = 2
  }
  export class FEdgePin {
      private _edge;
      private _pos;
      constructor(edge: FSectorEdge, pos: number);
      edge(): FSectorEdge;
      pos(): number;
      mx(): number;
      my(): number;
  }
  export class FSectorEdge {
      private _sector;
      private _direction;
      private _adjacencies;
      private _connections;
      private _pins;
      constructor(sector: FSector, dir: FDirection);
      sector(): FSector;
      direction(): FDirection;
      resetLength(length: number): void;
      addAdjacency(adjacency: FSectorAdjacency): void;
      hasAdjacency(): boolean;
      adjacencies(): FSectorAdjacency[];
      addConnection(connection: FSectorConnection): void;
      hasConnection(): boolean;
      hasConnectionFully(): boolean;
      addPin(pos: number): void;
      pins(): readonly FEdgePin[];
      isValidPinPos(pos: number): boolean;
  }
  export class FRoom {
      private _map;
      private _id;
      private _sector;
      private _mx1;
      private _my1;
      private _mx2;
      private _my2;
      private _structures;
      poorVisibility: boolean;
      constructor(map: FMap, id: FRoomId, sector: FSector);
      id(): FRoomId;
      sector(): FSector;
      get mx1(): number;
      get my1(): number;
      get mx2(): number;
      get my2(): number;
      get width(): number;
      get height(): number;
      tryInfrateRect(mx: number, my: number): void;
      forEachBlocks(func: (block: FMapBlock) => void): void;
      setRect(mx: number, my: number, mw: number, mh: number): void;
      blocks(): FMapBlock[];
      addStructureRef(value: FStructure): void;
      structures(): readonly FStructure[];
  }
  export class FEntryPont {
      private _mx;
      private _my;
      constructor(mx: number, my: number);
      mx(): number;
      my(): number;
  }
  export class FExitPont {
      private _mx;
      private _my;
      constructor(mx: number, my: number);
      mx(): number;
      my(): number;
  }
  export class FMap {
      private _floorId;
      private _randSeed;
      private _rand;
      private _innerWidth;
      private _innerHeight;
      private _fullWidth;
      private _fullHeight;
      private _paddingX;
      private _paddingY;
      private _blocks;
      private _innerBlocks;
      private _sectors;
      private _sectorAdjacencies;
      private _sectorConnections;
      private _rooms;
      private _structures;
      private _entryPoint;
      private _exitPont;
      private _templateId;
      constructor(floorId: LFloorId, randSeed: number);
      resetFromInnerSize(innerWidth: number, innerHeight: number, paddingX: number, paddingY: number): void;
      resetFromFullSize(fullWidth: number, fullHeight: number, paddingX: number, paddingY: number): void;
      floorId(): LFloorId;
      random(): LRandom;
      /** Inner の左上 X 座標 */
      get ox(): number;
      /** Inner の左上 Y 座標 */
      get oy(): number;
      get fullWidth(): number;
      get fullHeight(): number;
      get innerWidth(): number;
      get innerHeight(): number;
      blocks(): readonly FMapBlock[];
      get innerBlocks(): readonly FMapBlock[];
      innerBlock(x: number, y: number): FMapBlock;
      blockTry(x: number, y: number): FMapBlock | undefined;
      block(x: number, y: number): FMapBlock;
      sectors(): readonly FSector[];
      newSector(): FSector;
      attemptNewAdjacency(s1: FSector, s1Dir: FDirection, s2: FSector, s2Dir: FDirection): FSectorAdjacency;
      connectSectors(edge1: FSectorEdge, edge2: FSectorEdge): FSectorConnection;
      adjacencies(): readonly FSectorAdjacency[];
      connections(): readonly FSectorConnection[];
      room(roomId: FRoomId): FRoom;
      rooms_raw(): readonly FRoom[];
      rooms(): readonly FRoom[];
      newRoom(sector: FSector): FRoom;
      structures(): readonly FStructure[];
      addStructure(structure: FStructure): void;
      isValid(x: number, y: number): boolean;
      setEntryPont(value: FEntryPont): void;
      entryPoint(): FEntryPont | undefined;
      setExitPont(value: FExitPont): void;
      exitPont(): FExitPont | undefined;
      rmmzFixedMapData(): IDataMap;
      get templateId(): DTemplateMapId;
      print(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/floorgen/FSectorConnectionBuilder' {
  import { DTerrainShape } from "MysteryRogueSystem/ts/mr/data/DTerrainPreset";
  import { LRandom } from "MysteryRogueSystem/ts/mr/lively/LRandom";
  import { FMap } from "MysteryRogueSystem/ts/mr/floorgen/FMapData";
  export class FSectorConnectionBuilder {
      static connect(map: FMap, rand: LRandom, shape: DTerrainShape): void;
      private static connectDefault;
      private static sector;
      private static connectC;
      private static connectH;
  }

}
declare module 'MysteryRogueSystem/ts/mr/floorgen/FStructure' {
  import { DItemShopTypeId } from "ts/mr/data/DItemShop";
  import { DMonsterHouseTypeId } from "ts/mr/data/DMonsterHouse";
  import { FRoomId } from "MysteryRogueSystem/ts/mr/floorgen/FMapData";
  export class FStructure {
  }
  export class FMonsterHouseStructure extends FStructure {
      private _roomId;
      private _monsterHouseTypeId;
      constructor(roomId: FRoomId, monsterHouseId: DMonsterHouseTypeId);
      roomId(): FRoomId;
      setMonsterHouseTypeId(value: DMonsterHouseTypeId): void;
      monsterHouseTypeId(): DMonsterHouseTypeId;
  }
  export class FItemShopStructure extends FStructure {
      private _roomId;
      private _itemShopTypeId;
      constructor(roomId: FRoomId, itemShopTypeId: DItemShopTypeId);
      roomId(): FRoomId;
      setItemShopTypeId(value: DItemShopTypeId): void;
      itemShopTypeId(): DItemShopTypeId;
  }

}
declare module 'MysteryRogueSystem/ts/mr/floorgen/passes/FBackgroundWaterPass' {
  import { FMapBuildPass } from "MysteryRogueSystem/ts/mr/floorgen/passes/FMapBuildPass";
  import { FMap } from "MysteryRogueSystem/ts/mr/floorgen/FMapData";
  /**
   */
  export class FBackgroundWaterPass extends FMapBuildPass {
      execute(map: FMap): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/floorgen/passes/FDecorationPass' {
  import { FMapBuildPass } from "MysteryRogueSystem/ts/mr/floorgen/passes/FMapBuildPass";
  import { FMap } from "MysteryRogueSystem/ts/mr/floorgen/FMapData";
  import { DTemplateMap } from "ts/mr/data/DTemplateMap";
  import { FMapBlock } from "MysteryRogueSystem/ts/mr/floorgen/data/FMapBlock";
  /**
   * ランダムマップの装飾
   */
  export class FDecorationPass extends FMapBuildPass {
      execute(map: FMap): void;
      makeFloorDecoration(map: FMap, template: DTemplateMap): void;
      makeWallDecoration(map: FMap, template: DTemplateMap): void;
      isAroundWalls(map: FMap, block: FMapBlock): boolean;
  }

}
declare module 'MysteryRogueSystem/ts/mr/floorgen/passes/FEntryPointAndExitPointPass' {
  import { FMapBuildPass } from "MysteryRogueSystem/ts/mr/floorgen/passes/FMapBuildPass";
  import { FMap } from "MysteryRogueSystem/ts/mr/floorgen/FMapData";
  /**
   */
  export class FEntryPointAndExitPointPass extends FMapBuildPass {
      execute(map: FMap): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/floorgen/passes/FMakeItemShopPass' {
  import { FMap } from "MysteryRogueSystem/ts/mr/floorgen/FMapData";
  import { FMapBuildPass } from "MysteryRogueSystem/ts/mr/floorgen/passes/FMapBuildPass";
  export class FMakeItemShopPass extends FMapBuildPass {
      execute(map: FMap): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/floorgen/passes/FMakeMonsterHousePass' {
  import { FMap } from "MysteryRogueSystem/ts/mr/floorgen/FMapData";
  import { FMapBuildPass } from "MysteryRogueSystem/ts/mr/floorgen/passes/FMapBuildPass";
  /**
   * @deprecated
   */
  export class FMakeMonsterHouseForFixedMapPass extends FMapBuildPass {
      execute(map: FMap): void;
      private selectPattern;
  }
  export class FMakeMonsterHouseForRandomMapPass extends FMapBuildPass {
      execute(map: FMap): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/floorgen/passes/FMakeTileKindPass' {
  import { FMap } from "MysteryRogueSystem/ts/mr/floorgen/FMapData";
  import { FMapBuildPass } from "MysteryRogueSystem/ts/mr/floorgen/passes/FMapBuildPass";
  /**
   */
  export class FMakeTileKindPass extends FMapBuildPass {
      execute(map: FMap): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/floorgen/passes/FMapBuildPass' {
  import { FMap } from "MysteryRogueSystem/ts/mr/floorgen/FMapData";
  export abstract class FMapBuildPass {
      abstract execute(map: FMap): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/floorgen/passes/FMarkContinuationPass' {
  import { FMapBuildPass } from "MysteryRogueSystem/ts/mr/floorgen/passes/FMapBuildPass";
  import { FMap } from "MysteryRogueSystem/ts/mr/floorgen/FMapData";
  /**
   * [ランダムマップ・固定マップ用]
   * - 出口の位置を決め、そこからたどることができる Block にマークを付けていく。
   * - AI用の通路目的 Block を決める。 http://shiren2424.blog.fc2.com/blog-entry-119.html
   *
   * プレイヤーの初期位置などはこのマークのある Block から選択することになる。
   *
   * 侵入不可能な地形が確定した後に実行するのが望ましい。
   */
  export class FMarkContinuationPass extends FMapBuildPass {
      execute(map: FMap): void;
      private selectSeekStartBlock;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/abilities/LAbility' {
  import { DAbilityId } from "ts/mr/data/DAbility";
  import { LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { LObject, LObjectId } from "MysteryRogueSystem/ts/mr/lively/LObject";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  export type LAbilityId = LObjectId;
  /**
   * Ability は Entity の各種行動や与・被Effect 時に追加の様々な効果を与えるもの。
   *
   * 振舞いは State と非常によく似ているが、Ability は合成印や新種道具の効果を表すものであり、
   * アイテムの詳細説明ウィンドウの効果欄に列挙されたりする。
   *
   *
   * [2021/2/20] Ability は Entity にはしないの？
   * ----------
   * State と同じだけど、いったんしない方向で行ってみる。
   * Entity にすればいろいろな応用が利きそうだけど現状はする・しないに対して明確な理由は出し切れない。
   * とりあえず YAGNI で。
   *
   * あと Entity としたとき、Behavior から ownerEntity をとるときにちょっと細工する必要があるのが不自然かも。
   *
   */
  export class LAbility extends LObject {
      private _abilityId;
      private _behabiorIds;
      constructor();
      clone(newOwner: LEntity): LAbility;
      id(): LAbilityId;
      setup(abilityId: DAbilityId): void;
      abilityId(): DAbilityId;
      private addBehavior;
      behabiors(): LBehavior[];
      iterateBehaviors(func: ((b: LBehavior) => void) | ((b: LBehavior) => boolean)): boolean;
      onAttached(self: LEntity): void;
      onDetached(self: LEntity): void;
      onRemoveChild(entity: LEntity): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/abilities/LEntityDivisionBehavior' {
  import { SCommandResponse } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { CommandArgs, LBehavior, onDirectAttackDamaged } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  /** @deprecated TODO: カウンターアクションとして、"分裂" スキルを発動するようにしたい */
  export class LEntityDivisionBehavior extends LBehavior {
      clone(newOwner: LEntity): LBehavior;
      [onDirectAttackDamaged](args: CommandArgs, cctx: SCommandContext): SCommandResponse;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/abilities/LGrabFootBehavior' {
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { DEventId } from "ts/mr/data/predefineds/DBasicEvents";
  import { LEventResult } from "MysteryRogueSystem/ts/mr/lively/LEventServer";
  /**
   * 足つかみ。
   *
   *
   */
  export class LGrabFootBehavior extends LBehavior {
      private _targetId;
      constructor();
      clone(newOwner: LEntity): LBehavior;
      onAttached(self: LEntity): void;
      onDetached(self: LEntity): void;
      onEvent(cctx: SCommandContext, eventId: DEventId, args: any): LEventResult;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/abilities/LKnockbackBehavior' {
  import { LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  export class LKnockbackBehavior extends LBehavior {
      clone(newOwner: LEntity): LBehavior;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/activities/LActivity' {
  import { DActionId, DSkillId } from "ts/mr/data/DCommon";
  import { LBlock } from "MysteryRogueSystem/ts/mr/lively/LBlock";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LActionTokenConsumeType } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  import { DSkill } from "ts/mr/data/DSkill";
  export interface LEntityIdData {
      index: number;
      key: number;
  }
  export interface LActivityData {
      actionId: DActionId;
      actor: LEntityIdData;
      subject: LEntityIdData;
      object: LEntityIdData;
      objects2: LEntityIdData[];
      skillId: DSkillId;
      direction: number;
      entityDirection: number;
      actionTokenConsumeType: LActionTokenConsumeType | undefined;
      fastForward: boolean;
      selectedAction: string;
  }
  /**
   * Unit の "行動"。
   *
   * 行動履歴として記録される。シリアライズされ、ファイルに保存される。
   *
   *
   *
   * Activity にするべきか迷ったとき
   * ----------
   * ### 未知の拡張機能により、行動がリジェクトされることを想定するか？
   */
  export class LActivity {
      private _actionId;
      private _actor;
      private _subject;
      private _object;
      private _objects2;
      private _skillId;
      private _effectDirection;
      private _entityDirection;
      private _actionTokenConsumeType;
      private _fastForward;
      private _selectedAction;
      constructor();
      setup(actionId: DActionId, actor: LEntity, object?: LEntity, dir?: number): this;
      actionId(): DActionId;
      get action(): DSkill;
      actor(): LEntity;
      subject(): LEntity;
      hasObject(): boolean;
      object(): LEntity;
      setObject(object: LEntity): void;
      objects2(): LEntity[];
      setObjects2(objects: LEntity[]): void;
      skillId(): DSkillId;
      withOtherSubject(subject: LEntity): this;
      withEffectDirection(d: number): this;
      effectDirection(): number;
      hasEffectDirection(): boolean;
      entityDirection(): number;
      withEntityDirection(dir: number): this;
      withConsumeAction(consumeType?: LActionTokenConsumeType | undefined): this;
      isConsumeAction(): boolean;
      consumeActionTokenType(): LActionTokenConsumeType | undefined;
      getConsumeActionTokenType(): LActionTokenConsumeType;
      withFastForward(): this;
      isFastForward(): boolean;
      selectedAction(): string;
      toData(): LActivityData;
      static makeFromData(data: LActivityData): LActivity;
      static make(actor: LEntity): LActivity;
      static makeDirectionChange(actor: LEntity, dir: number): LActivity;
      static makeMoveToAdjacent(actor: LEntity, dir: number): LActivity;
      static makeMoveToAdjacentBlock(actor: LEntity, block: LBlock): LActivity;
      static makePrimaryUse(subject: LEntity, object: LEntity): LActivity;
      static makePick(actor: LEntity): LActivity;
      static makePut(actor: LEntity, object: LEntity): LActivity;
      static makeThrow(actor: LEntity, object: LEntity): LActivity;
      static makeShooting(actor: LEntity, object: LEntity): LActivity;
      static makeFall(actor: LEntity): LActivity;
      static makeTrample(actor: LEntity): LActivity;
      static makeExchange(actor: LEntity, object: LEntity): LActivity;
      static makeEquip(actor: LEntity, object: LEntity): LActivity;
      static makeEquipOff(actor: LEntity, object: LEntity): LActivity;
      static makeEat(actor: LEntity, object: LEntity): LActivity;
      static makeWave(actor: LEntity, object: LEntity): LActivity;
      static makeRead(actor: LEntity, object: LEntity, targets?: LEntity[]): LActivity;
      static makePutIn(actor: LEntity, storage: LEntity, item: LEntity): LActivity;
      static makeTalk(actor: LEntity): LActivity;
      static makeCollide(subject: LEntity, target: LEntity): LActivity;
      static makePerformSkill(actor: LEntity, skillId: DSkillId, dirToFace?: number): LActivity;
      static makeDialogResult(actor: LEntity, target: LEntity, selectedAction: string): LActivity;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/ai/LActionDeterminer' {
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LCandidateSkillAction } from "ts/mr/utility/UAction";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LEntityId } from "MysteryRogueSystem/ts/mr/lively/LObject";
  export class LActionDeterminer {
      private _primaryTargetEntityId;
      private _requiredSkillAction;
      clone(): LActionDeterminer;
      protected setPrimaryTargetEntityId(entityId: LEntityId): void;
      protected setRequiredSkillAction(action: LCandidateSkillAction | undefined): void;
      decide(cctx: SCommandContext, self: LEntity): void;
      isMoveRequested(): boolean;
      isMajorActionRequested(): boolean;
      hasPrimaryTarget(): boolean;
      primaryTarget(): LEntity;
      perform(cctx: SCommandContext, self: LEntity): boolean;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/ai/LBlindAI' {
  import { SPhaseResult } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LCharacterAI } from "MysteryRogueSystem/ts/mr/lively/ai/LCharacterAI";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  export class LBlindAI extends LCharacterAI {
      private _candidateSkillActions;
      constructor();
      clone(): LCharacterAI;
      thinkMoving(cctx: SCommandContext, self: LEntity): SPhaseResult;
      thinkAction(cctx: SCommandContext, self: LEntity): SPhaseResult;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/ai/LCharacterAI' {
  import { SPhaseResult } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  /**
   * Run のマージにより 1Run 内に複数回行動する場合、まず thinkMoving() が
   * 複数回呼ばれ、そのあと Token が残っている分だけ thinkAction() が呼ばれる。
   */
  export abstract class LCharacterAI {
      abstract clone(): LCharacterAI;
      abstract thinkMoving(cctx: SCommandContext, self: LEntity): SPhaseResult;
      /**
       * メジャーアクション
       *
       * thinkMoving() で Handled を返しても、MajorActionToken が残っていれば呼び出されるので、
       * 移動だけしたいときはフラグを立てておき、thinkAction() では Pass を返すようにすること。
       */
      abstract thinkAction(cctx: SCommandContext, self: LEntity): SPhaseResult;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/ai/LConfusionAI' {
  import { SPhaseResult } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LCharacterAI } from "MysteryRogueSystem/ts/mr/lively/ai/LCharacterAI";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  export enum LConfusionAIRestriction {
      /** 攻撃しない */
      None = 0,
      /** 敵を攻撃 */
      AttcakToOpponent = 1,
      /** 誰かを攻撃 */
      AttackToOther = 2,
      /** 味方を攻撃 */
      AttcakToFriend = 3
  }
  export class LConfusionAI extends LCharacterAI {
      private _restriction;
      private _candidateSkillActions;
      constructor(restriction: LConfusionAIRestriction);
      clone(): LCharacterAI;
      thinkMoving(cctx: SCommandContext, self: LEntity): SPhaseResult;
      thinkAction(cctx: SCommandContext, self: LEntity): SPhaseResult;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/ai/LEscapeAI' {
  import { SPhaseResult } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LCharacterAI } from "MysteryRogueSystem/ts/mr/lively/ai/LCharacterAI";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  export class LEscapeAI extends LCharacterAI {
      private _moveDeterminer;
      constructor();
      clone(): LCharacterAI;
      private checkDeadInArea;
      thinkMoving(cctx: SCommandContext, self: LEntity): SPhaseResult;
      private decideTargetPosition;
      thinkAction(cctx: SCommandContext, self: LEntity): SPhaseResult;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/ai/LMoveDeterminer' {
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LBlock } from "MysteryRogueSystem/ts/mr/lively/LBlock";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  export enum LMovingMethod {
      ToTarget = 0,
      LHRule = 1
  }
  export interface LUpdateMovingTargetResult {
      method: LMovingMethod;
      passageway?: LBlock;
  }
  export class LMoveDeterminer {
      private _targetPositionX;
      private _targetPositionY;
      private _noActionTurnCount;
      _decired: LUpdateMovingTargetResult;
      clone(): LMoveDeterminer;
      setTargetPosition(x: number, y: number): void;
      decide(cctx: SCommandContext, self: LEntity): void;
      /**
       * 移動実行
       */
      perform(cctx: SCommandContext, self: LEntity): boolean;
      private performInternal;
      private canModeToTarget;
      private moveToTarget;
      private postMoveToAdjacent;
      hasDestination(): boolean;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/ai/LMovingTargetFinder' {
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  /**
   * LActionDeterminer で有効スキルが発生しなかったため移動処理を行う際に、移動先座標を決定するためのクラス。
   *
   * 移動先決定は様々なパターンがある。
   *
   * - 落ちているアイテムへ向かう
   * - 落ちているゴールドへ向かう
   * - アイテムまたはゴールドへ向かう
   * - 食べ物モンスターや土偶へ向かう
   * - 罠へ向かう (罠壊し)
   * - 階段へ向かう (ツッパリ)
   * - (HPが少なくなったら) 水路へ向かう
   *
   * 今後も多くの追加が予想される。
   * また Behavior 固有ではなく AI として共有されるものであるため、この検索処理を Behavior に実装するのは望ましくない。
   *
   * さらに AI のアーキテクチャはまだまだ手探り状態。
   * そのためできるだけ細かい粒度で機能を分割 (継承ではなく包含で) しておき、後々のリファクタリングに耐えやすいようにしておく。
   */
  export class LMovingTargetFinder {
      decide(self: LEntity): (number[] | undefined);
  }
  export class LMovingTargetFinder_Item {
      decide(self: LEntity): (number[] | undefined);
  }
  export class LMovingTargetFinder_Gold {
      decide(self: LEntity): (number[] | undefined);
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/ai/LRatedRandomAI' {
  import { SPhaseResult } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LCharacterAI } from "MysteryRogueSystem/ts/mr/lively/ai/LCharacterAI";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  export class LRatedRandomAI extends LCharacterAI {
      private _randomRate;
      private _rundomTurn;
      private _standardAI;
      private _randomAI;
      constructor();
      clone(): LCharacterAI;
      thinkMoving(cctx: SCommandContext, self: LEntity): SPhaseResult;
      thinkAction(cctx: SCommandContext, self: LEntity): SPhaseResult;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/ai/LSaunteringAIHelper' {
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  export class LSaunteringAIHelper {
      private _targetPositionX;
      private _targetPositionY;
      private _noActionTurnCount;
      clone(): LSaunteringAIHelper;
      setTargetPosition(mx: number, my: number): void;
      thinkMoving(self: LEntity, cctx: SCommandContext): boolean;
      thinkMovingCore(self: LEntity, cctx: SCommandContext): boolean;
      private hasDestination;
      private canModeToTarget;
      private moveToTarget;
      private postMoveToAdjacent;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/ai/LStandardAI' {
  import { SPhaseResult } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LCharacterAI } from "MysteryRogueSystem/ts/mr/lively/ai/LCharacterAI";
  import { LMovingTargetFinder } from "MysteryRogueSystem/ts/mr/lively/ai/LMovingTargetFinder";
  /**
   * https://yttm-work.jp/game_ai/game_ai_0001.html
   * https://wiki.denfaminicogamer.jp/ai_wiki/%E3%82%AD%E3%83%A3%E3%83%A9%E3%82%AF%E3%82%BF%E3%83%BCAI
   */
  export class LCharacterAI_Normal extends LCharacterAI {
      private _moveDeterminer;
      private _actionDeterminer;
      private _movingTargetFinder;
      clone(): LCharacterAI;
      setMovingTargetFinder(value: LMovingTargetFinder | undefined): void;
      thinkMoving(cctx: SCommandContext, self: LEntity): SPhaseResult;
      private applyTargetPosition;
      thinkAction(cctx: SCommandContext, self: LEntity): SPhaseResult;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/activities/LProjectileBehavior' {
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandResponse } from "ts/mr/system/SCommand";
  import { SEffectSubject } from "ts/mr/system/SEffectContext";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { CommandArgs, LBehavior, onMoveAsProjectile, onThrowReaction } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { DEmittor } from "ts/mr/data/DEmittor";
  import { LReaction } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  /**
   * 投射可能であるか。従来の Throwable の拡張。
   *
   * それは、
   * - 直線状に投げることができる。
   * - 吹き飛ばすことができる。
   * - 別の Unit に衝突することができる。
   * - 自然落下することができる。
   * - 壁に当たって落下することができる。
   */
  export class LProjectileBehavior extends LBehavior {
      blowDirection: number;
      blowMoveCount: number;
      private _effectSet;
      private _penetration;
      clone(newOwner: LEntity): LBehavior;
      static startMoveAsProjectile(cctx: SCommandContext, entity: LEntity, subject: SEffectSubject, dir: number, distance: number): void;
      static startMoveAsEffectProjectile(cctx: SCommandContext, entity: LEntity, subject: SEffectSubject, dir: number, length: number, effectSet: DEmittor): void;
      private clearKnockback;
      private hitType;
      private get effectSet();
      onQueryReactions(self: LEntity, reactions: LReaction[]): void;
      [onThrowReaction](args: CommandArgs, cctx: SCommandContext): SCommandResponse;
      [onMoveAsProjectile](args: CommandArgs, cctx: SCommandContext): SCommandResponse;
      private processEffectForNormal;
      private processEffectForPenetration;
      private endMoving;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/actors/LEaterBehavior' {
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandResponse } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { SActivityContext } from "ts/mr/system/SActivityContext";
  import { DActionId } from "ts/mr/data/DCommon";
  /**
   * @deprecated see kEntity_すばやさ草A
   */
  export class LEaterBehavior extends LBehavior {
      clone(newOwner: LEntity): LBehavior;
      onQueryActions(actions: DActionId[]): DActionId[];
      onActivity(self: LEntity, cctx: SCommandContext, actx: SActivityContext): SCommandResponse;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LActivityCharmBehavior' {
  import { SCommandResponse } from "ts/mr/system/SCommand";
  import { SActivityContext } from "ts/mr/system/SActivityContext";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LActivity } from "MysteryRogueSystem/ts/mr/lively/activities/LActivity";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  /**
   *
   */
  export class LActivityCharmBehavior extends LBehavior {
      clone(newOwner: LEntity): LBehavior;
      isCharmBehavior(): boolean;
      onActivity(self: LEntity, cctx: SCommandContext, actx: SActivityContext): SCommandResponse;
      onActivityReaction(self: LEntity, cctx: SCommandContext, activity: LActivity): SCommandResponse;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LActorBehavior' {
  import { DActor } from "ts/mr/data/DActor";
  import { DClass } from "ts/mr/data/DClass";
  import { DParameterId } from "ts/mr/data/DCommon";
  import { DActionId, DSkillId } from "ts/mr/data/DCommon";
  import { LBehavior } from "MysteryRogueSystem/ts/mr/lively/internal";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LBattlerBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBattlerBehavior";
  /**
   */
  export class LActorBehavior extends LBattlerBehavior {
      _classId: number;
      _skills: DSkillId[];
      clone(newOwner: LEntity): LBehavior;
      constructor();
      onAttached(self: LEntity): void;
      actor(): DActor;
      currentClass(): DClass;
      initSkills(): void;
      private learnSkill;
      private isLearnedSkill;
      onQueryIdealParamBase(paramId: DParameterId, base: number): number;
      onQueryActions(actions: DActionId[]): DActionId[];
      onCollectTraits(self: LEntity, result: IDataTrait[]): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LBattlerBehavior' {
  import { LBehavior } from "ts/mr/lively/behaviors/LBehavior";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { SCommandResponse } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LParamSet } from "MysteryRogueSystem/ts/mr/lively/LParam";
  import { SEffectorFact } from "ts/mr/system/SEffectApplyer";
  import { LReaction } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  import { DFlavorEffect } from "ts/mr/data/DFlavorEffect";
  export class LBattlerBehavior extends LBehavior {
      constructor();
      clone(newOwner: LEntity): LBehavior;
      paramSet(): LParamSet;
      onAttached(self: LEntity): void;
      onQueryReactions(self: LEntity, reactions: LReaction[]): void;
      isGuard(): boolean;
      attackAnimationId(): DFlavorEffect;
      bareHandsAnimationId(): DFlavorEffect;
      onCollectEffector(owner: LEntity, data: SEffectorFact): void;
      onPermanentDeath(self: LEntity, cctx: SCommandContext): SCommandResponse;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior' {
  /**
   *
   * [2020/11/30] シンボル関数名 vs Id(number)
   * ----------
   * 少なくとも、シンボルを関数名として使うのはやめた方がよさそう。
   * post 側は、相手側の関数名を知る必要は無くしたい。
   *
   * post では ActionId(Symbol or Number) を渡し、フレームワークによって
   * 従来の onPreReaction, onReaction を呼んでもらう。
   *
   * ### 相手側の関数名を知っていたいときもある
   *
   * 相手…というより、自分自身に post したいとき。向き変更や歩行が代表的かな。
   * これらは Action-Reaction のフレームワークがマッチしなかった者たち。
   *
   *
   *
   *
   * [2020/9/29] Behavior の代用
   * レンサのワナ、吸収の壺、あくまだんしゃく系
   *
   *
   * @note Attribute と Behavior を分ける必要はあるのか？
   * やはり移動がイメージしやすいかな。
   * Player, Enemy 共に Position は持つが、それをキー入力で更新するのか、AI で更新するのかは異なる。
   */
  import { DEventId } from "ts/mr/data/predefineds/DBasicEvents";
  import { SEffectSubject } from "ts/mr/system/SEffectContext";
  import { SCommand, SCommandResponse, SPhaseResult } from "MysteryRogueSystem/ts/mr/system/SCommand";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { LBehaviorId, LObject } from "MysteryRogueSystem/ts/mr/lively/LObject";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LActivity } from "MysteryRogueSystem/ts/mr/lively/activities/LActivity";
  import { DAnimationId, DParameterId } from "ts/mr/data/DCommon";
  import { LEventResult } from "MysteryRogueSystem/ts/mr/lively/LEventServer";
  import { DPrefabId } from "ts/mr/data/DPrefab";
  import { DCounterAction } from "ts/mr/data/DEntity";
  import { LCharacterAI } from "MysteryRogueSystem/ts/mr/lively/ai/LCharacterAI";
  import { SEffect, SEffectorFact } from "ts/mr/system/SEffectApplyer";
  import { DBlockLayerKind, DSpecialEffectId, DSubComponentEffectTargetKey, DActionId } from "ts/mr/data/DCommon";
  import { DSequelId } from "ts/mr/data/DSequel";
  import { LCandidateSkillAction } from "ts/mr/utility/UAction";
  import { DEffect } from "ts/mr/data/DEffect";
  import { DFactionId } from "ts/mr/data/MRData";
  import { LMinimapMarkerClass, LPriceInfo, LReaction } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  import { LMap } from "MysteryRogueSystem/ts/mr/lively/LMap";
  import { DEmittor } from "ts/mr/data/DEmittor";
  import { SActivityContext } from "ts/mr/system/SActivityContext";
  import { LFieldEffect } from "MysteryRogueSystem/ts/mr/lively/LFieldEffect";
  import { SSubTaskChain } from "ts/mr/system/tasks/STask";
  export enum DecisionPhase {
      Manual = 0,
      AIMinor = 1,
      UpdateState = 2,
      ResolveAdjacentAndMovingTarget = 3,
      AIMajor = 4
  }
  export enum LBehaviorGroup {
      Underlying = 0,
      SpecialAbility = 1
  }
  export enum LGenerateDropItemCause {
      Dead = 0,
      Stumble = 1
  }
  export interface LNameView {
      name: string;
      iconIndex: number;
      upgrades: number;
      capacity?: number;
      initialCapacity?: number;
  }
  export interface LParamMinMaxInfo {
      min?: number;
      max?: number;
  }
  export interface CommandArgs {
      /** Behavior がアタッチされている Entity. */
      self: LEntity;
      /** Command を Post した人 */
      sender: LEntity;
      /**
       * 効果発動時に参照する subject. 経験値の取得者などを示す。
       *
       * 1度のコマンドチェーンの中で複数回の攻撃とカウンターが互い違いに発生するケースでは
       * 個々のコールツリーごとに subject を持ちまわる必要があるため、CommandContext 側で管理するのは難しい。
       * そのため頑張って持ちまわる。
       */
      subject: SEffectSubject;
      args: any;
  }
  export const onPreThrowReaction: unique symbol;
  export const onThrowReaction: unique symbol;
  export const onMoveAsProjectile: unique symbol;
  export const onWalkedOnTopAction: unique symbol;
  export const onWalkedOnTopReaction: unique symbol;
  export const onPreStepFeetProcess_Actor: unique symbol;
  export const onPreStepFeetProcess: unique symbol;
  export const onPerformStepFeetProcess: unique symbol;
  /**
   * Response
   * - Canceled : 呪い状態等のため、Inventory からアイテムを取り出すことはできない。
   */
  export const testPickOutItem: unique symbol;
  /**
   * knockback 状態の別の Entity が衝突しようとしている
   */
  export const onCollidePreReaction: unique symbol;
  /**
   * 自分が knockback 状態であり、何らかの別の Entity に衝突した
   */
  export const onCollideAction: unique symbol;
  /**
   * 食べられた
   */
  export const onEatReaction: unique symbol;
  /**
   * (杖など) 振られた
   */
  export const onWaveReaction: unique symbol;
  /**
   * (階段など) 進まれた
   */
  export const onProceedFloorReaction: unique symbol;
  /**
   * 攻撃された
   */
  export const onAttackReaction: unique symbol;
  /**
   * 直接攻撃がヒットし、ダメージを受けた。
   * - 外れたときは呼ばれない。
   * - ヤリなど、隣接していなくても呼ばれることがある。
   */
  export const onDirectAttackDamaged: unique symbol;
  export const onEffectResult: unique symbol;
  /**
   * 接地した。
   *
   * 落下とはことなり、例えば既にアイテムがあるところに落ちようとした時は周囲タイルへ落ちていくが、
   * そういった落下完了までの諸々の処理が解決され、本当に地面上に着地したときに呼ばれる。
   */
  export const onGrounded: unique symbol;
  export interface CollideActionArgs {
      dir: number;
  }
  interface SEffectRejectionInfo {
      kind: "Effect";
      effect: DEffect;
  }
  interface SEffectBehaviorRejectionInfo {
      kind: "EffectBehavior";
      id: DSpecialEffectId;
  }
  export type SRejectionInfo = SEffectRejectionInfo | SEffectBehaviorRejectionInfo;
  /**
   * Entity の動作を定義する
   *
   * [2021/3/14]
   * ----------
   * 従来は派生クラスで State 用の StateBehavior や Ability 用の AbilityBehavior を作っていたが、これを禁止する。
   * たとえば "ハラヘリ" という Behavior は "ハラヘリ状態異常" や "ハラヘリの腕輪" で共有できるようにしておくことで、カスタマイズ性を確保しておきたい。
   */
  export abstract class LBehavior extends LObject {
      constructor();
      setup(...args: any[]): void;
      id(): LBehaviorId;
      ownerEntity(): LEntity;
      /**
       * 子オブジェクトが破棄されるなど、親オブジェクトから直ちに取り除くべき時に呼び出される。
       * この動作はキャンセルできないため、例えば呪い状態による装備の着脱判定などは行わず、確実に除外しなければならない。
       */
      onRemoveChild(entity: LEntity): void;
      /**
       * 親オブジェクトから直ちに取り除くべき時に呼び出される。
       * この動作はキャンセルできないため、例えば呪い状態による装備の着脱判定などは行わず、確実に除外しなければならない。
       */
      onOwnerRemoveFromParent(owner: LObject): void;
      onAttached(self: LEntity): void;
      onDetached(self: LEntity): void;
      onEvent(cctx: SCommandContext, eventId: DEventId, args: any): LEventResult;
      onPartyEvent(eventId: DEventId, args: any): LEventResult;
      onResetStatus(self: LEntity): void;
      dataId: number;
      behaviorGroup(): LBehaviorGroup;
      isCharmBehavior(): boolean;
      queryDisplayName(): LNameView | undefined;
      queryPrefabId(): DPrefabId | undefined;
      queryInnermostFactionId(): DFactionId | undefined;
      queryOutwardFactionId(): DFactionId | undefined;
      queryHomeLayer(): DBlockLayerKind | undefined;
      queryMinimapMarkerClass(): LMinimapMarkerClass | undefined;
      onQueryIdealParamBase(paramId: DParameterId, base: number): number;
      onQuerySubEntities(key: DSubComponentEffectTargetKey, result: LEntity[]): void;
      onQueryPrice(result: LPriceInfo): void;
      onQueryProperty(propertyId: number): any;
      onQueryIdealParameterPlus(paramId: DParameterId): number;
      onQueryIdleSequelId(): DSequelId;
      /**
       * この Behavior が Attach されている Entity が送信できる Action を取得する。
       * 例えばキャラクターはアイテムを "拾う" ことができる。
       *
       * 基本的に状態異常等は関係なく、その Entity が元々とれる行動を返すこと。
       * 例えば "封印" 状態であれば "食べる" ことはできないが、メニューから行動として
       * "食べる" を選択することはできるので、このメソッドは EatAction を返すべき。
       */
      onQueryActions(actions: DActionId[]): DActionId[];
      /**
       * この Behavior が Attach されている Entity に対して送信できる Action を取得する。
       * 例えばアイテムはキャラクターに "拾われる" ことができる。
       *
       * こちらも onQueryActions() 同様、基本的に状態に関係なくEntity が反応できる行動を返すこと。
       * 例えば "床に張り付いた聖域の巻物" は "拾う" ことはできないが、メニューから行動として
       * "拾う" を選択することはできるので、このメソッドは PickAction を返すべき。
       *
       * 状況に応じて、そもそもメニューに表示したくない Action は返さないようにしてもよい。
       *
       * なお "階段" Entity がこのメソッドで PickAction を返すと、階段を拾うことができてしまう。
       */
      onQueryReactions(self: LEntity, reactions: LReaction[]): void;
      onQueryCharacterAI(characterAIs: LCharacterAI[]): void;
      onQueryAttackAnimationId(self: LEntity, index: number): DAnimationId | undefined;
      onParamIdealPlusChanged(self: LEntity, paramId: DParameterId, newValue: number, oldValue: number): void;
      onParamChanged(self: LEntity, paramId: DParameterId, newValue: number, oldValue: number): void;
      /** 指定された依存パラメータの値を取得する。 */
      onGetDependentParameterIdealBaseValue(self: LEntity, parameterId: DParameterId): number | undefined;
      /** 指定された依存パラメータの値を設定する。 */
      onSetDependentParameterIdealBaseValue(self: LEntity, parameterId: DParameterId, value: number): void;
      onRefreshConditions(self: LEntity): void;
      onDecisionPhase(self: LEntity, cctx: SCommandContext, phase: DecisionPhase): SPhaseResult;
      onCommand(self: LEntity, cctx: SCommandContext, chain: SSubTaskChain, cmd: SCommand): SCommandResponse;
      onPreprocessActivity(cctx: SCommandContext, activity: LActivity): LActivity;
      /**
       * onActivity が呼び出される前に呼び出されます。
       * Pass 以外を返した場合、activity が onActivity() に通知されることはありません。
       * これによって、特定の行動をキャンセルするような動作を実装できます。
       * 行動トークンの消費は呼び出し側で処理されます。
       */
      onPreActivity(self: LEntity, cctx: SCommandContext, actx: SActivityContext): SCommandResponse;
      /**
       * Activity の処理。
       * [飲む] [振る] [読む] など。
       */
      onActivity(self: LEntity, cctx: SCommandContext, actx: SActivityContext): SCommandResponse;
      /**
       * Activity を受ける側の処理。
       * [飲まれた] [振られた] [読まれた] など。
       */
      onActivityPreReaction(self: LEntity, cctx: SCommandContext, activity: LActivity): SCommandResponse;
      onActivityReaction(self: LEntity, cctx: SCommandContext, activity: LActivity): SCommandResponse;
      /**
       * @deprecated 地雷の即死効果で使用していた。今は使っていないので、折を見て削除する予定。
       */
      onPreApplyEffect(self: LEntity, cctx: SCommandContext, effect: SEffect): SCommandResponse;
      /** 特定の Reaction に割り当てられている Effect を、命中判定無しで発動する。遠投の処理で使用する。 */
      onEmitEffect(self: LEntity, cctx: SCommandContext, actionId: DActionId, subject: LEntity, target: LEntity, dir: number): SCommandResponse;
      onEffectSensed(self: LEntity, cctx: SCommandContext): SCommandResponse;
      onCollectEffector(owner: LEntity, data: SEffectorFact): void;
      onCollectTraits(self: LEntity, result: IDataTrait[]): void;
      onCollectCharmdBehaviors(self: LEntity, result: LBehavior[]): void;
      /** 主に AI 行動決定用に、スキルの一覧を取得する */
      onCollectSkillActions(result: IDataAction[]): void;
      onCollectFieldEffect(self: LEntity): Generator<LFieldEffect, void, unknown>;
      onPostMakeSkillActions(candidates: LCandidateSkillAction[]): void;
      onAfterStep(self: LEntity, cctx: SCommandContext): SCommandResponse;
      /** 1行動消費単位の終了時点 */
      onStepEnd(cctx: SCommandContext): SCommandResponse;
      onStabilizeSituation(self: LEntity, cctx: SCommandContext): SCommandResponse;
      /**
       * 完全な死亡状態となった。
       * 復活草などの発動判定が行われた後、救いようが無くゲームオーバーとなった状態で、このハンドラが呼ばれたら復活してはならない。
       * 戦闘不能エフェクトやドロップアイテムの処理をオーバーライドできる。
       */
      onPermanentDeath(self: LEntity, cctx: SCommandContext): SCommandResponse;
      onPertyChanged(self: LEntity): void;
      onEnteredMap(self: LEntity, map: LMap): void;
      onTalk(self: LEntity, cctx: SCommandContext, person: LEntity): SCommandResponse;
      onGenerateDropItems(self: LEntity, cause: LGenerateDropItemCause, result: LEntity[]): void;
      /** EffectBehavior で狙われたとき。効果を防止するには Cancel を返す。 */
      onPreviewRejection(self: LEntity, cctx: SCommandContext, rejection: SRejectionInfo): SCommandResponse;
      onEffectPerformed(self: LEntity, cctx: SCommandContext, emittor: DEmittor): SCommandResponse;
      onCounterAction(self: LEntity, cctx: SCommandContext, data: DCounterAction): SCommandResponse;
      abstract clone(newOwner: LEntity): LBehavior;
      onCheckLooksLikeItem(): boolean;
      onCheckLooksLikeGold(): boolean;
  }
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LCommonBehavior' {
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { DecisionPhase, LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { SActivityContext } from "ts/mr/system/SActivityContext";
  import { SCommandResponse, SPhaseResult } from "ts/mr/system/SCommand";
  import { DEmittor } from "ts/mr/data/DEmittor";
  import { DActionId } from "ts/mr/data/DCommon";
  /**
   * 全 Entity に共通するもの。
   *
   * ひとまず、一般的ではないかもしれないけど、検証用途や一時的にここに機能を置くこともある。
   * というか現状何が本当に必要なのか不透明な状態なので、あるていど機能のまとまりが見えてきたら派生クラス作って分離していく。
   */
  export class LCommonBehavior extends LBehavior {
      reservedCounterActionIndex: number;
      clone(newOwner: LEntity): LBehavior;
      onQueryActions(actions: DActionId[]): DActionId[];
      onActivity(self: LEntity, cctx: SCommandContext, actx: SActivityContext): SCommandResponse;
      onDecisionPhase(self: LEntity, cctx: SCommandContext, phase: DecisionPhase): SPhaseResult;
      onEffectPerformed(self: LEntity, cctx: SCommandContext, emittor: DEmittor): SCommandResponse;
      onStabilizeSituation(self: LEntity, cctx: SCommandContext): SCommandResponse;
      private meetsCounterActionConditions;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LDecisionBehavior' {
  import { SPhaseResult } from "MysteryRogueSystem/ts/mr/system/SCommand";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { DecisionPhase, LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { LCharacterAI } from "MysteryRogueSystem/ts/mr/lively/ai/LCharacterAI";
  import { LActivity } from "MysteryRogueSystem/ts/mr/lively/activities/LActivity";
  import { LCharacterAI_Normal } from "MysteryRogueSystem/ts/mr/lively/ai/LStandardAI";
  /**
   * Scheduler から通知された各タイミングにおいて、行動決定を行う Behavior.
   *
   * この Behavior は標準的な行動決定のみ行う。
   * 状態異常による行動制限(&経過ターンのデクリメント)・暴走は、状態異常の Behavior 側で onDecisionPhase() をフックして実装する。
   */
  export class LDecisionBehavior extends LBehavior {
      _characterAI: LCharacterAI_Normal;
      forceMajorActivity: LActivity | undefined;
      clone(newOwner: LEntity): LBehavior;
      characterAI(): LCharacterAI_Normal;
      onQueryCharacterAI(characterAIs: LCharacterAI[]): void;
      onDecisionPhase(self: LEntity, cctx: SCommandContext, phase: DecisionPhase): SPhaseResult;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LEnemyBehavior' {
  import { DEnemy, DDropItem } from "ts/mr/data/DEnemy";
  import { DParameterId } from "ts/mr/data/DCommon";
  import { SPhaseResult } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { DecisionPhase, LBehavior, LGenerateDropItemCause } from "MysteryRogueSystem/ts/mr/lively/internal";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LRandom } from "MysteryRogueSystem/ts/mr/lively/LRandom";
  import { LBattlerBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBattlerBehavior";
  /**
   */
  export class LEnemyBehavior extends LBattlerBehavior {
      clone(newOwner: LEntity): LBehavior;
      constructor();
      onAttached(self: LEntity): void;
      enemyData(): DEnemy;
      onQueryIdealParamBase(paramId: DParameterId, base: number): number;
      exp(): number;
      onCollectTraits(self: LEntity, result: IDataTrait[]): void;
      onCollectSkillActions(result: IDataAction[]): void;
      onGenerateDropItems(self: LEntity, cause: LGenerateDropItemCause, result: LEntity[]): void;
      onDecisionPhase(self: LEntity, cctx: SCommandContext, phase: DecisionPhase): SPhaseResult;
      selectDropItem(rand: LRandom): DDropItem | undefined;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LEntryPointBehavior' {
  import { DBlockLayerKind } from "ts/mr/data/DCommon";
  import { CommandArgs, LBehavior, onProceedFloorReaction } from "ts/mr/lively/behaviors/LBehavior";
  import { SCommandResponse } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LReaction } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  /**
   */
  export class LEntryPointBehavior extends LBehavior {
      clone(newOwner: LEntity): LBehavior;
      queryHomeLayer(): DBlockLayerKind | undefined;
      onQueryReactions(self: LEntity, reactions: LReaction[]): void;
      [onProceedFloorReaction](args: CommandArgs, cctx: SCommandContext): SCommandResponse;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LEquipmentBehavior' {
  import { SCommand, SCommandResponse } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { SSubTaskChain } from "ts/mr/system/tasks/STask";
  import { LReaction } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LObject } from "MysteryRogueSystem/ts/mr/lively/LObject";
  import { CommandArgs, LBehavior, testPickOutItem } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  export class LEquipmentBehavior extends LBehavior {
      clone(newOwner: LEntity): LBehavior;
      onAttached(self: LEntity): void;
      onQueryReactions(self: LEntity, reactions: LReaction[]): void;
      onOwnerRemoveFromParent(owner: LObject): void;
      [testPickOutItem](args: CommandArgs, cctx: SCommandContext): SCommandResponse;
      onCommand(self: LEntity, cctx: SCommandContext, chain: SSubTaskChain, cmd: SCommand): SCommandResponse;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LEquipmentUserBehavior' {
  import { SCommandResponse } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { DAnimationId, DParameterId } from "ts/mr/data/DCommon";
  import { SActivityContext } from "ts/mr/system/SActivityContext";
  import { DActionId, DSubComponentEffectTargetKey } from "ts/mr/data/DCommon";
  import { LEventResult } from "MysteryRogueSystem/ts/mr/lively/LEventServer";
  import { DEventId } from "ts/mr/data/predefineds/DBasicEvents";
  /**
   * 装備アイテムを装備できる人。
   *
   * LInventoryBehavior が必須。
   * 装備アイテムは LInventoryBehavior が持っているものを参照する。
   * この Behavior が装備アイテムEntity の親になることは無い。
   */
  export class LEquipmentUserBehavior extends LBehavior {
      private _slots;
      private _shortcutItemEntityId;
      private _revisitonNumber;
      constructor();
      onAttached(self: LEntity): void;
      onDetached(self: LEntity): void;
      onEvent(cctx: SCommandContext, eventId: DEventId, args: any): LEventResult;
      clone(newOwner: LEntity): LBehavior;
      isEquipped(item: LEntity): boolean;
      isShortcutEquipped(item: LEntity): boolean;
      get shortcutItem(): LEntity | undefined;
      equippedItemEntities(): LEntity[];
      revisitonNumber(): number;
      onQuerySubEntities(key: DSubComponentEffectTargetKey, result: LEntity[]): void;
      static calcEquipmentParam(item: LEntity, paramId: DParameterId): number;
      onQueryProperty(propertyId: number): any;
      onQueryIdealParameterPlus(paramId: DParameterId): number;
      onQueryActions(actions: DActionId[]): DActionId[];
      onQueryAttackAnimationId(self: LEntity, index: number): DAnimationId | undefined;
      onCollectTraits(self: LEntity, result: IDataTrait[]): void;
      onActivity(self: LEntity, cctx: SCommandContext, actx: SActivityContext): SCommandResponse;
      equipOnUtil(itemEntity: LEntity): void;
      private equipOn;
      private postEquipOff;
      removeEquitment(itemEntity: LEntity): boolean;
      removeShortcut(itemEntity: LEntity): boolean;
      equipOnShortcut(cctx: SCommandContext, item: LEntity): void;
      equipOffShortcut(cctx: SCommandContext, itemEntity: LEntity): void;
      onRemoveItemFromInventory(item: LEntity): void;
      private refreshSlots;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LEscapeBehavior' {
  import { SPhaseResult } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { DecisionPhase, LBehavior, LBehaviorGroup } from "MysteryRogueSystem/ts/mr/lively/internal";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  /**
   */
  export class LEscapeBehavior extends LBehavior {
      private _escapeAI;
      constructor();
      clone(newOwner: LEntity): LBehavior;
      behaviorGroup(): LBehaviorGroup;
      onDecisionPhase(self: LEntity, cctx: SCommandContext, phase: DecisionPhase): SPhaseResult;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LExitPointBehavior' {
  import { CommandArgs, LBehavior, onProceedFloorReaction } from "ts/mr/lively/behaviors/LBehavior";
  import { SCommandResponse } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { DBlockLayerKind } from "ts/mr/data/DCommon";
  import { LReaction } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  /**
   * [2021/8/14] 「戻る」の実装について
   * ----------
   *
   * まず制約として、階段の外見を変更できるようにする必要がある。
   * これを実現する一番手っ取り早い&ツクールの仕組みで頑張るなら、スイッチによるイベントページの切り替え。
   * SFCトルネコでは特定アイテムの所持で方向が変わるが、これはそのままツクールのイベントの[条件]を使えばよいだろう。
   *
   *
   *
   * [2020/11/1] NOTE: Player が乗ったときの UI 表示タイミング
   * ----------
   * 乗った瞬間ではなく、乗った次のターンの Dialog 表示時である点に注意。
   * ただ、これはアイテムなど「あしもと」に対して行う表示と同様のシステムになりそう。
   * - アイテムを拾うのは手番内。
   * - アイテムに「のった」表示も手番内。
   * - お店のアイテムにのったときの UI 表示は次のターン。
   *
   * あとこれはコアシステムとして必須の機能ではなくて、ユーザビリティのための便利機能。
   *
   * Dialog 側で足元の Entty の種別をみて Window 表示とかやると、また拡張性が微妙になる。
   * できれば Item や階段の Behavior 側の「乗られた」Reaction で、
   * 「次の Player Dialog Open時に表示したいユーザビリティアクション」みたいなものを、PlayerEntity の set して実現したいところ。
   * set はしてるけど、次に Player が行動不能だったりしたら破棄するだけ。
   *
   * …と考えてみたが、階段上へ移動 → モンスターの吹き飛ばしで階段上以外へ移動 → そのあとは UI 表示しない といこともあるので、この対策が何か必要。
   *
   * HC4 の時に実装したリアクションコマンド形式がいいかも。
   * Behavior に問い合わせ用のメソッド追加する必要があるけど、Entity に対してどんなアクションをとれるか聞く仕組みがあると自然。
   */
  export class LExitPointBehavior extends LBehavior {
      clone(newOwner: LEntity): LBehavior;
      queryHomeLayer(): DBlockLayerKind | undefined;
      onQueryReactions(self: LEntity, reactions: LReaction[]): void;
      [onProceedFloorReaction](args: CommandArgs, cctx: SCommandContext): SCommandResponse;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LExperienceBehavior' {
  import { LBehavior } from "ts/mr/lively/behaviors/LBehavior";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { DParameterId } from "ts/mr/data/DCommon";
  export class LExperienceBehavior extends LBehavior {
      constructor();
      clone(newOwner: LEntity): LBehavior;
      onAttached(self: LEntity): void;
      onResetStatus(self: LEntity): void;
      onParamIdealPlusChanged(self: LEntity, paramId: DParameterId, newValue: number, oldValue: number): void;
      onParamChanged(self: LEntity, paramId: DParameterId, newValue: number, oldValue: number): void;
      onRefreshConditions(self: LEntity): void;
      private resetLevel;
      level(self: LEntity): number;
      currentExp(self: LEntity): number;
      setLevel(self: LEntity, value: number): void;
      private gainLevel;
      nextLevelExp(self: LEntity): number;
      private actor;
      private maxLevel;
      private isMaxLevel;
      private currentClass;
      expForLevel(self: LEntity, level: number): number;
      private currentLevelExp;
      setExp(self: LEntity, value: number): void;
      private refreshExpFromLevel;
      private refreshLevelFromExp;
      private onLevelUp;
      private onLevelDown;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LFlockBehavior' {
  import { DEventId } from "ts/mr/data/predefineds/DBasicEvents";
  import { LBehavior } from "MysteryRogueSystem/ts/mr/lively/internal";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LEventResult } from "MysteryRogueSystem/ts/mr/lively/LEventServer";
  export class LFlockBehavior extends LBehavior {
      clone(newOwner: LEntity): LBehavior;
      onAttached(self: LEntity): void;
      onDetached(self: LEntity): void;
      onPertyChanged(self: LEntity): void;
      onPartyEvent(eventId: DEventId, args: any): LEventResult;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LGlueToGroundBehavior' {
  import { SCommandResponse } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LActivity } from "MysteryRogueSystem/ts/mr/lively/activities/LActivity";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { CommandArgs, LBehavior, onGrounded, testPickOutItem } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  /**
   * 置くと床に張り付く
   */
  export class LGlueToGroundBehavior extends LBehavior {
      private _glued;
      clone(newOwner: LEntity): LBehavior;
      get glued(): boolean;
      set glued(value: boolean);
      onActivityPreReaction(self: LEntity, cctx: SCommandContext, activity: LActivity): SCommandResponse;
      [testPickOutItem](args: CommandArgs, cctx: SCommandContext): SCommandResponse;
      [onGrounded](args: CommandArgs, cctx: SCommandContext): SCommandResponse;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LGoldBehavior' {
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LBehavior, LNameView } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  /**
   * お金
   */
  export class LGoldBehavior extends LBehavior {
      clone(newOwner: LEntity): LBehavior;
      constructor();
      onAttached(self: LEntity): void;
      queryDisplayName(): LNameView | undefined;
      onCheckLooksLikeGold(): boolean;
      gold(): number;
      setGold(value: number): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LGoldThiefBehavior' {
  import { SPhaseResult } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LCandidateSkillAction } from "ts/mr/utility/UAction";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { DecisionPhase, LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  /**
   *
   */
  export class LGoldThiefBehavior extends LBehavior {
      private _standardAI;
      private _escapeAI;
      constructor();
      clone(newOwner: LEntity): LBehavior;
      onPostMakeSkillActions(candidates: LCandidateSkillAction[]): void;
      onDecisionPhase(self: LEntity, cctx: SCommandContext, phase: DecisionPhase): SPhaseResult;
      private activeAI;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LInventoryBehavior' {
  /**
   *
   * [2021/9/26] モンスターのアイテムドロップ
   * ----------
   *
   * - 倒されたときのランダムアイテムドロップ
   * - 転ばされたときのランダムアイテムドロップ
   * - 倒されたときの固有アイテムドロップ (Mr.ブーン系など)
   * - ケンゴウ系能力によってはじかれた装備品
   * - マゼルン系おとす合成後アイテム
   *
   * モンスターから出てくるアイテムはこれらのいずれか。
   * 例えば Mr.ブーン はケンゴウ系能力で装備品をはじかれた後は、倒されても草を落とさない。
   *
   * ### 実装方針
   *
   * まずインベントリと、アイテムドロップフラグというものを作っておく。
   *
   * 倒されたとき…
   * - インベントリにアイテムがある場合、アイテムドロップフラグは考慮せずに、そのアイテムを落とす。
   * - 転んだ・弾かれたなどで UnitEntity が何かアイテムを生成した場合、アイテムドロップフラグをON.
   * - アイテムドロップフラグがONの場合、倒されてもアイテムを落とさない。
   * - 倒されたときにアイテムドロップフラグが OFF の場合、アイテムドロップ処理を開始する。
   *   - 固有アイテムがあれば落とす。
   *   - なければ、フロアの「てきがおとすもの」テーブルに従いドロップする。
   *
   *
   *
   * [2020/11/29] Note:
   * ----------
   * Inventory の定義をどこまでにするのかによるけど、
   * 「アイテムを持てる」という視点だと、Inventory は必ず Unit がもつ、というわけではない点に注意。
   *
   * - Player は持ち物として Inventory がある。
   * - 仲間によっては持ち物を持てる (シレン2 マーモ)
   * - モンスターも、アイテムを拾って保持し、投げる者がいる (シレン2 アメンジャ)
   * - 行商人も、アイテムを拾って保持する。(値札をつける)
   * - 倉庫を Entity とするかは微妙なところだが、しておくと UI が共通化できそう
   * - 壺は Inventory を持つアイテム、と考えられそう
   *
   * アイテムに関連する共通アクション
   * - 拾う
   * - 交換
   * - 置く
   * - 投げる
   * - (放り投げる)
   * - (落とす)
   * - (落下する)
   * - (ばらまく) : 転ばされた時。壺は稀に割れる
   *
   * 壺
   * - 入れる
   * - だす
   *
   * 固有アクション
   * - 食べる
   * - 振る
   * - 読む
   * - …など。
   *
   * NPCに対して　スリ取り・スリ入れ ができるようなシステムを考えると、NPC は全員 Inventory を持つことになりそう。
   *
   *
   * ### UI共通化について
   *
   * "持ち物リスト" という画面を出すタイミングは、前述の Inventory を持ち得る Entity に共通すること。（モンスター能力は違うかもだけど）
   *
   * Inventory の内容を表示する画面、という考えて作っておくと再利用いろいろできそう。
   *
   *
   *
   * [2021/7/8] アイテムのスタック
   * ----------
   * ### スタックできるもの
   * - 矢弾
   * - 札
   * 種別として固定しない方がいいかも。
   *
   * ### スタックできる基準
   * elona だと、呪われていたりすると別スタック。
   * シレンだと、統合先の状態に合わせてスタックできる。
   * - つまり、スタックの条件はタイトルによって異なる。
   *
   * また、アイテムの種類ではなくインベントリの種類によっても異なるので注意。
   * - 壺インベントリの場合はスタックしない
   *
   * ### スタック数と使用回数は別物？
   * elona 的には別物。
   * こっちでも別物扱いの方がいいだろう。使用回数[0]はスタック0ではない。
   * スタック0はそもそも存在しないことを示す。
   *
   * ### スタックするタイミングは？
   * 少なくとも、インベントリに入ったタイミングではない。
   * [交換] では矢やお金はスタックされない。
   *
   */
  import { LEntityId } from "MysteryRogueSystem/ts/mr/lively/LObject";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LBehavior, SRejectionInfo } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { SCommandResponse } from "ts/mr/system/SCommand";
  export class LInventoryBehavior extends LBehavior {
      _entities: LEntityId[];
      private _gold;
      private _capacity;
      clone(newOwner: LEntity): LBehavior;
      /** [ScriptCommandAPI] */
      clearItems(): void;
      reset(): void;
      get capacity(): number;
      set capacity(value: number);
      get itemCount(): number;
      get remaining(): number;
      get isFully(): boolean;
      hasAnyItem(): boolean;
      get items(): LEntity[];
      iterateItems(func: ((item: LEntity) => void) | ((item: LEntity) => boolean)): void;
      contains(entity: LEntity): boolean;
      addEntity(entity: LEntity): void;
      canAddEntityWithStacking(item: LEntity): boolean;
      addEntityWithStacking(entity: LEntity): void;
      removeEntity(entity: LEntity): void;
      onRemoveChild(entity: LEntity): void;
      onCollectTraits(self: LEntity, result: IDataTrait[]): void;
      onCollectCharmdBehaviors(self: LEntity, result: LBehavior[]): void;
      onPreviewRejection(self: LEntity, cctx: SCommandContext, rejection: SRejectionInfo): SCommandResponse;
      gold(): number;
      gainGold(amount: number): void;
      loseGold(amount: number): void;
      maxGold(): number;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LItemBehavior' {
  import { SCommandResponse } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LActivity } from "MysteryRogueSystem/ts/mr/lively/activities/LActivity";
  import { LStructureId } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { CommandArgs, LBehavior, onAttackReaction } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { SActivityContext } from "ts/mr/system/SActivityContext";
  import { DActionId } from "ts/mr/data/DCommon";
  /**
   * Item として表現する Entity の共通 Behavior
   */
  export class LItemBehavior extends LBehavior {
      private _shopStructureId;
      clone(newOwner: LEntity): LBehavior;
      constructor();
      shopStructureId(): LStructureId;
      setShopStructureId(value: LStructureId): void;
      onCollectTraits(self: LEntity, result: IDataTrait[]): void;
      onActivity(self: LEntity, cctx: SCommandContext, actx: SActivityContext): SCommandResponse;
      onActivityReaction(self: LEntity, cctx: SCommandContext, activity: LActivity): SCommandResponse;
      onEmitEffect(self: LEntity, cctx: SCommandContext, actionId: DActionId, subject: LEntity, target: LEntity, dir: number): SCommandResponse;
      private applyHitEffect;
      [onAttackReaction](args: CommandArgs, cctx: SCommandContext): SCommandResponse;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LItemImitatorBehavior' {
  import { DPrefabId } from "ts/mr/data/DPrefab";
  import { DEventId } from "ts/mr/data/predefineds/DBasicEvents";
  import { DFactionId } from "ts/mr/data/MRData";
  import { SCommandResponse } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LEventResult } from "MysteryRogueSystem/ts/mr/lively/LEventServer";
  import { CommandArgs, LBehavior, LNameView, testPickOutItem } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { DBlockLayerKind } from "ts/mr/data/DCommon";
  import { LMap } from "MysteryRogueSystem/ts/mr/lively/LMap";
  import { LMinimapMarkerClass, LReaction } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  /**
   * Item に化けるモンスター。
   *
   * [2021/6/20] 化けるItem自体のEntityと合成するか、それは内包して見た目だけコントールするか
   * ----------
   *
   * 後者で行ってみる。
   *
   * 後者の場合、基本的にはこの Behavior で名前、アイコン、種別、コマンドリストなどをオーバーライドして対応できる。
   * アイテムによっては 水がめの [くむ]、草投げの杖の [いれる]、いかすしの巻物の [たべる] など基本と異なるコマンドがあるが、
   * それは内包しているアイテム Entity に対して中継すればよいだけ。説明文、使用回数や修正値もこのように参照できる。
   *
   * 前者の場合、真のアイテム種別などをモンスターEntity自身が持ってしまうことになるため、
   * 種別の区別が必要になる色々な処理に細工が必要になる。
   * たとえば、ひま投げで投げられた化けモンスターが、合成の壺や草効果の壺に入った時。
   * 壺側の処理として、Entityが２つの種類を持つ可能性を考慮するのは何か違うきがするし、
   * そういった処理を常に気を付けながら実装しなければならないのはNG.
   *
   * どちらの場合にしても、例えば草、杖といった "種別" は、表示用と処理用の2つが必要になる。
   *
   * [2021/6/21] アイテム化けはスキルおよびステートとして扱う
   * ----------
   *
   * こうしないと、完全にあるモンスター専用の Behavior を作る必要がある。
   * それはカスタマイズ性を著しく下げるため避けたいところ。
   * その場合は既存の AI の仕組みをオーバーライドする必要もあり、AI 側はそのような使われ方を想定して実装しなければならず負担が大きい。
   *
   * アイテム化けスキルは「敵対Entityが視界内にいなければ優先的に発動する」スキルとして実装する。
   * またこのスキルは「アイテム化けステートを付加する」のみの効果とする。
   *
   *
   *
   *
   */
  export class LItemImitatorBehavior extends LBehavior {
      private _itemEntityId;
      clone(newOwner: LEntity): LBehavior;
      constructor();
      onAttached(self: LEntity): void;
      onDetached(self: LEntity): void;
      onEnteredMap(self: LEntity, map: LMap): void;
      queryDisplayName(): LNameView | undefined;
      queryPrefabId(): DPrefabId | undefined;
      queryHomeLayer(): DBlockLayerKind | undefined;
      queryMinimapMarkerClass(): LMinimapMarkerClass | undefined;
      onQueryReactions(self: LEntity, reactions: LReaction[]): void;
      itemEntity(): LEntity;
      queryOutwardFactionId(): DFactionId | undefined;
      [testPickOutItem](args: CommandArgs, cctx: SCommandContext): SCommandResponse;
      onEvent(cctx: SCommandContext, eventId: DEventId, args: any): LEventResult;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LItemThiefBehavior' {
  import { SPhaseResult } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LCandidateSkillAction } from "ts/mr/utility/UAction";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { DecisionPhase, LBehavior, LBehaviorGroup } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  /**
   *
   */
  export class LItemThiefBehavior extends LBehavior {
      private _standardAI;
      private _escapeAI;
      constructor();
      clone(newOwner: LEntity): LBehavior;
      behaviorGroup(): LBehaviorGroup;
      onPostMakeSkillActions(candidates: LCandidateSkillAction[]): void;
      onDecisionPhase(self: LEntity, cctx: SCommandContext, phase: DecisionPhase): SPhaseResult;
      private activeAI;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LItemUserBehavior' {
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  /**
   * @deprecated
   */
  export class LItemUserBehavior extends LBehavior {
      clone(newOwner: LEntity): LBehavior;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LParamBehavior' {
  import { DParameterId } from "ts/mr/data/DCommon";
  import { LBehavior, LBehaviorGroup } from "MysteryRogueSystem/ts/mr/lively/internal";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  /**
   * パラメータの定数加算
   */
  export class LParamBehavior extends LBehavior {
      private _values;
      constructor();
      clone(newOwner: LEntity): LBehavior;
      setParamBase(paramId: DParameterId, value: number): void;
      behaviorGroup(): LBehaviorGroup;
      onQueryIdealParamBase(paramId: DParameterId, base: number): number;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LPreventionBehavior' {
  import { SCommandResponse } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LBehavior, SRejectionInfo } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  /**
   *
   */
  export class LStumblePreventionBehavior extends LBehavior {
      clone(newOwner: LEntity): LBehavior;
      onPreviewRejection(self: LEntity, cctx: SCommandContext, rejection: SRejectionInfo): SCommandResponse;
      private rejectStumble;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LRaceBehavior' {
  import { LBehavior } from "MysteryRogueSystem/ts/mr/lively/internal";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LBattlerBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBattlerBehavior";
  /**
   * LEntity の持つ Race に基づいて種族を表現する Behavior。
   */
  export class LRaceBehavior extends LBattlerBehavior {
      clone(newOwner: LEntity): LBehavior;
      private races;
      onCollectTraits(self: LEntity, result: IDataTrait[]): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LRatedRandomAIBehavior' {
  import { SPhaseResult } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LCharacterAI } from "MysteryRogueSystem/ts/mr/lively/ai/LCharacterAI";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { DecisionPhase, LBehavior, LBehaviorGroup } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  /**
   *
   */
  export class LRatedRandomAIBehavior extends LBehavior {
      private _characterAI;
      clone(newOwner: LEntity): LBehavior;
      behaviorGroup(): LBehaviorGroup;
      onQueryCharacterAI(characterAIs: LCharacterAI[]): void;
      onDecisionPhase(self: LEntity, cctx: SCommandContext, phase: DecisionPhase): SPhaseResult;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LRevivalItemBehavior' {
  import { SCommandResponse } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  /**
   *
   */
  export class LRevivalItemBehavior extends LBehavior {
      clone(newOwner: LEntity): LBehavior;
      isCharmBehavior(): boolean;
      onStabilizeSituation(self: LEntity, cctx: SCommandContext): SCommandResponse;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LSanctuaryBehavior' {
  import { SCommandResponse } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LActivity } from "MysteryRogueSystem/ts/mr/lively/activities/LActivity";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LFieldEffect } from "MysteryRogueSystem/ts/mr/lively/LFieldEffect";
  import { LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  /**
   */
  export class LSanctuaryBehavior extends LBehavior {
      private _fieldEffect;
      constructor();
      clone(newOwner: LEntity): LBehavior;
      onAttached(self: LEntity): void;
      onDetached(self: LEntity): void;
      onActivityReaction(self: LEntity, cctx: SCommandContext, activity: LActivity): SCommandResponse;
      onCollectFieldEffect(self: LEntity): Generator<LFieldEffect, void, unknown>;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LSelfExplosionBehavior' {
  import { SCommandResponse } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { CommandArgs, LBehavior, onEffectResult } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  /**
   */
  export class LSelfExplosionBehavior extends LBehavior {
      constructor();
      clone(newOwner: LEntity): LBehavior;
      [onEffectResult](args: CommandArgs, cctx: SCommandContext): SCommandResponse;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LShopkeeperBehavior' {
  import { DecisionPhase, LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { SCommandResponse, SPhaseResult } from "ts/mr/system/SCommand";
  import { LStructureId } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  import { LItemShopStructure, LShopEntrance } from "MysteryRogueSystem/ts/mr/lively/structures/LItemShopStructure";
  import { LMovingTargetFinder } from "MysteryRogueSystem/ts/mr/lively/ai/LMovingTargetFinder";
  import { LActivity } from "MysteryRogueSystem/ts/mr/lively/activities/LActivity";
  /**
   */
  export class LShopkeeperBehavior extends LBehavior {
      private _shopStructureId;
      private _shopkeeperIndex;
      clone(newOwner: LEntity): LBehavior;
      shopStructureId(): number;
      shopkeeperIndex(): number;
      shop(): LItemShopStructure;
      shopEntrance(): LShopEntrance;
      setup(shopStructureId: LStructureId, shopkeeperIndex: number): void;
      onAttached(self: LEntity): void;
      onDecisionPhase(self: LEntity, cctx: SCommandContext, phase: DecisionPhase): SPhaseResult;
      onTalk(self: LEntity, cctx: SCommandContext, person: LEntity): SCommandResponse;
      onActivityReaction(self: LEntity, cctx: SCommandContext, activity: LActivity): SCommandResponse;
  }
  export class LMovingTargetFinder_Shopkeeper extends LMovingTargetFinder {
      private _ownerShopkeeperId;
      constructor(shopkeeper: LShopkeeperBehavior);
      decide(self: LEntity): (number[] | undefined);
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LStorageBehavior' {
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  /**
   *
   */
  export class LStorageBehavior extends LBehavior {
      constructor();
      clone(newOwner: LEntity): LBehavior;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LSurvivorBehavior' {
  import { SPhaseResult } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { DecisionPhase, LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  /**
   *
   */
  export class LSurvivorBehavior extends LBehavior {
      private _basicLoss;
      private _prevFP;
      constructor();
      clone(newOwner: LEntity): LBehavior;
      onAttached(self: LEntity): void;
      onDecisionPhase(self: LEntity, cctx: SCommandContext, phase: DecisionPhase): SPhaseResult;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LTrapBehavior' {
  import { SCommandResponse } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { CommandArgs, LBehavior, onPerformStepFeetProcess, onPreStepFeetProcess } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { DEventId } from "ts/mr/data/predefineds/DBasicEvents";
  import { LEventResult } from "MysteryRogueSystem/ts/mr/lively/LEventServer";
  import { DEmittor } from "ts/mr/data/DEmittor";
  import { LActivity } from "MysteryRogueSystem/ts/mr/lively/activities/LActivity";
  import { DCounterAction } from "ts/mr/data/DEntity";
  import { LReaction } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  /**
   *
   * [2021/5/26]
   * ----------
   * - 全ての Unit は罠にかかる可能性を持っている。
   * - 仲間 Unit は TrapThrough Trait を持たせて、一切かからないようにしてみる。仲間システム作ったら。
   * - Trap は中立勢力にする。今のところ敵対でも問題ないかもしれないけど、多分中立の方が自然。
   *   - 条件によってはモンスターに対して効果発動することもあるし
   *   - 範囲攻撃巻物の対象外にしやすいし
   *   - ミニマップ表示やりやすいし
   * - Trap は罠にかけたい勢力を持っている (デフォルトは Player)
   * - 罠にかけたい勢力側に TrapMaster がいたら、その敵対勢力を罠にかけるようにする。
   * - 両方の勢力に TrapMaster がいたら、何もしない。
   *
   * [2021/11/14] 罠の発動確率
   * ----------
   * 原作だと、見えない状態と見えている状態で踏んだ時で確率が変わる。
   * またダンジョンによっても変わる。(逃げコンセプトダンジョンなど)
   * 罠によっても変わる？
   * 強化バネやワープポイント、ポイントスイッチは罠に見えるが罠ではない。どちらかというと階段に近いオブジェクト。
   *
   */
  export class LTrapBehavior extends LBehavior {
      private _exposed;
      private _recharging;
      constructor();
      clone(newOwner: LEntity): LBehavior;
      /**
       * 露出しているかどうか。
       * 罠が踏まれたり、空振りや魔法弾の通過で発見された状態で、勢力に関わらず可視である。
       */
      exposed(): boolean;
      isExposedFor(target: LEntity): boolean;
      setExposed(value: boolean): void;
      onQueryReactions(self: LEntity, reactions: LReaction[]): void;
      onAttached(self: LEntity): void;
      onDetached(self: LEntity): void;
      onEvent(cctx: SCommandContext, eventId: DEventId, args: any): LEventResult;
      private checkValidTarget;
      private triggerRate;
      private testTrigger;
      private _launching;
      [onPreStepFeetProcess](e: CommandArgs, cctx: SCommandContext): SCommandResponse;
      [onPerformStepFeetProcess](e: CommandArgs, cctx: SCommandContext): SCommandResponse;
      onActivityReaction(self: LEntity, cctx: SCommandContext, activity: LActivity): SCommandResponse;
      private performTrapEffect;
      onStepEnd(cctx: SCommandContext): SCommandResponse;
      onEffectPerformed(self: LEntity, cctx: SCommandContext, emittor: DEmittor): SCommandResponse;
      onCounterAction(self: LEntity, cctx: SCommandContext, data: DCounterAction): SCommandResponse;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/behaviors/LUnitBehavior' {
  import { SCommandResponse, SPhaseResult } from "MysteryRogueSystem/ts/mr/system/SCommand";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { CommandArgs, LBehavior, onAttackReaction, onWalkedOnTopAction } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { DFactionId } from "ts/mr/data/MRData";
  import { DecisionPhase, onPreStepFeetProcess_Actor } from "MysteryRogueSystem/ts/mr/lively/internal";
  import { DActionId, DBlockLayerKind } from "ts/mr/data/DCommon";
  import { SActivityContext } from "ts/mr/system/SActivityContext";
  import { LReaction } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  /**
   *
   */
  export class LUnitBehavior extends LBehavior {
      private _factionId;
      _speedLevel: number;
      _waitTurnCount: number;
      _manualMovement: boolean;
      _targetingEntityId: number;
      _straightDashing: boolean;
      _fastforwarding: boolean;
      clone(newOwner: LEntity): LBehavior;
      setFactionId(value: DFactionId): LUnitBehavior;
      setSpeedLevel(value: number): LUnitBehavior;
      waitTurnCount(): number;
      setWaitTurnCount(value: number): LUnitBehavior;
      manualMovement(): boolean;
      setManualMovement(value: boolean): LUnitBehavior;
      clearStraightDashing(): void;
      private _requiredFeetProcess;
      private _requiredTrapProcess;
      queryInnermostFactionId(): DFactionId | undefined;
      queryOutwardFactionId(): DFactionId | undefined;
      requiredFeetProcess(): boolean;
      clearFeetProcess(): void;
      requiredTrapProcess(): boolean;
      clearTrapProcess(): void;
      queryHomeLayer(): DBlockLayerKind | undefined;
      onQueryActions(actions: DActionId[]): DActionId[];
      onQueryReactions(self: LEntity, reactions: LReaction[]): void;
      onEffectSensed(self: LEntity, cctx: SCommandContext): SCommandResponse;
      onActivity(self: LEntity, cctx: SCommandContext, actx: SActivityContext): SCommandResponse;
      [onAttackReaction](args: CommandArgs, cctx: SCommandContext): SCommandResponse;
      [onPreStepFeetProcess_Actor](e: CommandArgs, cctx: SCommandContext): SCommandResponse;
      [onWalkedOnTopAction](args: CommandArgs, cctx: SCommandContext): SCommandResponse;
      private judgeFeetProcess;
      onTalk(self: LEntity, cctx: SCommandContext, person: LEntity): SCommandResponse;
      onDecisionPhase(self: LEntity, cctx: SCommandContext, phase: DecisionPhase): SPhaseResult;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/Extensions' {
  global {
      interface Array<T> {
          pushArray(ary: readonly T[]): void;
          mutableResize(newSize: number, defaultValue: T): void;
          mutableRemoveAt(index: number): void;
          mutableRemove(predicate: (x: T) => boolean): boolean;
          mutableRemoveAll(predicate: (x: T) => boolean): boolean;
          mutableShuffle(): void;
          distinct(): Array<T>;
          distinctObjects(key: (x: T) => any): Array<T>;
          immutableSort(compareFn?: (a: T, b: T) => number): Array<T>;
          selectMin(fn: (a: T, b: T) => number): T | undefined;
          count(predicate: (x: T) => boolean): number;
          isEmpty(): boolean;
          front(): T;
          back(): T;
          backOrUndefined(): T | undefined;
          binarySearchIndex(target: T): number;
      }
  }
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/lively/internal' {
  export * from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";

}
declare module 'MysteryRogueSystem/ts/mr/lively/LActionToken' {
  import { LActionTokenConsumeType } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  export enum LActionTokenType {
      Minor = 0,
      Major = 1
  }
  export class LActionToken {
      private _minorActionTokenCount;
      private _majorActionTokenCount;
      clone(): LActionToken;
      clearActionTokenCount(): void;
      canMinorAction(): boolean;
      canMajorAction(): boolean;
      actionCount(): number;
      reset(entity: LEntity, count: number): void;
      charge(count: number): void;
      consume(type: LActionTokenConsumeType): LActionTokenType;
      verify(type: LActionTokenConsumeType): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LBlock' {
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { FBlockComponent } from "ts/mr/floorgen/FMapData";
  import { REBlockLayer } from "MysteryRogueSystem/ts/mr/lively/LBlockLayer";
  import { LRoom } from "MysteryRogueSystem/ts/mr/lively/LRoom";
  import { DBlockLayerKind } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { LRoomId } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  import { DBlockVisualPartIndex } from "MysteryRogueSystem/ts/mr/data/DTemplateMap";
  /** Tile の本質的な形状 */
  export enum LTileShape {
      /** 中空 */
      Void = 0,
      /** 床 */
      Floor = 1,
      /** 壁 */
      Wall = 2,
      /** 壊れない壁 */
      HardWall = 3,
      /** 水路 */
      Water = 4
  }
  export enum LBlockSystemDecoration {
      None = 0,
      ItemShop = 1
  }
  /**
   * GameBlock
   *
   * Block 内の同一レイヤーには、複数の Entity が同時に存在することがありえる。
   * 貫通属性を持ち、複数同時発射されれる Projectile など。（シレン2のかまいたちの矢等）
   */
  export class LBlock {
      private _layers;
      private _mx;
      private _my;
      _roomId: LRoomId;
      _blockComponent: FBlockComponent;
      _continuation: boolean;
      _roomInnerEntrance: boolean;
      _shopkeeperLine: boolean;
      _passed: boolean;
      _tileShape: LTileShape;
      _shapeVisualPartIndex: DBlockVisualPartIndex;
      _decorationVisualPartIndex: DBlockVisualPartIndex;
      _systemDecoration: LBlockSystemDecoration;
      constructor(x: number, y: number);
      /** 絶対座標 X */
      get mx(): number;
      /** 絶対座標 Y */
      get my(): number;
      room(): LRoom | undefined;
      /** 表示用 TileId. 通行判定や部屋内判定に使用するものではない点に注意。 */
      /** 表示用 TileId. 通行判定や部屋内判定に使用するものではない点に注意。 */
      tileShape(): LTileShape;
      get shapeVisualPartIndex(): DBlockVisualPartIndex;
      get decorationVisualPartIndex(): DBlockVisualPartIndex;
      setSystemDecoration(value: LBlockSystemDecoration): void;
      systemDecoration(): LBlockSystemDecoration;
      /** 地面上で、歩行による移動が可能であるか。(中空や水地形ではない) */
      isFloorLikeShape(): boolean;
      isWallLikeShape(): boolean;
      /** 部屋内のブロックであるか */
      isRoom(): boolean;
      /** 通路あるか */
      isPassageway(): boolean;
      isContinuation(): boolean;
      /** 部屋の入口であるか */
      isRoomInnerEntrance(): boolean;
      layers(): readonly REBlockLayer[];
      layer(kind: DBlockLayerKind): REBlockLayer;
      addEntity(layerKind: DBlockLayerKind, entity: LEntity): void;
      removeEntity(entity: LEntity): boolean;
      removeAllEntites(): void;
      aliveEntity(layer: DBlockLayerKind): LEntity | undefined;
      /** Block に含まれている Entity を取得する。 layerKind を指定した場合は、 */
      getEntities(layerKind?: DBlockLayerKind): LEntity[];
      getFirstEntity(layerKind?: DBlockLayerKind): LEntity | undefined;
      /** Entity が含まれている Layer を検索する */
      findEntityLayerKind(entity: LEntity): DBlockLayerKind | undefined;
      /** Entity が含まれている Layer を検索する */
      findEntity(predicate: (entity: LEntity) => boolean): LEntity | undefined;
      /** 指定した Entity がこの Block に含まれているか */
      containsEntity(entity: LEntity): boolean;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LBlockLayer' {
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LEntityId } from "MysteryRogueSystem/ts/mr/lively/LObject";
  export class REBlockLayer {
      private _entityIds;
      constructor();
      entityIds(): readonly LEntityId[];
      entities(): readonly LEntity[];
      firstEntity(): LEntity | undefined;
      isContainsAnyEntity(): boolean;
      isContains(entity: LEntity): boolean;
      isOccupied(): boolean;
      addEntity(entity: LEntity): void;
      removeEntity(entity: LEntity): boolean;
      removeAllEntites(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LCamera' {
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LEntityId } from "MysteryRogueSystem/ts/mr/lively/LObject";
  import { LFloorId } from "MysteryRogueSystem/ts/mr/lively/LFloorId";
  /**
   * 始点位置。ツクールの Game_Player と連携する。
   *
   * ツクールのマップ移動=Game_Player の移動であるように、RE でもマップ移動=Camera の移動、となる。
   *
   *
   * 移動処理の整理
   * ----------
   * まず前提として、すべての Entity は必ず何らかのフロアに属する。
   * これは REシステム管理外のマップへ遷移するときも同様で、例えばプレイヤーキャラクターが REシステム管理外の ワールドマップのようなマップへ移動するとき、
   * ワールドマップを MapId:5 とすると、プレイヤーキャラクターの Entity は FloorId{land:0, floorNumber:5} に存在することとなる。
   *
   * > こうしておかないと、ゲームオーバーなどで強制フロア移動するときに REシステムとしての遷移先が見つからない事態になってしまう。
   *
   * ### 考えられる移動手段の例
   * - [場所移動] イベントコマンドによる、ランダムマップフロアへの移動 (REシステム内外関係なし)
   * - [場所移動] イベントコマンドによる、固定マップフロアへの移動 (REシステム内外関係なし)
   * - [場所移動] イベントコマンドによる、固定マップへの直接移動 (REシステム内外関係なし)
   * - 階段を "降りる" 等のアクションによる、フロア間の移動
   * - "ゲームオーバー" や "脱出の巻物"、"イベント" 等による、別 Land への移動
   * - "ゲームオーバー" や "脱出の巻物"、"イベント" 等による、REシステム管理外のマップへの移動
   *
   *
   * ### フロア移動を伴う場合は、必ず RMMZ 側の [場所移動] を行うようにする
   *
   * つまり $gamePlayer.reserveTransfar() を実行する、ということ。
   *
   * 階段を進むことによるランダムフロア間の移動では RMMZ としてのマップが変わることは無いためマップデータをロードする必要はないのだが、
   * これ以外のケースでは全て RMMZ マップのロードが必要になる。
   * ランダムフロア間の移動は最もメジャーであるが内部処理的にはこれ用に特別な処理が必要になる。でもそれはやめてシンプルにしたい。
   * そのため「フロアを移動するときは RMMZ 側の [場所移動] を行う」とする。
   *
   * ### 処理の流れ
   *
   * 1. $gamePlayer.reserveTransfar() を呼び出す
   *    - REシステム外からは、イベントコマンドの [場所移動] により呼び出される。
   *    - REシステム (特にコマンドチェーン) 内からは、REIntegration.onReserveTransferMap() を経由して呼び出される。
   * 2. RMMZ コアスクリプトの既定の流れでマップ遷移が行われる
   * 3. 既定の Game_Map.setup() 後、performFloorTransfer() で現在の $gameMap や $dataMap を元にフロアを構築する。
   *
   */
  export class LCamera {
      private _focusedEntityId;
      private _transferingNewFloorId;
      private _transferingNewX;
      private _transferingNewY;
      focusedEntityId(): LEntityId;
      /**
       * 現在フォーカスのある Entity を取得します。
       * 取得した Entity は、必ずしも Player ではない点に注意してください。
       * 操作中の Player を取得したい場合は LSystem.mainPlayerEntity を使用してください。
       */
      focusedEntity(): LEntity | undefined;
      getFocusedEntity(): LEntity;
      focus(entity: LEntity): void;
      clearFocus(): void;
      isFloorTransfering(): boolean;
      transferingNewFloorId(): LFloorId;
      _reserveFloorTransferToFocusedEntity(): void;
      private reserveFloorTransfer;
      clearFloorTransfering(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LChallengeResult' {
  /**
   * 冒険の結果。番付データ。
   */

}
declare module 'MysteryRogueSystem/ts/mr/lively/LCommon' {
  import { DActionId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  export type LRoomId = number;
  export type LStructureId = number;
  export interface LPriceInfo {
      sellingPrice: number;
      purchasePrice: number;
  }
  export const phaseCount = 4;
  export enum LMinimapMarkerClass {
      /** 表示なし */
      None = 0,
      /** ユニット。最終的なマーカーは、視点の Entity と勢力によって決まる。 */
      Unit = 1,
      Item = 2,
      Trap = 3,
      ExitPoint = 4
  }
  export enum LActionTokenConsumeType {
      /** MinorAction を実行した。 MinorToken を1つ消費する。 */
      MinorActed = 0,
      /** MajorAction を実行した。 MajorToken を1つ消費する。 */
      MajorActed = 1,
      /** 待機した。Major を優先的に消費する。 */
      WaitActed = 2
  }
  export interface LReaction {
      actionId: DActionId;
      displayName?: string | undefined;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LDeathResult' {
  import { DStateId } from "MysteryRogueSystem/ts/mr/data/DState";
  export class LDeathResult {
      private _states;
      constructor();
      clear(): void;
      clearStates(): void;
      addState(id: DStateId): void;
      states(): readonly DStateId[];
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LEffectResult' {
  import { DState, DStateId } from "ts/mr/data/DState";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { DEffect, DValuePoint } from "MysteryRogueSystem/ts/mr/data/DEffect";
  import { DEntityId } from "MysteryRogueSystem/ts/mr/data/DEntity";
  import { DEffectId, DParameterId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DFactionType as DFactionType } from "MysteryRogueSystem/ts/mr/data/DFaction";
  export class LParamEffectResult {
      paramId: DParameterId;
      damage: number;
      oldValue: number;
      newValue: number;
      drain: boolean;
      applyTarget: DValuePoint;
      constructor(paramId: DParameterId);
      paramDisplayName(): string;
      getValue(entity: LEntity, recover: boolean): number;
  }
  /**
   * 一度の Effect の適用結果。Visual で表示したいコンテンツのソースデータとなる。
   * メッセージに限らず、ポップアップやイメージ表情差分表示など、様々な Visual 表現に必要なすべてのデータを含む。
   */
  export class LEffectResult {
      sourceEffectId: DEffectId | undefined;
      used: boolean;
      missed: boolean;
      evaded: boolean;
      physical: boolean;
      critical: boolean;
      success: boolean;
      hpAffected: boolean;
      paramEffects2: LParamEffectResult[];
      addedStates: DStateId[];
      removedStates: DStateId[];
      addedBuffs: DParameterId[];
      addedDebuffs: DParameterId[];
      removedBuffs: DParameterId[];
      /** @deprecated */
      focusedFriendly: boolean;
      get looksFactionType(): DFactionType;
      /** @deprecated */
      levelup: boolean;
      /** @deprecated */
      leveldown: boolean;
      gainedExp: number;
      instanceChangedFrom: DEntityId | undefined;
      _revision: number;
      _commitedRevision: number;
      _dirty: boolean;
      isHit(): boolean;
      clear(): void;
      clearParamEffects(): void;
      hasResult(): boolean;
      get sourceEffect(): DEffect;
      isStateAdded(stateId: DStateId): boolean;
      pushAddedState(stateId: DStateId): void;
      isStateRemoved(stateId: DStateId): boolean;
      pushRemovedState(stateId: DStateId): void;
      isBuffAdded(paramId: DParameterId): boolean;
      pushAddedBuff(paramId: DParameterId): void;
      isDebuffAdded(paramId: DParameterId): boolean;
      pushAddedDebuff(paramId: DParameterId): void;
      isBuffRemoved(paramId: DParameterId): boolean;
      pushRemovedBuff(paramId: DParameterId): void;
      addedStateObjects(): DState[];
      makeSuccess(): void;
      private shouldShowMessage;
      private refreshRevision;
      showResultMessages(cctx: SCommandContext, entity: LEntity): void;
      private displayParameterFlavorEffect;
      private selectParameterFlavorEffect;
      private meetsConditionParameterFlavorEffect;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LEntity' {
  import { DecisionPhase, LBehavior, LGenerateDropItemCause, LNameView, SRejectionInfo } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { SCommandResponse, SPhaseResult } from "MysteryRogueSystem/ts/mr/system/SCommand";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { DStateId } from "ts/mr/data/DState";
  import { LBehaviorId, LEntityId, LObject } from "MysteryRogueSystem/ts/mr/lively/LObject";
  import { LState, LStateId } from "MysteryRogueSystem/ts/mr/lively/states/LState";
  import { LEffectResult } from "ts/mr/lively/LEffectResult";
  import { LAbility, LAbilityId } from "MysteryRogueSystem/ts/mr/lively/abilities/LAbility";
  import { DAbilityId } from "ts/mr/data/DAbility";
  import { LActivity } from "MysteryRogueSystem/ts/mr/lively/activities/LActivity";
  import { LFloorId } from "MysteryRogueSystem/ts/mr/lively/LFloorId";
  import { LParty, LPartyId } from "MysteryRogueSystem/ts/mr/lively/LParty";
  import { DSParamId, DXParamId } from "ts/mr/data/DParameter";
  import { DFactionId } from "ts/mr/data/MRData";
  import { DEntity, DEntityId } from "ts/mr/data/DEntity";
  import { DPrefabId } from "ts/mr/data/DPrefab";
  import { DEventId } from "ts/mr/data/predefineds/DBasicEvents";
  import { LParamSet } from "MysteryRogueSystem/ts/mr/lively/LParam";
  import { DParamBuff, LStateLevelType } from "ts/mr/data/DEffect";
  import { DSequelId } from "MysteryRogueSystem/ts/mr/data/DSequel";
  import { LReward } from "MysteryRogueSystem/ts/mr/lively/LReward";
  import { DBlockLayerKind, DEntityCategoryId, DSubComponentEffectTargetKey, DRaceId, DActionId, DParameterId, DAnimationId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { LActionToken } from "MysteryRogueSystem/ts/mr/lively/LActionToken";
  import { LMinimapMarkerClass, LPriceInfo, LReaction, LRoomId } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  import { LShopArticle } from "MysteryRogueSystem/ts/mr/lively/LShopArticle";
  import { DEntityCategory } from "MysteryRogueSystem/ts/mr/data/DEntityCategory";
  import { DTraitId } from "MysteryRogueSystem/ts/mr/data/DTraits";
  import { SActivityContext } from "MysteryRogueSystem/ts/mr/system/SActivityContext";
  import { LSchedulingResult } from "MysteryRogueSystem/ts/mr/lively/LSchedulingResult";
  import { LDeathResult } from "MysteryRogueSystem/ts/mr/lively/LDeathResult";
  import { LFieldEffect } from "MysteryRogueSystem/ts/mr/lively/LFieldEffect";
  export interface LParamMinMax {
      min: number;
      max: number;
  }
  export enum LParamChangedAction {
      None = 0,
      WithRefresh = 2,
      WithNotification = 4,
      All = 6
  }
  /**
   * [2021/5/27] 祝福・呪い・封印
   * ----------
   * ### 印にするべきか？
   * シレンタイトルでは 2 だけこのパターン。
   * 印であることを利用した予防やモンスター対策など小技があるが、印を埋めると無害化できるので
   * このパターンはかなりプレイヤーに有利なルールと言える。
   * また性質上、装備品以外は呪い状態にできないのであんまりよくないかも。
   *
   * ### State にするべきか？独立したパラメータにするべきか？
   * これら3ステートは排他なので state にした場合はその上書きや解除の処理が必要になる。
   *
   * また例えば祝福は草など他のアイテム効果を高めるだけでなく、祝福状態自体に「一定確率で呪いを防ぐ」みたいな効果もある。
   * 祝福によるダメージ増加、効果2倍などはそれぞれ 武器、草アイテム Entity 側で、祝福されているかどうかをチェックして対応するべき。
   * でも呪い防止は祝福自体の効果なので、Behavior にするべきだろう。
   * RMMZ の仕組みの上に乗っているのでステート有効度で制御できるようにもなる。
   */
  /**
   * システムを構成する最も原始的な要素。
   * プレイヤー、仲間、モンスター、アイテム、ワナ、地形、飛翔体（矢、魔法弾）などの、状態をもちえるすべての要素のベースクラス。
   *
   * 複数の Attribute や Behavior をアタッチすることで、動作を定義していく。
   *
   * Entity のライフサイクル
   * ----------
   * - インスタンスの作成は newEntity() で行う。
   *   - すべての Entity は必ず World に存在することになる。
   * - 破棄は destroy()。 ※直ちにインスタンスが削除されるのではなく、削除マークが付けられ、後で削除される。
   *
   * @note
   * BlockLayer は種別のような他の情報から求めるべきかもしれないが、Entity によっては固定されることは無い。
   * - アイテム変化するモンスターは自身の種別を変更することになるが、それだと BlockLayer を変更することと変わらない。
   * - アイテムとして持っている土偶を立てたときは、振舞いは Item から Unit に変わる。これも結局状態変更することと変わらない。
   *
   * @note
   * 以前オブジェクトの参照と寿命管理のために LObject をベースクラスとし、Entity だけではなく Map 等もその派生としていたことがあったが、
   * セーブデータ作成や、World から Entity を検索するとき等の書き方が非常に煩雑になってしまったため廃止した。
   *
   *
   *
   * 座標と Map 上への配置状況について
   * ----------
   *
   * 座標 x,y のマイナス値は正当な値。これは、Floor 内には存在しているが Map 上には配置されていない状態を示す。
   * イメージとしては、概念として存在しているが、現実世界に登場していない状態。
   * お店のセキュリティシステムなど、Map 上に存在する必要はないが Floor 内に存在し、影響を与える Entity でこの状態になることがある。
   * また、フロア移動 ～ Map 上へ配置までの間では、通常の Entity も一時的にこの状態になることがある。
   */
  export class LEntity extends LObject {
      private _entityDataId;
      private _params;
      private _basicBehaviors;
      /**
       * この Entity 個体として識別済みであるか。
       */
      private _individualIdentified;
      _partyId: LPartyId;
      constructor();
      setupInstance(entityDataId: DEntityId): void;
      get dataId(): DEntityId;
      get data(): DEntity;
      kindDataId(): DEntityCategoryId;
      kindData(): DEntityCategory;
      entityId(): LEntityId;
      equals(other: LEntity): boolean;
      isGCReady(): boolean;
      _name: string;
      _displayName: string;
      _iconName: string;
      rmmzEventId: number;
      /**
       * 固定マップにおいて、エディタで配置したイベントを元に作られた Entity であるかどうか。
       *
       * 基本的には Database マップの Event をコピーして使いたいが、固定の出口、固定NPC、その他未知の固定イベントの設置は考えられる。
       * 特に固定出口はツクールのエディタから「場所移動」によって遷移先を決めるのに都合がよいため、静的 Event と Entity は関連付けておきたい。
       *
       * 注意点としては、一度 map から離れると静的 Event との関連付けが解除されること。
       * 例えば固定のアイテムが落ちていたとして、それを拾って再び置いたときは、Entity は同一だが異なる動的 Event と関連付けられる。
       * 仮に階段をインベントリに入れてからまた置くと、「場所移動」実行内容が定義されている Event との関連付けが解除されるため、移動ができなくなる。
       * これは現状の仕様とする。
       */
      inhabitsCurrentFloor: boolean;
      keeper: boolean;
      /**
       * Entity が存在しているフロア。
       *
       * 0 は、World には存在しているがいずれの Floor(Map) 上にもいないことを示し、
       * これは通常、別 Entity の Inventory の中にいる状態。
       *
       * 直接変更禁止。transfarMap を使うこと
       */
      floorId: LFloorId;
      mx: number; /**< 論理 X 座標。マップ座標系。マイナス値は正当（クラスコメント参照） */
      my: number; /**< 論理 Y 座標。マップ座標系。マイナス値は正当（クラスコメント参照） */
      dir: number;
      blockOccupied: boolean;
      immediatelyAfterAdjacentMoving: boolean;
      _states: LStateId[];
      _needVisualRefresh: boolean;
      _abilities: LAbilityId[];
      _effectResult: LEffectResult;
      _schedulingResult: LSchedulingResult;
      _deathResult: LDeathResult;
      _reward: LReward;
      _located: boolean;
      _actionToken: LActionToken;
      /**
       * この Entity のクローンを作成し、World に登録する。
       * Behavior, State など子要素もディープクローンされる。
       * クローンは特定の親に属していない状態となるため、このあと直ちにマップ上への配置やインベントリへの追加などを行うこと。
       * そうしなければ GC により削除される。
       */
      clone(): LEntity;
      onFinalize(): void;
      private clearInstance;
      protected onRemoveChild(obj: LObject): void;
      protected onRemoveFromParent(): void;
      parentEntity(): LEntity | undefined;
      isPlayer(): boolean;
      isUnit(): boolean;
      partyId(): LPartyId;
      party(): LParty | undefined;
      individualIdentified(): boolean;
      setIndividualIdentified(value: boolean): void;
      /**
       * すべての状態をリセットする。
       *
       * recoverAll() は buffs 等一部リセットされないものがあるが、このメソッドは全てリセットする。
       * 拠点へ戻ったときなどで完全リセットしたいときに使う。
       */
      resetStatus(): void;
      get params(): LParamSet;
      /**
       * 装備効果やバフが反映された、実際の最大値 （UIの表示やダメージ計算に使用する、一般的な最大値） を取得する。
       * @param paramId
       */
      getParamActualMax(paramId: DParameterId): number;
      getEffortValue(paramId: DParameterId): number;
      setEffortValue(paramId: DParameterId, value: number, action?: LParamChangedAction): void;
      getActualParam(paramId: DParameterId): number;
      /** 直接設定 */
      setParamCurrentValue(paramId: DParameterId, value: number): void;
      private notifyParamIdealPlusChanged;
      private notifyParamChanged;
      private getDependentParameterCurrentValue;
      private setDependentParameterCurrentValue;
      setActualDamgeParam(paramId: DParameterId, value: number): void;
      gainActualParam(paramId: DParameterId, value: number, refresh: boolean): void;
      private resetInitialActualParam;
      refreshConditions(): void;
      addBuff(buff: DParamBuff): void;
      removeBuff(paramId: DParameterId): void;
      allTraits(): IDataTrait[];
      traits(code: number): IDataTrait[];
      hasTrait(code: DTraitId): boolean;
      traitsWithId(code: number, id: number): IDataTrait[];
      traitsPi(code: number, id: number): number;
      traitsSum(code: number, id: number): number;
      traitsSumOrDefault(code: number, id: number, defaultValue: number): number;
      private traitsSumAll;
      private traitsSet;
      xparam(xparamId: DXParamId): number;
      xparamOrDefault(xparamId: DXParamId, defaultValue: number): number;
      sparam(sparamId: DSParamId): number;
      elementRate(elementId: number): number;
      stateRate(stateId: DStateId): number;
      attackElements(): number[];
      fieldEffects(): Generator<LFieldEffect, void, unknown>;
      getDisplayName(): LNameView;
      getPrefabId(): DPrefabId;
      getInnermostFactionId(): DFactionId;
      getOutwardFactionId(): DFactionId;
      getHomeLayer(): DBlockLayerKind;
      queryMinimapMarkerClass(): LMinimapMarkerClass;
      getIdealParamBase(paramId: DParameterId): number;
      querySubEntities(key: DSubComponentEffectTargetKey): LEntity[];
      queryParamMinMax(paramId: DParameterId): LParamMinMax;
      queryPrice(): LPriceInfo;
      queryRaceIds(): readonly DRaceId[];
      getAttackAnimationId(index: number): DAnimationId;
      behavior(name: string): LBehavior | undefined;
      basicBehaviors(): LBehavior[];
      addBehavior<T extends LBehavior>(ctor: {
          new (...args: any[]): T;
      }, ...args: any[]): T;
      _addBehavior(behavior: LBehavior): LBehavior;
      removeBehavior(behavior: LBehavior): void;
      /** 全ての Behavior を除外します。 */
      removeAllBehaviors(): void;
      addState(stateId: DStateId, refresh?: boolean, level?: number, levelType?: LStateLevelType): void;
      states(): readonly LState[];
      isStateAffected(stateId: DStateId): boolean;
      removeStates(stateIds: DStateId[]): void;
      removeState(stateId: DStateId): void;
      /** 全ての State を除外します。 */
      removeAllStates(withoutDeadStates: boolean): void;
      findState(stateId: DStateId): LState | undefined;
      hasState(stateId: DStateId): boolean;
      isBlessed(): boolean;
      isCursed(): boolean;
      isSealed(): boolean;
      isDeathStateAffected(): boolean;
      removeDeadStates(): void;
      isStateAddable(stateId: DStateId): boolean;
      stateResistSet(): DStateId[];
      isStateResist(stateId: DStateId): boolean;
      addAbility(abilityId: DAbilityId): void;
      removeAbility(abilityId: DAbilityId): void;
      removeAllAbilities(): void;
      abilities(): readonly LAbility[];
      /**
       * Entity が存在している場所から除外する。
       *
       * 何らかの Inventory に入っているならそこから、Map 上に出現しているならその Block から除外する。
       * 除外された UniqueEntity 以外の Entity は、そのターンの間にいずれかから参照を得ない場合 GC によって削除される。
       */
      /**
       * 動的に生成した Game_Event が参照する EventData.
       * 頻繁にアクセスされる可能性があるので Attribute ではなくこちらに持たせている。
       */
      /**
       * ゲーム全体にわたって絶対に破棄 (destroy) されることの無い Entity (UniqueEntity) であるかどうか
       *
       * Player や (ダンジョンを抜けても状態を保持する)仲間などが該当する。
       * これらはダンジョン内で倒れてもマップから "除外" されるだけで "破棄" されることはない。
       *
       * UniqueEntity のインベントリに入れられたアイテム等は UniqueEntity ではないので注意。
       */
      isUnique(): boolean;
      /**
       * フォーカスされている Entity であるか。
       *
       * フォーカス=操作中と考えてよい。
       * メッセージ表示時に主語を省略するといった処理で参照する。
       */
      isFocused(): boolean;
      /**
       * Entity が機能を果たせる状態にあるか（破棄準備状態であるか）
       *
       * HP0 となっても直ちに破棄準備状態となるわけではなく、例えば復活草の効果を受けて回復することがある。
       * その他、仮に不死の Entity がいる場合、HP が 0 になろうともマップにとどまる限りは true となるべき。
       *
       * そのためこの値が false の場合は、Entity が完全に機能を停止して World から取り除かれようとしていることを示す。
       * 各種処理で、こういった Entity を存在しないものとして扱うためにこのフラグを確認する。
       */
      isAlive(): boolean;
      /**
       * この Entity に直接アタッチされている Behavior を検索します。
       * State や Ability にアタッチされている Behavior は対象外です。
       */
      findEntityBehavior<T extends LBehavior>(ctor: {
          new (...args: any[]): T;
      }): T | undefined;
      findEntityBehaviorByName(name: string): LBehavior | undefined;
      /**
       * この Entity に直接アタッチされている Behavior を取得します。
       * State や Ability にアタッチされている Behavior は対象外です。
       * 見つからない場合は例外が発生します。
       */
      getEntityBehavior<T extends LBehavior>(ctor: {
          new (...args: any[]): T;
      }): T;
      private _iterateBehaviors;
      queryProperty(propertyId: number): any;
      /**
       * Visual としての Idle 状態での再生 Sequel.
       *
       * 状態異常等で変わる。
       */
      queryIdleSequelId(): DSequelId;
      queryActions(): DActionId[];
      queryReactions(): LReaction[];
      collectTraits(): IDataTrait[];
      collectSkillActions(): IDataAction[];
      queryIdealParameterPlus(paramId: DParameterId): number;
      /** @deprecated  use collectBehaviors*/
      _callBehaviorIterationHelper(func: (b: LBehavior) => SCommandResponse): SCommandResponse;
      /** @deprecated  use collectBehaviors*/
      _callStateIterationHelper(func: (x: LBehavior) => SCommandResponse): SCommandResponse;
      /** @deprecated  use collectBehaviors*/
      static _iterateBehavior<TResult>(behaviorIds: readonly LBehaviorId[], func: (x: LBehavior) => TResult, isContinue: (x: TResult) => boolean): TResult | undefined;
      /** @deprecated  use iterateBehaviors2*/
      iterateBehaviors(func: (b: LBehavior) => void): void;
      iterateStates(func: ((s: LState) => void) | ((s: LState) => boolean)): boolean;
      iterateBehaviors2(func: (b: LBehavior) => boolean): boolean;
      iterateBehaviorsReverse(func: ((b: LBehavior) => void) | ((b: LBehavior) => boolean), fromTraits?: boolean): boolean;
      /** @deprecated iterateBehaviorsReverse */
      collectBehaviors(): LBehavior[];
      _callDecisionPhase(cctx: SCommandContext, phase: DecisionPhase): SPhaseResult;
      _sendActivity(cctx: SCommandContext, actx: SActivityContext): SCommandResponse;
      _sendActivityReaction(cctx: SCommandContext, activity: LActivity): SCommandResponse;
      makeSaveContents(): any;
      extractSaveContents(contents: any): void;
      /**
       * この Entity が GroundLayer 上に存在しているかを確認する。
       * Map 上に出現していても、Ground 以外のレイヤーに存在している場合は false を返す。
       */
      isOnGround(): boolean;
      /** 0 is Invalid. */
      roomId(): LRoomId;
      isOnRoom(): boolean;
      isOnPassageWay(): boolean;
      layer(): DBlockLayerKind;
      /** 特定の座標を持っておらず、Floor へ進入中であるかどうか。Map がロードされた後、EntryPoint へ配置される状態。 */
      isOnOffstage(): boolean;
      /** 現在のマップ上に出現しているか (いずれかの Block 上に存在しているか) */
      isAppearedOnMap(): boolean;
      _dropItemGenerated: boolean;
      generateDropItems(cause: LGenerateDropItemCause): LEntity[];
      recoverAll(): void;
      previewRejection(cctx: SCommandContext, rejection: SRejectionInfo): boolean;
      _shopArticle: LShopArticle;
      sendPartyEvent(eventId: DEventId, args: any): boolean;
      checkLooksLikeItem(): boolean;
      checkLooksLikeGold(): boolean;
      makeDeathResultStates(): void;
      _stackCount: number;
      canStack(): boolean;
      checkStackable(other: LEntity): boolean;
      isStacked(): boolean;
      /**
       * 指定 Entity をスタックに入れ、削除する。
       */
      increaseStack(other: LEntity): void;
      /**
       * スタックを減らして新しい Entity を作成する。
       */
      decreaseStack(): LEntity;
      debugDisplayName(): string;
      get hp(): number;
      get atk(): number;
      get def(): number;
      get agi(): number;
      get fp(): number;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LEventServer' {
  import { DEventId } from "ts/mr/data/predefineds/DBasicEvents";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  export type EventHandler = (args: any) => void;
  export enum LEventResult {
      Pass = 0,
      Handled = 1
  }
  /**
   *
   * Command との違い
   * ----------
   * - Command: 特定の Entity や攻撃対象など、行いたい動作に対して関係者が決まっているメソッドとして使う。
   * - Event: Commandの前後のタイミングを他に通知して、未知の割り込み動作を許可するタイミングとして使う。
   */
  export class LEventServer {
      private _entries;
      subscribe(eventId: DEventId, behavior: LBehavior): void;
      unsubscribe(eventId: DEventId, behavior: LBehavior): void;
      publish(cctx: SCommandContext, eventId: DEventId, args: any): boolean;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LFieldEffect' {
  import { SCommandResponse } from "MysteryRogueSystem/ts/mr/system/SCommand";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  /**
   * マップ上に継続的に何らかの効果を発揮する
   */
  export class LFieldEffect {
      /** 指定座標がこの FieldEffect の影響範囲内であるかを確認する。 */
      onCheckIncludes(mx: number, my: number): boolean;
      /** entity が、指定座標へ歩行による移動ができるか確認する */
      onCheckPossibleMovement(entity: LEntity, mx: number, my: number): boolean;
      onStabilizeSituation(cctx: SCommandContext): SCommandResponse;
  }
  /** 聖域の効果 */
  export class LSanctuaryFieldEffect extends LFieldEffect {
      private _ownerEntityId;
      constructor(owner: LEntity);
      get owner(): LEntity;
      onCheckIncludes(mx: number, my: number): boolean;
      onCheckPossibleMovement(entity: LEntity, mx: number, my: number): boolean;
      onStabilizeSituation(cctx: SCommandContext): SCommandResponse;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LFloorId' {
  import { DFloorClass, DFloorInfo, DLand } from "ts/mr/data/DLand";
  import { DLandId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DMap } from "MysteryRogueSystem/ts/mr/data/DMap";
  import { DFloorPreset } from "MysteryRogueSystem/ts/mr/data/DTerrainPreset";
  /**
   * LandId と フロア番号によってフロアを識別するもの。
   *
   * 初期verでは少々扱いづらかったため全フロアに一意の静的なFloorId を振ることで対策したが、
   * 次のような問題が出てきたため、改めて用意した。
   * - REシステム管理下のすべてのマップは Land 内の Floor として扱った方が都合がよい。
   *   - 例えば固定マップで召喚の罠を踏んだ時の出現エネミーはどこのテーブルからとる？
   * - FloorId を静的なものにしてしまうと、動的な Land 生成に対応しづらくなる。
   *
   * Land 内からの固定マップ遷移について
   * ----------
   * フロアを進んだり直接遷移するときの仕組みは、"Land定義マップの Y=0 へ Player を移動する" に統一する。
   * これによって、
   * - 階段を進んだ時の ProceedFloorForward プラグインコマンド
   * - プレイヤー初期位置指定による遷移
   * - ゲーム中の [場所移動] 空の遷移
   * すべて同じように遷移できる仕組みとする。
   *
   * Player(というかフォーカスのある Entity) の移動処理は、LCamera.reserveFloorTransfer() にすべて流れてくるが、
   * ここで次にロードするマップを選択する。
   * 厳密には
   * - LFloorId.rmmzMapId() で、ロードするべきマップを取得 (ランダムマップならLand定義マップID, 固定マップならそのマップID)
   * - その後、RMMZIntegration 経由で $gamePlayer.reserveTransfer に流して、実際にマップ移動する。
   */
  export class LFloorId {
      /** LandId==DHelpers.RmmzNormalMapLandId は、floorNumber が RMMZ の MapId を直接示すことを表す。 */
      private readonly _landId;
      private readonly _floorClass;
      private readonly _floorNumber;
      constructor(landId: DLandId, floorClass: DFloorClass, floorNumber: number);
      landId(): DLandId;
      landData(): DLand;
      floorNumber(): number;
      get eventMapIndex(): number;
      eventMapData(): DMap;
      get preset(): DFloorPreset;
      isEmpty(): boolean;
      hasAny(): boolean;
      equals(other: LFloorId): boolean;
      clone(): LFloorId;
      static makeEmpty(): LFloorId;
      static make(landId: DLandId, floorClass: DFloorClass, floorNumber: number): LFloorId;
      static makeFromKeys(landKey: string, floorKey: string): LFloorId;
      static makeFromEventMapData(mapData: DMap): LFloorId;
      static makeByRmmzFixedMapName(fixedMapName: string): LFloorId;
      static makeByRmmzNormalMapId(mapId: number): LFloorId;
      floorInfo(): DFloorInfo;
      /** this が示すフロアへ遷移するとなったときに、ロードするべき RMMZ MapId */
      rmmzMapId(): number;
      rmmzFixedMapId(): number;
      isEventMap(): boolean;
      isNormalMap(): boolean;
      isRandomMap(): boolean;
      isFixedMap(): boolean;
      isSafetyMap(): boolean;
      /** Entity を登場させるマップであるか。false の場合は通常の RMMZ マップ。Entity は登場せず、Event を非表示にすることもない。 */
      isTacticsMap(): boolean;
      /** FloorInfo を取ることができるか */
      isDungeonMap(): boolean;
      isRMMZDefaultSystemMap(): boolean;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LIdentifyer' {
  import { DEntityId } from "ts/mr/data/DEntity";
  import { DLand } from "ts/mr/data/DLand";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  export enum DescriptionHighlightColor {
      Identified = 0,
      Unidentified = 1,
      UserIdentified = 2,
      UnitName = 3
  }
  /**
   * LIdentifyer を通して生成される、Entity の説明情報。
   *
   * GUI に表示するものはすべてこのオブジェクトを通さなければならない。
   * Entity の名前を直接表示したり、DItem の情報を直接参照することは禁止。
   *
   * これは未識別アイテムや、アイテムに化けるモンスターを表現するために必要な仕組み。
   */
  export class LEntityDescription {
      private _iconIndex;
      private _name;
      private _highlightLevel;
      private _upgrades;
      private _capacity;
      private static _levelColorTable;
      constructor(iconIndex: number, name: string, level: DescriptionHighlightColor, upgrades: number, capacity: number | undefined);
      iconIndex(): number;
      name(): string;
      displayText(): string;
      private static getColorNumber;
      static makeDisplayText(name: string, level: DescriptionHighlightColor): string;
  }
  export enum EntityIdentificationLevel {
      /** 未識別。 */
      Unidentified = 0,
      /** 種別識別済み。名前が黄色で表示される。説明は見ることができる。修正値や呪いの有無はわからない。 */
      KindIdentified = 1,
      /** 個体識別済み。修正値や説明文も見ることができる。 */
      IndividualIdentified = 2
  }
  /**
   *
   * インスタンスはグローバルで唯一なものとし、必要なタイミングで初期化して使う。
   *
   *
   * 仕様メモ
   * ----------
   *
   * - 新種道具は常に識別済み。
   *
   * - ダンジョン突入時、持っているアイテムは識別済み。
   *
   * - 識別済みは次の２つで現される。
   *      - グローバルな識別済みフラグ: 種類の識別。名前がわかる。
   *      - ローカルな識別済みフラグ: Entity 単位の識別。杖の使用回数がわかる。
   *
   * - いかすしの巻物は、未識別だと [食べる] コマンドが表示されない。
   *
   * [食べる] [読む] などはいつどうやって識別する？
   * ----------
   *
   * コマンド(Activity)の機能として識別するべき？
   * それともアイテム側の機能として「食べられたとき」に識別するべき？
   *
   *
   *
   */
  export class LIdentifyer {
      /** 種別としての識別済みフラグ。undefined の場合、その Entity は常に少なくとも名前は識別済み。 Index: DEntityId */
      private _identificationStates;
      reset(land: DLand): void;
      identifyGlobal(entityDataId: DEntityId): void;
      getEntityIdentificationLevel(viewSubject: LEntity, entity: LEntity): EntityIdentificationLevel;
      resolveDescription(viewSubject: LEntity, entity: LEntity): LEntityDescription;
      checkGlobalIdentified(entity: LEntity): boolean;
      setNickname(dataId: DEntityId, nickname: string): void;
      makeDisplayText(viewSubject: LEntity, entity: LEntity): string;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LJournal' {
  import { LandExitResult } from "MysteryRogueSystem/ts/mr/data/MRData";
  export enum LChallengingStatus {
      None = 0,
      Challenging = 1
  }
  /**
   * ひとつの "冒険" に関する情報を表現するクラス
   *
   * World から Land に入ったときに初期化される。
   * Land 間移動では初期化されない。
   */
  export class LJournal {
      private _status;
      private _exitResult;
      constructor();
      /** 最期の冒険の結果。次の冒険を開始するまでは値は維持される。 */
      get exitResult(): LandExitResult;
      get exitResultSummary(): number;
      /** 冒険の継続中であるか */
      get isChallenging(): boolean;
      /** ゲームオーバーなど、ペナルティを伴う挑戦結果であるか。 */
      get isPenaltyResult(): boolean;
      /** 冒険開始。基本的に拠点での起床時に開始する。拠点マップ(World)に居る時も、冒険中とみなす。（倉庫とかで倒れたりするので） */
      startChallenging(): void;
      /** 冒険終了 */
      finishChallenging(): void;
      /** 何らかの理由で Land から離脱 */
      commitLandResult(result: LandExitResult): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LLand' {
  import { DLand } from "ts/mr/data/DLand";
  import { LIdentifyer } from "MysteryRogueSystem/ts/mr/lively/LIdentifyer";
  export class LLand {
      readonly identifyer: LIdentifyer;
      private _landDataId;
      constructor(landDataId: DLand);
      landData(): DLand;
      maxFloorNumber(): number;
      resetIdentifyer(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LMap' {
  import { LBlock } from "MysteryRogueSystem/ts/mr/lively/LBlock";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { Vector2 } from "ts/mr/math/Vector2";
  import { DFloorInfo } from "ts/mr/data/DLand";
  import { LObject } from "MysteryRogueSystem/ts/mr/lively/LObject";
  import { LRoom } from "MysteryRogueSystem/ts/mr/lively/LRoom";
  import { LStructure } from "MysteryRogueSystem/ts/mr/lively/structures/LStructure";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LFloorId } from "MysteryRogueSystem/ts/mr/lively/LFloorId";
  import { LLand } from "MysteryRogueSystem/ts/mr/lively/LLand";
  import { FMap } from "ts/mr/floorgen/FMapData";
  import { DBlockLayerKind } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { LRoomId } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  export enum MovingMethod {
      Walk = 0,
      Projectile = 1,
      Penetration = 2
  }
  /**
   * アクティブなマップオブジェクト。インスタンスは1つだけ存在する。
   *
   * Map 遷移が行われたとき、World に存在する Entity のうち、
   * この Map 上にいることになっている Entity は、自動的に追加される。
   *
   * このクラスのメソッドによる登場や移動は Sequel を伴わない。そういったものは Command 処理側で対応すること。
   *
   * [2022/2/25] Player をマップ中央に表示するための、外周のマージンはどうやって表現しよう？
   * ----------
   * SFCシレンの場合、大部屋の左上が (4,4) となっており、4ブロック分のマージンがあることがわかる。
   * https://give-up-easily.hatenadiary.org/entry/20120223/1330019652
   * ちょうど1画面分。
   */
  export class LMap extends LObject {
      private _floorId;
      private _width;
      private _height;
      private _blocks;
      private _entityIds;
      private _rooms;
      private _structures;
      private _mapdataRevision;
      private _roundCount;
      unitClarity: boolean;
      itemClarity: boolean;
      trapClarity: boolean;
      sightClarity: boolean;
      keeperCount: number;
      lastKeeperCount: number;
      constructor();
      isGCReady(): boolean;
      setup(floorId: LFloorId, mapData: FMap): void;
      setupForRMMZDefaultMap(floorId: LFloorId): void;
      mapdataRevision(): number;
      increaseRevision(): void;
      roundCount(): number;
      increaseRoundCount(): void;
      private setupEmptyMap;
      private build;
      releaseMap(): void;
      isValid(): boolean;
      floorId(): LFloorId;
      rooms(): readonly LRoom[];
      room(roomId: LRoomId): LRoom;
      get isSingleRoomMap(): boolean;
      structures(): readonly LStructure[];
      land2(): LLand;
      floorData(): DFloorInfo;
      width(): number;
      height(): number;
      blocks(): readonly LBlock[];
      block(x: number, y: number): LBlock;
      block(pos: Vector2, _?: any): LBlock;
      tryGetBlock(x: number, y: number): LBlock | undefined;
      /**
       *
       * distance=0 の時は足元。
       * distance=1 の時は外周1マス。
       */
      getEdgeBlocks(x: number, y: number, distance: number): LBlock[];
      /** "部屋" 内の "床" である Block を取得する */
      roomFloorBlocks(): LBlock[];
      /**
       * NPC や Enemy が出現可能な Block を取得する。
       *
       * - 既に Unit が存在している Block は対象外。
       * - 地続きではない Block も取得する。(堀内部や埋蔵金部屋)
       */
      getSpawnableBlocks(layer: DBlockLayerKind): LBlock[];
      isValidPosition(x: number, y: number): boolean;
      roomId(x: number, y: number): LRoomId;
      roomId(entity: LEntity, _?: any): LRoomId;
      entities(): LEntity[];
      iterateEntities(func: ((b: LEntity) => void) | ((b: LEntity) => boolean), fromTraits?: boolean): boolean;
      /** entity の視界内の Entity を取得する */
      getInsightEntities(subject: LEntity): LEntity[];
      _addEntityInternal(entity: LEntity): void;
      /**
       * Entity を現在の Floor の指定座標に登場させる。
       * @param entity
       * @param x
       * @param y
       * 既に現在の Floor 上に登場済みの Entity に対してこのメソッドを呼び出すと失敗する。
       */
      appearEntity(entity: LEntity, x: number, y: number, layer?: DBlockLayerKind): void;
      _reappearEntity(entity: LEntity): void;
      _removeEntity(entity: LEntity): void;
      _removeAllEntities(): void;
      private _removeEntityHelper;
      onRemoveChild(obj: LObject): void;
      /**
       * 指定した Block へ Entity が侵入できるか。
       */
      canMoveEntering(block: LBlock, entity: LEntity, method: MovingMethod, layer: DBlockLayerKind): boolean;
      canLeaving(block: LBlock, entity: LEntity): boolean;
      checkPassage(entity: LEntity, dir: number, method: MovingMethod, toLayer?: DBlockLayerKind): boolean;
      /** 指定した Entity が、このマップ上に出現しているかを確認する。 */
      checkAppearing(entity: LEntity): boolean;
      updateLocatedResults(cctx: SCommandContext): void;
      /** 足元の Entity を取得する */
      firstFeetEntity(entity: LEntity): LEntity | undefined;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LMessageHistory' {
  export type ChoiceCallback = (n: number) => void;
  /**
   * Game_Message はログ表示という点では機能がマッチしなかったため、独自実装したもの。
   *
   * 前提としてユーザーと "対話" するためのものではないため、
   * Enter 待ちや選択肢の表示といった機能は持たず、ログを流すだけのシステムとなる。
   *
   * そういった対話が必要な場合は、VMessageLogWindow は非表示にして VMessageWindow に切り替えて使うこと。
   * このあたりもそれなりに複雑なので、ひとつのウィンドウにたくさんのことをさせたくない。
   * （実際に原作でも、ログ用ウィンドウと会話用ウィンドウではタイピングの有無などいろいろ差がある）
   */
  export class LMessageHistory {
      private _texts;
      _lastViewLineIndex: number;
      constructor();
      clear(): void;
      add(text: string): void;
      hasText(): boolean;
      texts(): readonly string[];
      includesText(text: string): boolean;
      countIncludesText(text: string): number;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LObject' {
  export class LEntityId {
      private _index;
      private _key;
      constructor(index: number, key: number);
      index2(): number;
      key2(): number;
      isEmpty(): boolean;
      hasAny(): boolean;
      equals(other: LEntityId): boolean;
      clear(): void;
      clone(): LEntityId;
      static makeEmpty(): LEntityId;
      get object(): LObject;
  }
  export type LObjectId = LEntityId;
  export type LBehaviorId = LEntityId;
  export enum LObjectType {
      Entity = 0,
      State = 1,
      Ability = 2,
      Behavior = 3,
      Map = 4
  }
  /**
   * Behavior を保持するクラスのベースクラス
   *
   * [2021/3/14]
   * ----------
   * 現時点では、LEntity, LState, LAbility のベースクラスとなる。
   *
   */
  export class LObject {
      private readonly _objectType;
      private _objectId;
      private _destroyed;
      private _parentObjectId;
      protected constructor(objectType: LObjectType);
      objectType(): LObjectType;
      __objectId(): LObjectId;
      hasId(): boolean;
      _setObjectId(id: LObjectId): void;
      _clearObjectId(): void;
      isUnique(): boolean;
      hasParent(): boolean;
      isGCReady(): boolean;
      /**
       * 親 Object
       *
       * GC のタイミングで、owner がおらず、UniqueEntity や Map に出現している Entity のリストに存在しない Entity は削除される。
       */
      parentObjectId(): LObjectId;
      parentObject(): LObject;
      parentAs<T extends LObject>(ctor: {
          new (...args: any[]): T;
      }): T | undefined;
      setParent(parent: LObject): void;
      clearParent(): void;
      /**
       * Entity が存在している場所から除外する。
       *
       * 何らかの Inventory に入っているならそこから、Map 上に出現しているならその Map から除外する。
       * 除外された UniqueEntity 以外の Entity は、そのターンの間にいずれかから参照を得ない場合 GC によって削除される。
       */
      removeFromParent(): void;
      /** destroy が要求されているか */
      isDestroyed(): boolean;
      /**
       * Behavior から Entity を削除する場合、CommandContext.postDestroy() を使用してください。
       */
      destroy(): void;
      onFinalize(): void;
      behaviorIds(): LBehaviorId[];
      protected onRemoveChild(obj: LObject): void;
      protected onRemoveFromParent(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LParam' {
  import { DParamBuff } from "ts/mr/data/DEffect";
  import { DParameter } from "ts/mr/data/DParameter";
  import { DParameterId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  interface LParamBuff {
      level: number;
      turn: number;
  }
  /**
   * パラメータひとつ分の情報を保持するクラス。
   *
   * コアスクリプトでは Level, Exp, HP, MP, TP は Param ではない。
   * MaxHP, MaxMP は Param である。
   * 例えば「HP の param」は MaxHP のことである。
   *
   * パラメータの仕様
   * ----------
   *
   * -9999 ...  -10                  0                        11                 20            ... 9999
   * +          +....................+------------------------+..................+                 +
   * | . . . .  |                    |                        |                  |     . . . . . . |
   * +          +....................+------------------------+..................+                 +
   *            |<-- --IdealMin -----|-- IdealMax(Base+Effort) -->|
   *                                                              |- Rate&Buff ->|
   *            |<--- ActualMinValue |--------- ActualMaxValue ----------------->|
   *                                                          |<---- Damage -----|
   *                                 |<---- ActualValue ----->|
   * |<---- MinLimit                 |                                                MaxLimit --->|
   *
   *
   * ### MinLimit, MaxLimit (下限値, 上限値)
   * システム上とりえる最小値、最大値。
   * ユニットがどれほど成長・弱体化しても、この範囲を超えることは無い。
   *
   * ### IdealMinValue, IdealMaxValue (基本値の下限値, 基本値の上限値)
   * ユニットのレベルによって変化する値の範囲。
   * IdealMaxValue は、コアスクリプトの paramBasePlus() に該当する。
   * - Base: アクターの場合、レベルによって変化する値。エネミーの場合はエディタで入力された値。
   * - Plus: 装備による追加値 + 成長アイテムによる永続的な追加値。
   *
   * IdealMinValue は一般的には 0 であるが、装備の「つよさ」の最小値はその武器の攻撃力をマイナスにしたものとなる。
   *
   * ### ActualMinValue, ActualMaxValue (実際の下限値, 実際の上限値)
   * ActualMaxValue は コアスクリプトの param() に該当する。IdealMaxValue に対して、Trait等によるボーナスやバフを適用したもの。
   * ActualMinValue は今のところ、IdealMinValue と同じ値である。
   *
   * ### ActualValue
   * ActualMaxValue から Damage を減算したもの。
   * ダメージ計算に用いたり、ステータス画面に表示したりするもの。
   *
   * Refresh タイミング
   * ----------
   * コアスクリプトでは setHP() などで値が変わると、refresh() が呼ばれる。
   * 対して MRシステムでは、EffectContext による一連の処理が終わったタイミングで refresh() が呼ばれる。
   * この refresh 時にステートの付け外しが行われるが、その時にも IdealMaxValue の評価などが毎回行われるため、非常に処理に時間がかかる。
   *
   * ダメージ値は減算方式
   * ----------
   * 現在値は、最大値からダメージ値を減算することで求める。
   * 本システムは atk,def などのすべての基本パラメータは HP と同じように0~最大値の間で変化が起こるようになっているが、
   * 増分計算だと装備品の有無やモンスターの特技、能力の成長アイテムなどで変わるときにその前後の変化量から現在値を調整する処理が必要になり複雑になる。
   *
   * 例えば、HP最大時に薬草アイテムを使って、増えた分の HP だけ現在値を増やす処理。
   * 原作薬草だと 2 増えるが、最大 HP がバフを受けている場合、もっと大きく増える。
   * 最大 HP が増えた時は、HP を全快させるのが自然だろう。
   * しかしそのような処理にすると、例えばちからの最大値だけ増やすアイテムを使った時に、ちからを全快できたりする。
   * 個々のパラメータごとに処理を変えるか、あるいは Effect 側に回復の有無を設定するか… いずれにしても設定が増えることになってしまう。
   *
   * MRシステムはツクール標準と比べて、パラメータシステムがかなり複雑となっている。
   * 加算方式の場合、ただでさえ問題調査が難しくなりがちな副作用に起因した問題が、さらに増えることが予想される。
   *
   * 減算方式のデメリットは、最大HPが減ったときに、現在のダメージ量が新しい最大HPを上回る場合があること。
   * これについては値 0 になることを許可するか、 1 になるように補正する。
   */
  export class LParam {
      readonly parameterId: DParameterId;
      private _damageValue;
      private _effortValue;
      private _buff;
      private _initialActualValue;
      private _constantBuff;
      private _ratioBuff;
      private _damageValueChanged;
      constructor(id: DParameterId);
      reset(): void;
      clone(): LParam;
      get data(): DParameter;
      get isDependent(): boolean;
      get isAllowDamage(): boolean;
      getMinLimit(): number;
      getMaxLimit(): number;
      effortValue(): number;
      setEffortValue(value: number): void;
      gainEffortValue(value: number): void;
      clearEffortValue(): void;
      getIdealMinValue(self: LEntity): number;
      getIdealMaxValue(self: LEntity): number;
      private getIdealMaxBase;
      private getIdealMaxPlus;
      getActualMin(self: LEntity): number;
      getActualMax(self: LEntity): number;
      private idealParamRate;
      private paramBuffRate;
      actualParamDamge(): number;
      get isDamageValueChanged(): boolean;
      clearDamageValueChanged(): void;
      setActualDamgeParam(value: number): void;
      gainActualParam(value: number): void;
      getConstantBuff(): LParamBuff;
      getRatioBuff(): LParamBuff;
      buff(): number;
      buffPlus(): number;
      buffRate(): number;
      clearDamage(owner: LEntity): void;
      resetInitialActualValue(value: number): void;
      initialActualValue(): number;
      addBuff(buff: DParamBuff): void;
      removeBuff(): void;
      updateBuffs(owner: LEntity): void;
  }
  export class LParamSet {
      private _params;
      constructor();
      getMinLimit(parameterId: DParameterId): number;
      getMaxLimit(parameterId: DParameterId): number;
      getIdealMinValue(self: LEntity, parameterId: DParameterId): number;
      getIdealMaxValue(self: LEntity, parameterId: DParameterId): number;
      getActualMin(self: LEntity, parameterId: DParameterId): number;
      getActualMax(self: LEntity, parameterId: DParameterId): number;
      copyTo(other: LParamSet): void;
      clear(): void;
      acquireParam(paramId: DParameterId): LParam;
      resetAllConditions(): void;
      clearParamPlus(): void;
      params(): (LParam | undefined)[];
      param(paramId: DParameterId): LParam | undefined;
      hasParam(paramId: DParameterId): boolean;
      updateBuffs(self: LEntity): void;
      refresh(self: LEntity): void;
  }
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/lively/LParty' {
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { DEventId } from "ts/mr/data/predefineds/DBasicEvents";
  import { LBehavior } from "MysteryRogueSystem/ts/mr/lively/internal";
  import { LJournal } from "MysteryRogueSystem/ts/mr/lively/LJournal";
  import { DLandId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  export type LPartyId = number;
  /**
   * 仲間キャラや、グループで動くモンスターをまとめる仕組み。
   * RMMZ の Party と Troop を合わせたようなもの。
   * member がいなくなると、GC される。
   *
   * Party には Leader が一人いる。
   * Leader がフロア移動すると、Party に属する全員が移動する。
   *
   * Leader ではないメンバーがフロア移動すると、そのメンバーは Party を脱退する。
   *
   * Party は勢力を表すものではない。
   * 仲間が倒されて Party を離脱しても、友好な Unique Entity として World 上には存在し、再び Party に入ることはできる。
   */
  export class LParty {
      private _id;
      private _members;
      private _leaderEntityId;
      readonly journal: LJournal;
      constructor();
      setup(id: LPartyId): void;
      id(): LPartyId;
      isEmpty(): boolean;
      get members(): LEntity[];
      addMember(entity: LEntity): void;
      removeMember(entity: LEntity): void;
      private _entries;
      subscribe(eventId: DEventId, behavior: LBehavior): void;
      unsubscribe(eventId: DEventId, behavior: LBehavior): void;
      send(eventId: DEventId, args: any): boolean;
      /**
       * 挑戦開始。基本的に拠点での起床時に開始する。拠点マップ(World)に居る時も、冒険中とみなす。（倉庫とかで倒れたりするので）
       *
       * 開始後に繰り返し startChallenging() を呼び出しても良いものとする。
       * これは主に、Land に入ったときのステータスリセットなどに使う。
       */
      startChallenging(): void;
      /** 挑戦終了 */
      finishChallenging(): void;
      onMemberMovedLand(member: LEntity, newLandId: DLandId, oldLandId: DLandId): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LRandom' {
  export class LRandom {
      private _x;
      private _y;
      private _z;
      private _w;
      constructor(seed: number);
      resetSeed(seed: number): void;
      nextInt(): number;
      nextIntWithMax(maxValue: number): number;
      nextIntWithMinMax(minValue: number, maxValue: number): number;
      nextIntWithWidth(median: number, width: number): number;
      select<T>(ary: ReadonlyArray<T>): T;
      selectOrUndefined<T>(ary: ReadonlyArray<T>): T | undefined;
      mutableShuffleArray<T>(array: Array<T>): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LReward' {
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  /**
   * 特に経験値はステップ終了時にまとめて取得できる。
   * そういった遅延取得に関係するデータをまとめておくクラス。
   */
  export class LReward {
      private _exp;
      constructor();
      clear(): void;
      exp(): number;
      addExp(value: number): void;
      apply(entity: LEntity): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LRoom' {
  import { FRoom } from "ts/mr/floorgen/FMapData";
  import { LBlock } from "MysteryRogueSystem/ts/mr/lively/LBlock";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  export enum MonsterHouseState {
      Sleeping = 0,
      Activated = 1
  }
  export class LRoom {
      private _roomId;
      private _mx1;
      private _my1;
      private _mx2;
      private _my2;
      private _poorVisibility;
      setup(room: FRoom): void;
      get mx1(): number;
      get my1(): number;
      get mx2(): number;
      get my2(): number;
      get width(): number;
      get height(): number;
      get poorVisibility(): boolean;
      contains(mx: number, my: number): boolean;
      /** 外周1マスも考慮し、mx,my が部屋に含まれているか確認する */
      containsWithEdge(mx: number, my: number): boolean;
      forEachEntities(func: (entity: LEntity) => void): void;
      findEntityInRoom(func: (entity: LEntity) => boolean): LEntity | undefined;
      /** 部屋内の Block を列挙する。 */
      forEachBlocks(func: (block: LBlock) => void): void;
      /** 部屋の外側、外周1タイル分の Block を列挙する */
      forEachEdgeBlocks(func: (block: LBlock) => void): void;
      forEachSightableBlocks(func: (block: LBlock) => void): void;
      /** 部屋の入口 Block リスト。埋蔵金部屋など、入り口が無い場合は空リストを返す。 */
      getRoomInnerEntranceBlocks(): LBlock[];
      /**
       * 指定した Block が、この部屋として有効な視界内にあるかを確認する。
       * (部屋の床タイルと、周囲１マスの壁は有効視界である)
       *
       * @see USearch.checkInSightBlockFromSubject
       */
      checkVisibilityBlock(block: LBlock): boolean;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LScheduler' {
  import { SSchedulerPhase } from "MysteryRogueSystem/ts/mr/system/scheduling/SSchedulerPhase";
  import { LUnitBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LUnitBehavior";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LEntityId } from "MysteryRogueSystem/ts/mr/lively/LObject";
  export type LTOUnitId = number;
  export enum LSchedulerPhase {
      RoundStarting = 0,
      Processing = 1,
      RoundEnding = 2
  }
  export class LSchedulingUnit {
      private _index;
      private _entityId;
      private _unitBehaviorId;
      private _factionId;
      private _iterationCountMax;
      private _iterationCount;
      speedLevel: number;
      speedLevel2: number;
      constructor(index: number, entity: LEntity, unitBehavior: LUnitBehavior);
      index(): number;
      entityId(): LEntityId;
      get entity2(): LEntity;
      entity(): LEntity;
      factionId(): number;
      unitBehavior(): LUnitBehavior;
      calcActionCount(): number;
      isManual(): boolean;
      isActionCompleted(): boolean;
      isValid(): boolean;
      invalidate(): void;
      resetEntity(entity: LEntity): void;
      resetIterationCount(): void;
      iterationCountMax(): number;
      setIterationCountMax(value: number): void;
      remainIterationCount(): number;
      isIterationClosed(): boolean;
      increaseIterationCount(): void;
  }
  export class LScheduler2 {
      chedulerPhase: LSchedulerPhase;
      _schedulingUnits: LSchedulingUnit[];
      nextSearchIndex: number;
      _currentPhaseIndex: number;
      maxRunCount: number;
      currentRunIndex: number;
      private _maxActionCount;
      buildSchedulingUnits(): void;
      schedulingUnits(): readonly LSchedulingUnit[];
      currentPhaseIndex(): number;
      private newUnit;
      static getSpeedLevel(entity: LEntity): number;
      dealActionTokens(): void;
      resetSeek(): void;
      nextUnit(phase: SSchedulerPhase): boolean;
      currentUnit(): LSchedulingUnit;
      isSeeking(): boolean;
      private pick;
      invalidateEntity(entity: LEntity): void;
      resetEntity(entity: LEntity): void;
      hasReadyEntity(): boolean;
      attemptRefreshSpeedLevel(): void;
      existsHighSpeedReadyEntity(subject: LSchedulingUnit): boolean;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LSchedulingResult' {
  import { LActionTokenType } from "MysteryRogueSystem/ts/mr/lively/LActionToken";
  export class LPhaseResult {
      consumedActionToken: LActionTokenType | undefined;
      clear(): void;
  }
  export class LSchedulingResult {
      private _phaseResults;
      constructor();
      clear(): void;
      setConsumedActionToken(phaseIndex: number, type: LActionTokenType): void;
      setConsumedActionTokeInCurrentPhase(type: LActionTokenType): void;
      consumedActionToken(phaseIndex: number): LActionTokenType | undefined;
      private acquirePhaseResult;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LShopArticle' {
  import { LStructureId } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  export class LShopArticle {
      _ownerShopStructureId: LStructureId;
      isSalling(): boolean;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LSystem' {
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LEntityId } from "MysteryRogueSystem/ts/mr/lively/LObject";
  /**
   */
  export class LSystem {
      mainPlayerEntityId: LEntityId;
      uniqueActorUnits: LEntityId[];
      eventInterpreterContextKey: string | undefined;
      constructor();
      get mainPlayerEntity(): LEntity;
      getEventCommandTarget(): LEntity | undefined;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/LWorld' {
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LRandom } from "ts/mr/lively/LRandom";
  import { LEntityId, LObject, LObjectId, LBehaviorId } from "MysteryRogueSystem/ts/mr/lively/LObject";
  import { LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { LAbility, LAbilityId } from "MysteryRogueSystem/ts/mr/lively/abilities/LAbility";
  import { LFloorId } from "MysteryRogueSystem/ts/mr/lively/LFloorId";
  import { LLand } from "MysteryRogueSystem/ts/mr/lively/LLand";
  import { LParty, LPartyId } from "MysteryRogueSystem/ts/mr/lively/LParty";
  import { DEntityId } from "ts/mr/data/DEntity";
  import { DLandId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  /**
   * 1ゲーム内に1インスタンス存在する。
   */
  export class LWorld {
      private _objects;
      private _random;
      private _lands;
      private _parties;
      constructor();
      object(id: LObjectId): LObject;
      findObject(id: LObjectId): LObject | undefined;
      iterateEntity(func: ((x: LEntity) => void) | ((x: LEntity) => boolean)): void;
      findEntity(id: LEntityId): LEntity | undefined;
      findFirstEntity(func: (entity: LEntity) => boolean): LEntity | undefined;
      getFirstEntityByKey(key: string): LEntity;
      findBehavior(id: LBehaviorId): LBehavior | undefined;
      objects(): (LObject | undefined)[];
      entity(id: LObjectId): LEntity;
      behavior(id: LBehaviorId): LBehavior;
      entityByIndex(index: number): LEntity;
      ability(id: LAbilityId): LAbility;
      random(): LRandom;
      land(landId: DLandId): LLand;
      party(partyId: LPartyId): LParty;
      /**
       * 新しい Entity を World 内に生成する。
       *
       * 生成された Entity はいずれの Floor にも属さない状態となっている。
       * 出現させるには transfarEntity() を呼び出す必要がある。
       */
      spawnEntity(entityDataId: DEntityId): LEntity;
      /**
       * インスタンスを作成し、World に登録する。
       * この後、何らかの親オブジェクトに属さない場合、GC で削除される。
       */
      spawn<T extends LObject>(ctor: {
          new (...args: any[]): T;
      }): T;
      newParty(): LParty;
      _registerObject(obj: LObject): void;
      /**
       * Entity を指定した位置に移動する。
       * - 現在表示中のマップへ移動した場合、そのマップへ登場する。
       *   - 移動先の同一 BlockLayer に別の Entity がいた場合、移動は失敗する。
       * - 表示中以外のマップ(固定マップ)へ移動した場合、
       *   - 移動先の同一 BlockLayer に別の Entity がいた場合、移動は失敗する。
       *
       * 直ちに座標を変更するため、コマンドチェーン実行内からの呼び出しは禁止。
       * CommandContext.postTransferFloor() を使うこと。
       *
       * このメソッドで移動しても、足元に対するアクションは行わない。(罠を踏んだり、アイテムを拾ったりしない)
       *
       * mx, my は省略可能。これは、未ロードのランダムマップへの遷移時に使用する。
       */
      transferEntity(entity: LEntity, floorId: LFloorId, mx?: number, my?: number): boolean;
      _removeDestroyedObjects(): void;
      getEntityByRmmzActorId(rmmzActorId: number): LEntity;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/MRGameExtension' {
  export class MRGameExtension {
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/MRLively' {
  import { LMap } from "MysteryRogueSystem/ts/mr/lively/LMap";
  import { LWorld } from "MysteryRogueSystem/ts/mr/lively/LWorld";
  import { LSystem } from "MysteryRogueSystem/ts/mr/lively/LSystem";
  import { LCamera } from "MysteryRogueSystem/ts/mr/lively/LCamera";
  import { SActivityRecorder } from "ts/mr/system/SActivityRecorder";
  import { LMessageHistory } from "MysteryRogueSystem/ts/mr/lively/LMessageHistory";
  import { LIdentifyer } from "MysteryRogueSystem/ts/mr/lively/LIdentifyer";
  import { SSequelSet } from "MysteryRogueSystem/ts/mr/system/SSequel";
  import { SImmediatelyCommandExecuteScheduler } from "ts/mr/system/SImmediatelyCommandExecuteScheduler";
  import { LEventServer } from "MysteryRogueSystem/ts/mr/lively/LEventServer";
  import { LBlock } from "MysteryRogueSystem/ts/mr/lively/LBlock";
  import { LScheduler2 } from "MysteryRogueSystem/ts/mr/lively/LScheduler";
  import { MRGameExtension } from "MysteryRogueSystem/ts/mr/lively/MRGameExtension";
  import { LLand } from "MysteryRogueSystem/ts/mr/lively/LLand";
  /**
   * 各 REGame_* インスタンスを保持する。
   *
   * コアスクリプトの $game* と同じ役割。
   */
  export class MRLively {
      static readonly TILE_LAYER_COUNT: number;
      static ext: MRGameExtension;
      static immediatelyCommandExecuteScheduler: SImmediatelyCommandExecuteScheduler;
      static system: LSystem;
      static world: LWorld;
      static map: LMap;
      static camera: LCamera;
      static scheduler: LScheduler2;
      static recorder: SActivityRecorder;
      static messageHistory: LMessageHistory;
      static eventServer: LEventServer;
      static challengeResultShowing: boolean;
      static borderWall: LBlock;
      /**  */
      static signalFlushSequelSet: ((sequelSet: SSequelSet) => void) | undefined;
      static getCurrentLand(): LLand;
      static getCurrentIdentifyer(): LIdentifyer;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/states/LDebugMoveRight' {
  import { DecisionPhase, LBehavior } from "ts/mr/lively/behaviors/LBehavior";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SPhaseResult } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  export class LDebugMoveRightBehavior extends LBehavior {
      clone(newOwner: LEntity): LBehavior;
      onDecisionPhase(self: LEntity, cctx: SCommandContext, phase: DecisionPhase): SPhaseResult;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/states/LGenericRMMZStateBehavior' {
  import { SCommandResponse, SPhaseResult } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { DecisionPhase, LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LActivity } from "MysteryRogueSystem/ts/mr/lively/activities/LActivity";
  import { DSequelId } from "ts/mr/data/DSequel";
  import { SActivityContext } from "ts/mr/system/SActivityContext";
  export class LGenericRMMZStateBehavior extends LBehavior {
      _stateTurn: number | null;
      private _characterAI;
      constructor();
      clone(newOwner: LEntity): LBehavior;
      private isStateExpired;
      private resetStateCounts;
      private updateStateTurns;
      private removeStatesAuto;
      private state;
      private stateData;
      private stateEffect;
      onAttached(self: LEntity): void;
      onDetached(self: LEntity): void;
      onQueryIdleSequelId(): DSequelId;
      onDecisionPhase(self: LEntity, cctx: SCommandContext, phase: DecisionPhase): SPhaseResult;
      onActivity(self: LEntity, cctx: SCommandContext, actx: SActivityContext): SCommandResponse;
      onPreprocessActivity(cctx: SCommandContext, activity: LActivity): LActivity;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/states/LIllusionStateBehavior' {
  import { SPhaseResult } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { DecisionPhase, LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  export class LIllusionStateBehavior extends LBehavior {
      private _characterAI;
      constructor();
      clone(newOwner: LEntity): LBehavior;
      onDecisionPhase(self: LEntity, cctx: SCommandContext, phase: DecisionPhase): SPhaseResult;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/states/LItemStandingState' {
  import { LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { DBlockLayerKind } from "ts/mr/data/DCommon";
  export class LItemStandingBehavior extends LBehavior {
      clone(newOwner: LEntity): LBehavior;
      queryHomeLayer(): DBlockLayerKind | undefined;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/states/LNapStateBehavior' {
  import { DEventId } from "ts/mr/data/predefineds/DBasicEvents";
  import { SPhaseResult } from "ts/mr/system/SCommand";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { DecisionPhase, LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LEventResult } from "MysteryRogueSystem/ts/mr/lively/LEventServer";
  import { DSequelId } from "ts/mr/data/DSequel";
  export class LNapStateBehavior extends LBehavior {
      private _getUpReserved;
      clone(newOwner: LEntity): LBehavior;
      onAttached(self: LEntity): void;
      onDetached(self: LEntity): void;
      onEvent(cctx: SCommandContext, eventId: DEventId, args: any): LEventResult;
      private attemptReserveGetUp;
      onQueryIdleSequelId(): DSequelId;
      onDecisionPhase(self: LEntity, cctx: SCommandContext, phase: DecisionPhase): SPhaseResult;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/states/LState' {
  import { DState, DStateEffect, DStateId } from "ts/mr/data/DState";
  import { SCommandResponse } from "ts/mr/system/SCommand";
  import { LBehaviorId, LObject, LObjectId } from "MysteryRogueSystem/ts/mr/lively/LObject";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBehavior";
  import { DParameterId } from "ts/mr/data/DCommon";
  export type LStateId = LObjectId;
  /**
   * Entity に着脱するステートの単位。
   *
   * RE において State とは、StateBehavior をグループ化するもの。
   * StateBehavior は仮眠、鈍足など具体的な処理を定義する。
   *
   * グループ化の仕組みにより、例えば "透視状態になるがハラヘリ速度が倍になる" といった
   * カスタマイズを施しやすくなる。
   *
   * 振舞いは Ability と非常によく似ているが、State は RMMZ のステートと同じく状態異常を主に表すものであり、
   * 特徴的なところだと "全快" するアイテムやイベントによってすべてでタッチされたりする。
   */
  export class LState extends LObject {
      _stateId: DStateId;
      _submatchEffectIndex: number;
      _stateBehabiors: LBehaviorId[];
      _level: number;
      constructor();
      clone(newOwner: LEntity): LState;
      setup(stateId: DStateId): void;
      id(): LStateId;
      stateDataId(): DStateId;
      stateData(): DState;
      get isDeathState(): boolean;
      stateEffect(): DStateEffect;
      submatchEffectIndex(): number;
      stateBehabiors(): readonly LBehavior[];
      behaviorIds(): LBehaviorId[];
      level(): number;
      setLevel(value: number): void;
      /** 全ての Behavior を除外します。 */
      removeAllBehaviors(): void;
      recast(): void;
      onAttached(self: LEntity): void;
      onDetached(self: LEntity): void;
      removeThisState(): void;
      collectTraits(self: LEntity, result: IDataTrait[]): void;
      iterateBehaviors(func: ((b: LBehavior) => void) | ((b: LBehavior) => boolean)): boolean;
      _callStateIterationHelper(func: (x: LBehavior) => SCommandResponse): SCommandResponse;
      checkRemoveAtDamageTesting(paramId: DParameterId): boolean;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/structures/LItemShopStructure' {
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LStructure } from "MysteryRogueSystem/ts/mr/lively/structures/LStructure";
  import { DItemShopTypeId } from "ts/mr/data/DItemShop";
  import { DFactionId } from "ts/mr/data/MRData";
  import { LRoomId } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  export class LShopEntrance {
      private _index;
      private _homeX;
      private _homeY;
      private _gateX;
      private _gateY;
      constructor(index: number);
      setup(homeX: number, homeY: number, gateX: number, gateY: number): void;
      index(): number;
      homeX(): number;
      homeY(): number;
      gateX(): number;
      gateY(): number;
  }
  export class LItemShopStructure extends LStructure {
      private _roomId;
      private _itemShopTypeId;
      private _sellngItems;
      private _gates;
      setup(roomId: LRoomId, itemShopTypeId: DItemShopTypeId): void;
      roomId(): LRoomId;
      itemShopTypeId(): DItemShopTypeId;
      clientFaction(): DFactionId;
      addShopEntrance(homeX: number, homeY: number, gateX: number, gateY: number): LShopEntrance;
      shopEntrance(shopkeeperIndex: number): LShopEntrance;
      getLossItems(): LEntity[];
      setInitialItems(items: LEntity[]): void;
      getBillingPrice(): number;
      getDepositPriece(): number;
      commitBilling(): void;
      checkBilling(): boolean;
      updateSecuritySystemState(): void;
      onEntityLocated(cctx: SCommandContext, entity: LEntity): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/structures/LMonsterHouseStructure' {
  import { DMonsterHouseType, DMonsterHouseTypeId } from "ts/mr/data/DMonsterHouse";
  import { DFactionId } from "ts/mr/data/MRData";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LRoom, MonsterHouseState } from "MysteryRogueSystem/ts/mr/lively/LRoom";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LStructure } from "MysteryRogueSystem/ts/mr/lively/structures/LStructure";
  import { LRoomId } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  export class LMonsterHouseStructure extends LStructure {
      private _roomId;
      private _monsterHouseTypeId;
      private _monsterHouseFactionId;
      private _monsterHouseState;
      setup(roomId: LRoomId, monsterHouseTypeId: DMonsterHouseTypeId): void;
      roomId(): LRoomId;
      get room(): LRoom;
      monsterHouseTypeId(): DMonsterHouseTypeId;
      monsterHouseData(): DMonsterHouseType;
      monsterHouseFactionId(): DFactionId;
      monsterHouseState(): MonsterHouseState;
      startMonsterHouse(cctx: SCommandContext): void;
      onEntityLocated(cctx: SCommandContext, entity: LEntity): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/lively/structures/LStructure' {
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { LStructureId } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  export class LStructure {
      _id: LStructureId;
      constructor(id: LStructureId);
      id(): LStructureId;
      onEntityLocated(cctx: SCommandContext, entity: LEntity): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/math/Math' {
  /**
   * 補間関数の定義。
   * 各関数の引数は、t:現在時間(0.0～d) b:開始値 c:値の変化量 (目標値-開始値) d:変化にかける時間。
   */
  export function linear(t: number, b: number, c: number, d: number): number;

}
declare module 'MysteryRogueSystem/ts/mr/math/Noise' {
  export class PerlinNoise {
      private perm;
      private gradP;
      constructor(seed: number | undefined);
      noise2D(x: number, y: number): number;
      private fade;
      private lerp;
  }
  export class SimplexNoise {
      private perm;
      private gradP;
      constructor(seed: number | undefined);
      noise2D(xin: number, yin: number): number;
  }

}
declare module 'MysteryRogueSystem/ts/mr/math/Vector2' {
  export class Vector2 {
      x: number;
      y: number;
      constructor(x?: number, y?: number);
      static clone(value: Vector2): Vector2;
      static add(a: Vector2, b: number): Vector2;
      static add(a: Vector2, b: Vector2): Vector2;
      static sub(a: Vector2, b: number): Vector2;
      static sub(a: Vector2, b: Vector2): Vector2;
      static mul(a: Vector2, b: number): Vector2;
      static mul(a: Vector2, b: Vector2): Vector2;
      static div(a: Vector2, b: number): Vector2;
      static div(a: Vector2, b: Vector2): Vector2;
      static sign(value: Vector2): Vector2;
  }

}
declare module 'MysteryRogueSystem/ts/mr/PluginParameters' {
  export var paramFixedMapRoomRegionId: number;
  export var paramFixedMapMonsterHouseRoomRegionId: number;
  export var paramFixedMapItemShopRoomRegionId: number;
  export var paramFixedMapPassagewayRegionId: number;
  export var paramRandomMapDefaultWidth: number;
  export var paramRandomMapDefaultHeight: number;
  export var paramEnemySpawnInvalidArea: number;
  export var paramPowerToAtk: boolean;
  export var paramHiddenTrapTriggerRate: number;
  export var paramExposedTrapTriggerRate: number;
  export var paraIndirectPhysicalHitRate: number;
  export var paramMaxEntityStackCount: number;
  export var paramFPLoss: number;
  export var paramMaxUnitsInMap: number;
  export var paramMaxItemsInMap: number;
  export var paramMaxTrapsInMap: number;
  export var paramMonsterHouseEnemiesMax: number;
  export var paramMonsterHouseEnemiesMin: number;
  export var paramMonsterHouseItemsMax: number;
  export var paramMonsterHouseItemsMin: number;
  export var paramDefaultVisibiltyLength: number;
  export var paramRandomMapPaddingX: number;
  export var paramRandomMapPaddingY: number;
  export var paramThrowingDistance: number;
  export var paramSuspendMenuEnabled: boolean;
  export const paramInventoryCapacity: number;
  export const paramInventoryItemsPerPage: number;

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/DataManager' {
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/FloorRestartSequence' {
  export class FloorRestartSequence {
      private static _step;
      static isProcessing(): boolean;
      static update(scene: Scene_Map): void;
      static onLoadSuccess(scene: Scene_Map): void;
      static onLoadFailure(scene: Scene_Map): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Game_CharacterBase' {
  import { DColorIndex } from "MysteryRogueSystem/ts/mr/data/DCommon";
  export interface PopupDamageInfo {
      value: number;
      color: DColorIndex;
  }
  global {
      interface Game_CharacterBase {
          _reRevision: number;
          isREEvent(): boolean;
          isREPrefab(): boolean;
          isRESpritePrepared(): boolean;
          isREExtinct(): boolean;
          increaseRERevision(): void;
          reRevision(): number;
          _popupDamages_RE: PopupDamageInfo[] | undefined;
          popupDamage_RE(value: number, color: DColorIndex): void;
          isDamagePopupRequested_RE(): boolean;
          clearDamagePopup_RE(): void;
          shiftDamageInfo_RE(): PopupDamageInfo;
      }
  }

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Game_Event' {
  import { RmmzREEventAttribute } from "MysteryRogueSystem/ts/mr/data/importers/DAttributeReader";
  import { DPrefab, DPrefabId } from "MysteryRogueSystem/ts/mr/data/DPrefab";
  global {
      interface Game_Event {
          _isREEntity: boolean;
          _reEventData: RmmzREEventAttribute | undefined;
          _spritePrepared_RE: boolean;
          _prefabId_RE: DPrefabId;
          _eventData_RE: IDataMapEvent | undefined;
          _pageData_RE: (RmmzREEventAttribute | undefined)[];
          setupPrefab(prefab: DPrefab, mapId: number, eventData: IDataMapEvent): void;
          resetPrefab(prefab: DPrefab): void;
          isREEntity(): boolean;
          isREEvent(): boolean;
          isREPrefab(): boolean;
          isREExtinct(): boolean;
          isRESpritePrepared(): boolean;
          setSpritePrepared(value: boolean): void;
      }
  }

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Game_Interpreter' {
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Game_Map' {
  global {
      interface Game_Map {
          unlinkREEvents(): void;
      }
  }
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Game_Message' {
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Game_Party' {
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Game_Player' {
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/JsonEx' {
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/PluginCommands' {
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/PrefabEvent' {
  /**
   * RE用動的スプライトのライフサイクル
   * ----------
   * Entity が削除されても、動的に作成された REEvent 及び対応する CharacterSprite は
   * 非表示になるだけで、削除されることは無い。
   * 新たな Entity が作成されると、これが再利用される。
   *
   * REEvent は通常の Event と同じ更新処理を適用したいため、$gameMap.events で管理される。
   * REEvent のインスタンス削除が発生すれば当然このリストからも取り除く必要があるが、
   * そうすると取り除いた箇所の index が undefined になってしまう。
   * コアスクリプトはそのような状態を想定していないためクラッシュする。
   */
  import { DPrefab } from "MysteryRogueSystem/ts/mr/data/DPrefab";
  global {
      interface Game_Map {
          getREPrefabEvents(): Game_CharacterBase[];
          spawnREEvent(prefab: DPrefab, resetEventId: number | undefined, overrideEventData: IDataMapEvent | undefined): Game_Event;
      }
  }
  global {
      interface Spriteset_Map {
          _prefabSpriteIdRE: number;
          updateREPrefabEvent(): void;
          makeREPrefabEventSprite(event: Game_Event): void;
      }
  }

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/RMMZHelper' {
  export class RMMZHelper {
      static isRESystemMap(): boolean;
      static setRegionId(x: number, y: number, regionId: number): void;
      static setRETileData(x: number, y: number, z: number, value: number): void;
      static _autoTileTable: number[];
      static mapAutoTileId(dirBits: number): number;
      static syncCameraPositionToGamePlayer(): void;
      static triggerOnStartEvent(): void;
      static triggerOnKeeperLostEvent(): void;
      static setVariable(pattern: string, value: any): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/RMMZIntegration' {
  import { LandExitResult } from "MysteryRogueSystem/ts/mr/data/MRData";
  import { FMap } from "MysteryRogueSystem/ts/mr/floorgen/FMapData";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { SSequelSet } from "MysteryRogueSystem/ts/mr/system/SSequel";
  import { SIntegration } from "MysteryRogueSystem/ts/mr/system/SIntegration";
  import { LMap } from "ts/mr/lively/LMap";
  import { SDialogContext } from "ts/mr/system/SDialogContext";
  import { SDialog } from "ts/mr/system/SDialog";
  import { LBlock } from "ts/mr/lively/LBlock";
  import { DEventId } from "ts/mr/data/predefineds/DBasicEvents";
  export class RMMZIntegration extends SIntegration {
      onEventPublished(eventId: DEventId, args: any, handled: boolean): void;
      onReserveTransferMap(mapId: number, x: number, y: number, d: number): void;
      onEntityLocated(entity: LEntity): void;
      onLocateRmmzEvent(eventId: number, x: number, y: number): void;
      onLoadFixedMapData(map: FMap): void;
      onLoadFixedMapEvents(): void;
      onUpdateBlock(block: LBlock): void;
      onRefreshGameMap(map: LMap): void;
      onFlushEffectResult(entity: LEntity): void;
      onFlushSequelSet(sequelSet: SSequelSet): void;
      onCheckVisualSequelRunning(): boolean;
      onOpenDialog(model: SDialog): void;
      onUpdateDialog(context: SDialogContext): void;
      onDialogClosed(context: SDialogContext, dialog: SDialog): void;
      onEntityEnteredMap(entity: LEntity): void;
      onEntityLeavedMap(entity: LEntity): void;
      onEntityReEnterMap(entity: LEntity): void;
      onSetLandExitResult(result: LandExitResult): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Scene_Boot' {
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Scene_Load' {
  const _Scene_Load_onLoadSuccess: () => void;

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Scene_Map' {
  global {
      interface Scene_Map {
      }
  }
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Scene_RogueDungeon' {
  class Scene_RogueDungeon extends Scene_Base {
      start(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Scene_Save' {
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Scene_Title' {
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Scene_Warehouse' {

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Spriteset_Base' {
  import { VFloatingAnimationTargetSprite } from "MysteryRogueSystem/ts/mr/view/sprites/VFloatingAnimationSprite";
  global {
      interface Spriteset_Base {
          _mrFloatingAnimationSprites: VFloatingAnimationTargetSprite[];
          createMRFloatingAnimationSprite(animation: IDataAnimation, x: number, y: number): void;
      }
  }

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Spriteset_Map' {
  global {
      interface Spriteset_Map {
          createVisibilityShadowPart(frame: number, anchorX: number, anchorY: number): Sprite;
      }
  }
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Sprite_Character' {
  import { REVisual_Entity } from "ts/mr/view/REVisual_Entity";
  import { VCharacterSpriteSet } from "ts/mr/view/VCharacterSpriteSet";
  import { Sprite_CharacterDamage_RE } from "MysteryRogueSystem/ts/mr/rmmz/Sprite_CharacterDamage_RE";
  global {
      interface Sprite_Character {
          _spriteSet: VCharacterSpriteSet | undefined;
          _spriteIndex: number;
          _stateIconSprite: Sprite;
          _stateIcons: number[];
          _reRevision: number;
          setStateIcons(icons: number[]): void;
          endAllEffect(): void;
          removeREPrefabEventSprite(index: number): void;
          findVisual(): REVisual_Entity | undefined;
          _damageSprites_RE: Sprite_CharacterDamage_RE[];
          updateDamagePopup_RE(): void;
          attemtSetupDamagePopup_RE(): void;
          setupDamagePopupFlash_RE(): void;
          damageOffsetX_RE(): number;
          damageOffsetY_RE(): number;
          getPopupParent_RE(): PIXI.Container;
      }
  }

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Sprite_CharacterDamage_RE' {
  export class Sprite_CharacterDamage_RE extends Sprite_Damage {
      setupCharacter(character: Game_CharacterBase): void;
      updateChild(sprite: Sprite): void;
      private easeOutExpo;
  }

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/StorageManager' {
  export class RmmzStorageManager {
      static ensureSaveDirectory(): void;
      static fileDirectoryPath(): string;
  }

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Tilemap' {
  export enum TilemapRendererId {
      Default = 0,
      Minimap = 2
  }
  global {
      interface Tilemap {
          setRendererId(id: number): void;
          _lowerLayer: Tilemap.Layer;
          selfVisible: boolean;
      }
      namespace Tilemap {
          interface Layer {
              _rendererId: TilemapRendererId;
              _images: Bitmap[];
          }
      }
  }

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/VMapEditor' {
  import { LMap } from "ts/mr/lively/LMap";
  import { LBlock } from "ts/mr/lively/LBlock";
  /**
   * RE Core 側で生成されたマップ (ランダムマップ) を、RMMZ 側のマップデータに反映する。
   */
  export class VMapEditor {
      private _coreMap;
      private _templateMap;
      constructor(coreMap: LMap);
      build(): void;
      refreshBlock(block: LBlock): void;
      private putPart;
      private width;
      private height;
      private isValidPos;
      private tileId;
      private setTileId;
      private putAutoTile;
      private refreshAutoTile;
      private getAutotileShape;
      private getSameKindTile;
  }

}
declare module 'MysteryRogueSystem/ts/mr/rmmz/Window_MapName' {
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/system/dialogs/SActivityPlaybackDialog' {
  import { SDialog } from "ts/mr/system/SDialog";
  import { SDialogContext } from "ts/mr/system/SDialogContext";
  /**
   * Playback 中に他の Dialog の代用となる特殊な Dialog.
   */
  export class SActivityPlaybackDialog extends SDialog {
      isVisualIntegration(): boolean;
      onUpdate(context: SDialogContext): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/dialogs/SCommonCommand' {
  import { DActionId } from "ts/mr/data/DCommon";
  import { LInventoryBehavior } from "ts/mr/lively/behaviors/LInventoryBehavior";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SDialog } from "MysteryRogueSystem/ts/mr/system/SDialog";
  export class SCommonCommand {
      static handleAction(dialog: SDialog, actor: LEntity, inventory: LInventoryBehavior, item: LEntity, actionId: DActionId): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/dialogs/SDetailsDialog' {
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SDialog } from "MysteryRogueSystem/ts/mr/system/SDialog";
  export class SDetailsDialog extends SDialog {
      private _entity;
      constructor(entity: LEntity);
      entity(): LEntity;
      get summary(): string;
      get description(): string;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/dialogs/SDialogCommand' {
  import { DActionId } from "ts/mr/data/DCommon";
  export type SActivityCommandHandler = (actionId: DActionId) => void;
  export type SSystemCommandHandler = (commandId: string) => void;
  /**
   * UI のコマンドリストなどに表示するアクションアイテム。
   * QAction のようなもの。
   */
  export class SDialogCommand {
      private _displayName;
      private _actionId;
      private _activityCommandHandler;
      private _systemCommandId;
      private _systemCommandIdHandler;
      static makeActivityCommand(actionId: DActionId, displayName: string | undefined, handler: SActivityCommandHandler): SDialogCommand;
      static makeSystemCommand(displayName: string, systemCommandId: string, handler: SSystemCommandHandler): SDialogCommand;
      private constructor();
      get displayName(): string;
      get isActivityCommand(): boolean;
      get actionId(): DActionId;
      get activityCommandHandler(): SActivityCommandHandler;
      get isSystemCommand(): boolean;
      get systemCommandId(): string;
      get systemCommandIdHandler(): SSystemCommandHandler;
      execute(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/dialogs/SEventExecutionDialog' {
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SDialog } from "ts/mr/system/SDialog";
  import { SDialogContext } from "ts/mr/system/SDialogContext";
  export class SEventExecutionDialog extends SDialog {
      private _rmmzEventId;
      billingPrice: number;
      depositPrice: number;
      owner: LEntity;
      constructor(rmmzEventId: number, owner: LEntity);
      rmmzEventId(): number;
      onUpdate(context: SDialogContext): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/dialogs/SFeetDialog' {
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SDialog } from "MysteryRogueSystem/ts/mr/system/SDialog";
  import { SDialogCommand } from "MysteryRogueSystem/ts/mr/system/dialogs/SDialogCommand";
  export class SFeetDialog extends SDialog {
      private _actorEntityId;
      private _itemEntityId;
      constructor(actorEntity: LEntity, targetEntity: LEntity);
      get actor(): LEntity;
      get item(): LEntity;
      makeActionList(): SDialogCommand[];
      private handleAction;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/dialogs/SItemListDialog' {
  import { LInventoryBehavior } from "ts/mr/lively/behaviors/LInventoryBehavior";
  import { LReaction } from "ts/mr/lively/LCommon";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SDialog } from "MysteryRogueSystem/ts/mr/system/SDialog";
  import { SDialogCommand } from "MysteryRogueSystem/ts/mr/system/dialogs/SDialogCommand";
  export class SItemListDialog extends SDialog {
      private _actorEntityId;
      private _inventoryBehaviorId;
      private _selectedEntity;
      constructor(actorEntity: LEntity, inventory: LInventoryBehavior);
      get actor(): LEntity;
      get inventory(): LInventoryBehavior;
      setSelectedEntity(entity: LEntity): void;
      selectedEntity(): LEntity;
      makeActionList(item: LEntity): SDialogCommand[];
      static normalizeActionList(actions: LReaction[]): LReaction[];
      private handleAction;
      private handleShortcutSet;
      private handleShortcutUnset;
      private handlePeek;
      private handlePutIn;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/dialogs/SItemSelectionDialog' {
  import { LInventoryBehavior } from "ts/mr/lively/behaviors/LInventoryBehavior";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SDialog } from "MysteryRogueSystem/ts/mr/system/SDialog";
  export class SItemSelectionDialog extends SDialog {
      private _actorEntityId;
      private _inventoryBehaviorId;
      private _selectedEntity;
      constructor(actorEntity: LEntity, inventory: LInventoryBehavior);
      entity(): LEntity;
      inventory(): LInventoryBehavior;
      setSelectedEntity(entity: LEntity): void;
      selectedEntity(): LEntity | undefined;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/dialogs/SItemSellDialog' {
  import { LInventoryBehavior } from "ts/mr/lively/behaviors/LInventoryBehavior";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SDialog } from "MysteryRogueSystem/ts/mr/system/SDialog";
  export class SItemSellDialog extends SDialog {
      private _serviceProviderId;
      private _serviceUserId;
      private _inventoryId;
      private _resultItems;
      constructor(serviceProvider: LEntity, serviceUser: LEntity, inventoryHolder: LEntity);
      get serviceProvider(): LEntity;
      get serviceUser(): LEntity;
      get inventory(): LInventoryBehavior;
      get resultItems(): LEntity[];
      setResultItems(items: LEntity[]): void;
      submitSell(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/dialogs/SMainMenuDialog' {
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SDialog } from "MysteryRogueSystem/ts/mr/system/SDialog";
  export class SMainMenuDialog extends SDialog {
      private _entityId;
      constructor(entity: LEntity);
      entity(): LEntity;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/dialogs/SManualDecisionDialog' {
  import { SDialogContext } from "ts/mr/system/SDialogContext";
  import { SDialog } from "MysteryRogueSystem/ts/mr/system/SDialog";
  export class SManualActionDialog extends SDialog {
      dashingEntry: boolean;
      onUpdate(context: SDialogContext): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/dialogs/SNicknameDialog' {
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SDialog } from "MysteryRogueSystem/ts/mr/system/SDialog";
  export class SNicknameDialog extends SDialog {
      private _actorEntityId;
      private _targetItemId;
      constructor(actorEntity: LEntity, targetItem: LEntity);
      get item(): LEntity;
      setNickname(name: string): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/dialogs/SWarehouseStoreDialog' {
  import { LInventoryBehavior } from "ts/mr/lively/behaviors/LInventoryBehavior";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SWarehouseDialogResult } from "MysteryRogueSystem/ts/mr/system/SCommon";
  import { SDialog } from "MysteryRogueSystem/ts/mr/system/SDialog";
  export class SWarehouseStoreDialog extends SDialog {
      private _userEntityId;
      private _inventoryBehaviorId;
      private _warehouseEntityId;
      private _warehouseInventoryBehaviorId;
      private _resultItems;
      private _result;
      constructor(user: LEntity, warehouse: LEntity);
      get user(): LEntity;
      get inventory(): LInventoryBehavior;
      get warehouseEntity(): LEntity;
      get warehouseInventory(): LInventoryBehavior;
      resultItems(): LEntity[];
      get result(): SWarehouseDialogResult;
      storeItems(items: LEntity[]): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/dialogs/SWarehouseWithdrawDialog' {
  import { LInventoryBehavior } from "ts/mr/lively/behaviors/LInventoryBehavior";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SWarehouseDialogResult } from "MysteryRogueSystem/ts/mr/system/SCommon";
  import { SDialog } from "MysteryRogueSystem/ts/mr/system/SDialog";
  export class SWarehouseWithdrawDialog extends SDialog {
      private _userEntityId;
      private _userInventoryBehaviorId;
      private _warehouseEntityId;
      private _inventoryBehaviorId;
      private _resultItems;
      private _result;
      constructor(user: LEntity, warehouse: LEntity);
      get user(): LEntity;
      get userInventory(): LInventoryBehavior;
      get inventory(): LInventoryBehavior;
      get warehouseEntity(): LEntity;
      resultItems(): LEntity[];
      get result(): SWarehouseDialogResult;
      withdrawItems(items: LEntity[]): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/effects/SChangeInstanceSpecialEffect' {
  import { DSpecialEffectRef } from "ts/mr/data/DSpecialEffect";
  import { LEffectResult } from "ts/mr/lively/LEffectResult";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SEffectModifier } from "MysteryRogueSystem/ts/mr/system/SEffectApplyer";
  import { SSpecialEffect } from "MysteryRogueSystem/ts/mr/system/effects/SSpecialEffect";
  export class SChangeInstanceSpecialEffect extends SSpecialEffect {
      onApplyTargetEffect(cctx: SCommandContext, data: DSpecialEffectRef, performer: LEntity, item: LEntity | undefined, modifier: SEffectModifier, target: LEntity, result: LEffectResult): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/effects/SClarificationSpecialEffect' {
  import { DSpecialEffectRef } from "ts/mr/data/DSpecialEffect";
  import { LEffectResult } from "ts/mr/lively/LEffectResult";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SEffectModifier } from "MysteryRogueSystem/ts/mr/system/SEffectApplyer";
  import { SSpecialEffect } from "MysteryRogueSystem/ts/mr/system/effects/SSpecialEffect";
  export class SClarificationSpecialEffect extends SSpecialEffect {
      onApplyTargetEffect(cctx: SCommandContext, data: DSpecialEffectRef, performer: LEntity, item: LEntity | undefined, modifier: SEffectModifier, target: LEntity, result: LEffectResult): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/effects/SDispelEquipmentsSpecialEffect' {
  import { DSpecialEffectRef } from "ts/mr/data/DSpecialEffect";
  import { LEffectResult } from "ts/mr/lively/LEffectResult";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SEffectModifier } from "MysteryRogueSystem/ts/mr/system/SEffectApplyer";
  import { SSpecialEffect } from "MysteryRogueSystem/ts/mr/system/effects/SSpecialEffect";
  /**
   * @deprecated
   */
  export class SDispelEquipmentsSpecialEffect extends SSpecialEffect {
      onApplyTargetEffect(cctx: SCommandContext, data: DSpecialEffectRef, performer: LEntity, item: LEntity | undefined, modifier: SEffectModifier, target: LEntity, result: LEffectResult): void;
      testApply(items: LEntity[]): boolean;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/effects/SDivisionSpecialEffect' {
  import { DSpecialEffectRef } from "ts/mr/data/DSpecialEffect";
  import { LEffectResult } from "ts/mr/lively/LEffectResult";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SEffectModifier } from "MysteryRogueSystem/ts/mr/system/SEffectApplyer";
  import { SSpecialEffect } from "MysteryRogueSystem/ts/mr/system/effects/SSpecialEffect";
  export class SDivisionSpecialEffect extends SSpecialEffect {
      onApplyTargetEffect(cctx: SCommandContext, data: DSpecialEffectRef, performer: LEntity, item: LEntity | undefined, modifier: SEffectModifier, target: LEntity, result: LEffectResult): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/effects/SGoldStealSpecialEffect' {
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SEffectModifier } from "MysteryRogueSystem/ts/mr/system/SEffectApplyer";
  import { SSpecialEffect } from "MysteryRogueSystem/ts/mr/system/effects/SSpecialEffect";
  import { LEffectResult } from "ts/mr/lively/LEffectResult";
  import { DSpecialEffectRef } from "ts/mr/data/DSpecialEffect";
  export class SGoldStealSpecialEffect extends SSpecialEffect {
      onApplyTargetEffect(cctx: SCommandContext, data: DSpecialEffectRef, performer: LEntity, item: LEntity | undefined, modifier: SEffectModifier, target: LEntity, result: LEffectResult): void;
      private pickGold;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/effects/SItemStealSpecialEffect' {
  import { DSpecialEffectRef } from "ts/mr/data/DSpecialEffect";
  import { LEffectResult } from "ts/mr/lively/LEffectResult";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SEffectModifier } from "MysteryRogueSystem/ts/mr/system/SEffectApplyer";
  import { SSpecialEffect } from "MysteryRogueSystem/ts/mr/system/effects/SSpecialEffect";
  export class SItemStealSpecialEffect extends SSpecialEffect {
      onApplyTargetEffect(cctx: SCommandContext, data: DSpecialEffectRef, performer: LEntity, item: LEntity | undefined, modifier: SEffectModifier, target: LEntity, result: LEffectResult): void;
      private pickItem;
      static postWarpBySteal(cctx: SCommandContext, performer: LEntity, itemName: string): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/effects/SLevelDownSpecialEffect' {
  import { DSpecialEffectRef } from "ts/mr/data/DSpecialEffect";
  import { LEffectResult } from "ts/mr/lively/LEffectResult";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SEffectModifier } from "MysteryRogueSystem/ts/mr/system/SEffectApplyer";
  import { SSpecialEffect } from "MysteryRogueSystem/ts/mr/system/effects/SSpecialEffect";
  export class SLevelDownSpecialEffect extends SSpecialEffect {
      onApplyTargetEffect(cctx: SCommandContext, data: DSpecialEffectRef, performer: LEntity, item: LEntity | undefined, modifier: SEffectModifier, target: LEntity, result: LEffectResult): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/effects/SPerformeSkillSpecialEffect' {
  import { DSpecialEffectRef } from "ts/mr/data/DSpecialEffect";
  import { LEffectResult } from "ts/mr/lively/LEffectResult";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SEffectModifier } from "MysteryRogueSystem/ts/mr/system/SEffectApplyer";
  import { SSpecialEffect } from "MysteryRogueSystem/ts/mr/system/effects/SSpecialEffect";
  export class SPerformeSkillSpecialEffect extends SSpecialEffect {
      onApplyTargetEffect(cctx: SCommandContext, data: DSpecialEffectRef, performer: LEntity, item: LEntity | undefined, modifier: SEffectModifier, target: LEntity, result: LEffectResult): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/effects/SRemoveStatesByIntentionsSpecialEffect' {
  import { DSpecialEffectRef } from "ts/mr/data/DSpecialEffect";
  import { LEffectResult } from "ts/mr/lively/LEffectResult";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SEffectModifier } from "MysteryRogueSystem/ts/mr/system/SEffectApplyer";
  import { SSpecialEffect } from "MysteryRogueSystem/ts/mr/system/effects/SSpecialEffect";
  export class SRemoveStatesByIntentionsSpecialEffect extends SSpecialEffect {
      onApplyTargetEffect(cctx: SCommandContext, data: DSpecialEffectRef, performer: LEntity, item: LEntity | undefined, modifier: SEffectModifier, target: LEntity, result: LEffectResult): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/effects/SRestartFloorSpecialEffect' {
  import { DSpecialEffectRef } from "ts/mr/data/DSpecialEffect";
  import { LEffectResult } from "ts/mr/lively/LEffectResult";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SEffectModifier } from "MysteryRogueSystem/ts/mr/system/SEffectApplyer";
  import { SSpecialEffect } from "MysteryRogueSystem/ts/mr/system/effects/SSpecialEffect";
  export class SRestartFloorSpecialEffect extends SSpecialEffect {
      onApplyTargetEffect(cctx: SCommandContext, data: DSpecialEffectRef, performer: LEntity, item: LEntity | undefined, modifier: SEffectModifier, target: LEntity, result: LEffectResult): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/effects/SSpecialEffect' {
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SEffectModifier } from "MysteryRogueSystem/ts/mr/system/SEffectApplyer";
  import { LEffectResult } from "ts/mr/lively/LEffectResult";
  import { DSpecialEffectRef } from "ts/mr/data/DSpecialEffect";
  export abstract class SSpecialEffect {
      onApplyTargetEffect(cctx: SCommandContext, data: DSpecialEffectRef, performer: LEntity, item: LEntity | undefined, modifier: SEffectModifier, target: LEntity, result: LEffectResult): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/effects/SSpecialEffectManager' {
  import { DSpecialEffectId } from "ts/mr/data/DCommon";
  import { SSpecialEffect } from "MysteryRogueSystem/ts/mr/system/effects/SSpecialEffect";
  export class SSpecialEffectManager {
      private behaviors;
      constructor();
      register(specialEffectId: DSpecialEffectId, behavior: SSpecialEffect): void;
      find(specialEffectId: DSpecialEffectId): SSpecialEffect | undefined;
      get(specialEffectId: DSpecialEffectId): SSpecialEffect;
      private setupBuiltins;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/effects/SStumbleSpecialEffect' {
  import { DSpecialEffectRef } from "ts/mr/data/DSpecialEffect";
  import { LEffectResult } from "ts/mr/lively/LEffectResult";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SEffectModifier } from "MysteryRogueSystem/ts/mr/system/SEffectApplyer";
  import { SSpecialEffect } from "MysteryRogueSystem/ts/mr/system/effects/SSpecialEffect";
  export class SStumbleSpecialEffect extends SSpecialEffect {
      onApplyTargetEffect(cctx: SCommandContext, data: DSpecialEffectRef, performer: LEntity, item: LEntity | undefined, modifier: SEffectModifier, target: LEntity, result: LEffectResult): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/effects/STransferToLowerFloorSpecialEffect' {
  import { DSpecialEffectRef } from "ts/mr/data/DSpecialEffect";
  import { LEffectResult } from "ts/mr/lively/LEffectResult";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SEffectModifier } from "MysteryRogueSystem/ts/mr/system/SEffectApplyer";
  import { SSpecialEffect } from "MysteryRogueSystem/ts/mr/system/effects/SSpecialEffect";
  export class STransferToLowerFloorSpecialEffect extends SSpecialEffect {
      onApplyTargetEffect(cctx: SCommandContext, data: DSpecialEffectRef, performer: LEntity, item: LEntity | undefined, modifier: SEffectModifier, target: LEntity, result: LEffectResult): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/effects/STransferToNextFloorSpecialEffect' {
  import { DSpecialEffectRef } from "ts/mr/data/DSpecialEffect";
  import { LEffectResult } from "ts/mr/lively/LEffectResult";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SEffectModifier } from "MysteryRogueSystem/ts/mr/system/SEffectApplyer";
  import { SSpecialEffect } from "MysteryRogueSystem/ts/mr/system/effects/SSpecialEffect";
  export class STransferToNextFloorSpecialEffect extends SSpecialEffect {
      onApplyTargetEffect(cctx: SCommandContext, data: DSpecialEffectRef, performer: LEntity, item: LEntity | undefined, modifier: SEffectModifier, target: LEntity, result: LEffectResult): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/effects/STrapProliferationSpecialEffect' {
  import { DSpecialEffectRef } from "ts/mr/data/DSpecialEffect";
  import { LEffectResult } from "ts/mr/lively/LEffectResult";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SEffectModifier } from "MysteryRogueSystem/ts/mr/system/SEffectApplyer";
  import { SSpecialEffect } from "MysteryRogueSystem/ts/mr/system/effects/SSpecialEffect";
  export class STrapProliferationSpecialEffect extends SSpecialEffect {
      onApplyTargetEffect(cctx: SCommandContext, data: DSpecialEffectRef, performer: LEntity, item: LEntity | undefined, modifier: SEffectModifier, target: LEntity, result: LEffectResult): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/effects/SWrapSpecialEffect' {
  import { DSpecialEffectRef } from "ts/mr/data/DSpecialEffect";
  import { LEffectResult } from "ts/mr/lively/LEffectResult";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SEffectModifier } from "MysteryRogueSystem/ts/mr/system/SEffectApplyer";
  import { SSpecialEffect } from "MysteryRogueSystem/ts/mr/system/effects/SSpecialEffect";
  export class SWarpSpecialEffect extends SSpecialEffect {
      onApplyTargetEffect(cctx: SCommandContext, data: DSpecialEffectRef, performer: LEntity, item: LEntity | undefined, modifier: SEffectModifier, target: LEntity, result: LEffectResult): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/Helpers' {
  import { DFactionId } from "ts/mr/data/MRData";
  import { Vector2 } from "ts/mr/math/Vector2";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { DFactionType } from "MysteryRogueSystem/ts/mr/data/DFaction";
  export class Helpers {
      static _dirToTileOffsetTable: Vector2[];
      static dirToTileOffset(dir: number): Vector2;
      static offsetToDir(offsetX: number, offsetY: number): number;
      static makeFrontPosition(x: number, y: number, dir: number, length: number): Vector2;
      static makeEntityFrontPosition(entity: LEntity, length: number): Vector2;
      static getDistance(entity1: LEntity, entity2: LEntity): number;
      static isHostile(subject: LEntity, target: LEntity): boolean;
      static isFriend(subject: LEntity, target: LEntity): boolean;
      static getLooksToFactionType(subject: LEntity, target: LEntity): DFactionType;
      static isHostileFactionId(subject: DFactionId, target: DFactionId): boolean;
      static isFriendFactionId(subject: DFactionId, target: DFactionId): boolean;
      static lerp(v1: number, v2: number, t: number): number;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/internal' {
  export * from "MysteryRogueSystem/ts/mr/system/SBehaviorFactory";
  export * from "MysteryRogueSystem/ts/mr/system/SEntityFactory";

}
declare module 'MysteryRogueSystem/ts/mr/system/map/SItemShopBuilder' {
  import { LRandom } from "ts/mr/lively/LRandom";
  import { LItemShopStructure } from "ts/mr/lively/structures/LItemShopStructure";
  import { SMapManager } from "MysteryRogueSystem/ts/mr/system/SMapManager";
  export class SItemShopBuilder {
      build(manager: SMapManager, info: LItemShopStructure, rand: LRandom): void;
      private setupEntranceBlocks;
      private getInRoomFloorBlock;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/map/SMonsterHouseBuilder' {
  import { LRandom } from "ts/mr/lively/LRandom";
  import { LMonsterHouseStructure } from "ts/mr/lively/structures/LMonsterHouseStructure";
  import { SMapManager } from "MysteryRogueSystem/ts/mr/system/SMapManager";
  export class SMonsterHouseBuilder {
      build(manager: SMapManager, info: LMonsterHouseStructure, rand: LRandom): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/MRSystem' {
  import { SIntegration } from "MysteryRogueSystem/ts/mr/system/SIntegration";
  import { BasicItems } from "ts/mr/data/predefineds/DBasicItems";
  import { EntityProperties, EntityProperty } from "ts/mr/data/predefineds/DBasicProperties";
  import { SSequelContext } from "MysteryRogueSystem/ts/mr/system/SSequelContext";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SScheduler } from "MysteryRogueSystem/ts/mr/system/scheduling/SScheduler";
  import { SMinimapData } from "MysteryRogueSystem/ts/mr/system/SMinimapData";
  import { SMapManager } from "MysteryRogueSystem/ts/mr/system/SMapManager";
  import { SDialogContext } from "MysteryRogueSystem/ts/mr/system/SDialogContext";
  import { SGroundRules } from "MysteryRogueSystem/ts/mr/system/SGroundRules";
  import { MRSystemExtension } from "MysteryRogueSystem/ts/mr/system/MRSystemExtension";
  import { STurnContext } from "MysteryRogueSystem/ts/mr/system/STurnContext";
  import { SSpecialEffectManager } from "MysteryRogueSystem/ts/mr/system/effects/SSpecialEffectManager";
  import { SFormulaOperand } from "MysteryRogueSystem/ts/mr/system/SFormulaOperand";
  import { LEntityId } from "MysteryRogueSystem/ts/mr/lively/LObject";
  export class MRSystem {
      static propertyData: EntityProperty[];
      static properties: EntityProperties;
      static ext: MRSystemExtension;
      static sequelContext: SSequelContext;
      static commandContext: SCommandContext;
      static dialogContext: SDialogContext;
      static turnContext: STurnContext;
      static integration: SIntegration;
      static scheduler: SScheduler;
      static minimapData: SMinimapData;
      static mapManager: SMapManager;
      static groundRules: SGroundRules;
      static effectBehaviorManager: SSpecialEffectManager;
      static requestedPlayback: boolean;
      static unittest: boolean;
      static requestedRestartFloorItem: LEntityId;
      static floorStartSaveContents: string | undefined;
      static items: BasicItems;
      static formulaOperandA: SFormulaOperand;
      static formulaOperandB: SFormulaOperand;
      static formulaOperandC: SFormulaOperand;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/MRSystemExtension' {
  import { DEntity } from "MysteryRogueSystem/ts/mr/data/DEntity";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  export class MRSystemExtension {
      onNewEntity(entity: LEntity, data: DEntity): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SAbilityFactory' {
  import { DAbilityId } from "ts/mr/data/DAbility";
  import { LAbility } from "ts/mr/lively/abilities/LAbility";
  export class SAbilityFactory {
      static newAbility(abilityId: DAbilityId): LAbility;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SActionHitTest' {
  import { DEffectHitType } from "MysteryRogueSystem/ts/mr/data/DEffect";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LRandom } from "MysteryRogueSystem/ts/mr/lively/LRandom";
  export class SActionHitTest {
      /**
       * Projectle 用の命中判定
       *
       * RMMZ では命中判定とダメージ適用を1つの処理で行っているが、
       * MR では飛び道具の命中判定の後に様々な処理が割り込む可能性があるため、分ける必要がある。
       * 例えば飛び道具の反射など。
       */
      static testProjectle(subject: LEntity, projectile: LEntity, target: LEntity, hitType: DEffectHitType, rand: LRandom): boolean;
      private static evaRate;
      private static testCertainIndirectHits;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SActivityContext' {
  import { LActivity } from "MysteryRogueSystem/ts/mr/lively/activities/LActivity";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { HandleActivityCommand, SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  /**
   * Activity の 3Way-Handshake
   */
  export class SActivityContext {
      private _activity;
      _thenFunc: (() => void) | undefined;
      _catchFunc: (() => void) | undefined;
      constructor(activity: LActivity);
      activity(): LActivity;
      /** 一連の処理が成功したとき */
      then(func: () => void): this;
      /** リジェクトされた/ハンドリングされなかったとき */
      catch(func: () => void): this;
      /**
       * onActivity の中から呼び出すこと。
       */
      postHandleActivity(cctx: SCommandContext, objectum: LEntity): HandleActivityCommand;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SActivityRecorder' {
  import { SActivityPlaybackDialog } from "ts/mr/system/dialogs/SActivityPlaybackDialog";
  import { LActivityData } from "ts/mr/lively/activities/LActivity";
  export enum ActivityRecordingCommandType {
      Activity = 1,
      CloseMainDialog = 2
  }
  export interface ActivityRecordingCommand {
      type: ActivityRecordingCommandType;
      activity: LActivityData | null;
  }
  export class SActivityRecorder {
      private _recorderMode;
      private _stream;
      private _playbackCommands;
      private _playbackCommandIndex;
      private _savefileId;
      private _silentPlayback;
      constructor();
      setSavefileId(id: number): void;
      isIdle(): boolean;
      isRecording(): boolean;
      isPlayback(): boolean;
      checkPlaybackRemaining(count: number): boolean;
      startRecording(): Promise<boolean>;
      stopRecording(): Promise<boolean>;
      restartRecording(): void;
      private filePath;
      push(cmd: ActivityRecordingCommand): void;
      attemptStartPlayback(silent: boolean): boolean;
      clearSilentPlayback(): void;
      isSilentPlayback(): boolean;
      private closeFile;
      runPlaybackCommand(dialog: SActivityPlaybackDialog): boolean;
      private doCommand;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SAIHelper' {
  import { LEntity } from "ts/mr/lively/LEntity";
  export class SAIHelper {
      private static _movingPriority;
      private static axisToDirIndices;
      static axisToDir(dx: number, dy: number): number;
      static distanceToDir(startX: number, startY: number, goalX: number, goalY: number): number;
      static entityDistanceToDir(start: LEntity, target: LEntity): number;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SBehaviorFactory' {
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LBehavior } from "ts/mr/lively/behaviors/LBehavior";
  import { DBehaviorInstantiation } from "MysteryRogueSystem/ts/mr/data/DEntityProperties";
  export class SBehaviorFactory {
      private static _behaviorEntries;
      static register<T extends LBehavior>(fullName: string, friendlyName: string, ctor: {
          new (...args: any[]): T;
      }): void;
      static attachBehaviors(entity: LEntity, behaviors: DBehaviorInstantiation[]): void;
      static createBehavior(name: string): LBehavior | undefined;
      static createBehaviorInstance(name: string): LBehavior | undefined;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/scheduling/SChainAfterScheduler' {
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  export class SChainAfterScheduler {
      private _phase;
      constructor();
      reset(): void;
      isRunning(): boolean;
      isEnd(): boolean;
      process(cctx: SCommandContext): void;
      private process_Prologue;
      private process_StabilizeSituation;
      private process_PreviewDead;
      private process_ResolvePermanentDeath;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/scheduling/SScheduler' {
  import { LScheduler2 } from "ts/mr/lively/LScheduler";
  export class SScheduler {
      private _data;
      private _stepScheduler;
      private _chainAfterScheduler;
      private _brace;
      private _occupy;
      constructor();
      reset(): void;
      data(): LScheduler2;
      stepSimulation(): void;
      private stepSimulationInternal;
      private update_RoundStarting;
      private update_ProcessPhase;
      private update_RoundEnding;
      private onCommandChainConsumed;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/scheduling/SSchedulerPhase' {
  import { SScheduler } from "MysteryRogueSystem/ts/mr/system/scheduling/SScheduler";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LUnitBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LUnitBehavior";
  export abstract class SSchedulerPhase {
      abstract isAllowIterationAtPrepare(): boolean;
      onStart(): void;
      abstract testProcessable(entity: LEntity, unitBehavior: LUnitBehavior): boolean;
      abstract onProcess(entity: LEntity, unitBehavior: LUnitBehavior): void;
      onAfterProcess(entity: LEntity): void;
      onEnd(scheduler: SScheduler): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/scheduling/SSchedulerPhaseImpl' {
  import { SScheduler } from "MysteryRogueSystem/ts/mr/system/scheduling/SScheduler";
  import { SSchedulerPhase } from "MysteryRogueSystem/ts/mr/system/scheduling/SSchedulerPhase";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LUnitBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LUnitBehavior";
  export class SSchedulerPhase_ManualAction extends SSchedulerPhase {
      isAllowIterationAtPrepare(): boolean;
      onStart(): void;
      testProcessable(entity: LEntity, unitBehavior: LUnitBehavior): boolean;
      onProcess(entity: LEntity, unitBehavior: LUnitBehavior): void;
  }
  export class SSchedulerPhase_AIMinorAction extends SSchedulerPhase {
      isAllowIterationAtPrepare(): boolean;
      onStart(): void;
      testProcessable(entity: LEntity, unitBehavior: LUnitBehavior): boolean;
      onProcess(entity: LEntity, unitBehavior: LUnitBehavior): void;
      onEnd(scheduler: SScheduler): void;
  }
  export class SSchedulerPhase_ResolveAdjacentAndMovingTarget extends SSchedulerPhase {
      isAllowIterationAtPrepare(): boolean;
      onStart(): void;
      testProcessable(entity: LEntity, unitBehavior: LUnitBehavior): boolean;
      onProcess(entity: LEntity, unitBehavior: LUnitBehavior): void;
  }
  export class SSchedulerPhase_CheckFeetMoved extends SSchedulerPhase {
      isAllowIterationAtPrepare(): boolean;
      onStart(): void;
      testProcessable(entity: LEntity, unitBehavior: LUnitBehavior): boolean;
      onProcess(entity: LEntity, unitBehavior: LUnitBehavior): void;
  }
  export class SSchedulerPhase_AIMajorAction extends SSchedulerPhase {
      isAllowIterationAtPrepare(): boolean;
      testProcessable(entity: LEntity, unitBehavior: LUnitBehavior): boolean;
      onProcess(entity: LEntity, unitBehavior: LUnitBehavior): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/scheduling/SStepScheduler' {
  import { SScheduler } from "MysteryRogueSystem/ts/mr/system/scheduling/SScheduler";
  export class SStepScheduler2 {
      private _scheduler;
      private _data;
      private _cctx;
      private _stepPhase;
      private _phases;
      constructor(scheduler: SScheduler);
      start(): void;
      process(): boolean;
      private isSequenceClosed;
      private currentPhase;
      private processCore2;
      private process_RunStarting;
      private process_PhaseStarting;
      private process_StepStarting;
      private process_MainProcess;
      private process_MainProcessClosing;
      private process_AfterProcess;
      private process_AfterProcessClosing;
      private process_StepClosing;
      private process_PhaseClosing;
      private process_RunClosing;
      private onStepProcessEnd;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SCommand' {
  import { DCommandId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  /**
   * RECommand の処理結果
   *
   *
   *
   * NOTE:
   * Behavior の Command 実行処理は、直前の Behavior の Response 結果にかかわらず呼び出されます。
   * 直前の結果が Pass であるような前提を期待せず、基本的には
   * 「直前の Behavior の処理で Command が失敗したら、この Command も実行しない」といった判定を入れてください。
   * 例外は「武器を振るだけでステータスダウン」のような、Command の成否にかかわらず実行したい処理です。
   *
   */
  export enum SCommandResponse {
      /**
       * 目的の処理を、意味のある結果を以って実行し終え、Command は実行済みであることを示します。
       *
       * Behavior の実装の中でこのコマンドを return した場合、後続の Behavior に Command は通知されません。
       */
      Handled = 0,
      /** RECommand はハンドリングされませんでした。続けて後続の Behavior に RECommand を通知します。 */
      Pass = 1,
      /** 状態異常の制限により、目的の処理を実行できなかったことを示します。後続の Behavior に RECommand は通知されません。 */
      Canceled = 2
  }
  export enum SPhaseResult {
      /** Behavior Chain の実行を続ける。 */
      Pass = 0,
      /** Behavior Chain の実行を終了する。 */
      Handled = 1
  }
  export function checkContinuousResponse(r: SCommandResponse): boolean;
  /**
   * onCommand の引数。
   *
   * LActivity と似ているが、こちらは Recoding 対象外。シリアライズされるものではない。
   * LActivity は意思決定の履歴と考えることができる。対して SCommand は単純な引数のセットである。
   */
  export class SCommand {
      readonly id: DCommandId;
      private _objects;
      private constructor();
      static make(id: DCommandId): SCommand;
      get objects(): readonly LEntity[];
      withObject(object: LEntity): this;
      withObjects(objects: readonly LEntity[]): this;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SCommandContext' {
  import { SCommand, SCommandResponse } from "MysteryRogueSystem/ts/mr/system/SCommand";
  import { SDialog } from "MysteryRogueSystem/ts/mr/system/SDialog";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { SMotionSequel } from "MysteryRogueSystem/ts/mr/system/SSequel";
  import { SEffectSubject } from "MysteryRogueSystem/ts/mr/system/SEffectContext";
  import { LBlock } from "MysteryRogueSystem/ts/mr/lively/LBlock";
  import { SSequelContext } from "MysteryRogueSystem/ts/mr/system/SSequelContext";
  import { LActivity } from "ts/mr/lively/activities/LActivity";
  import { LFloorId } from "ts/mr/lively/LFloorId";
  import { LRandom } from "ts/mr/lively/LRandom";
  import { SActivityContext } from "MysteryRogueSystem/ts/mr/system/SActivityContext";
  import { DActionId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { LActionTokenConsumeType } from "MysteryRogueSystem/ts/mr/lively/LCommon";
  import { CommandResultCallback, SSubTaskChain, STask, TaskThenFunc } from "MysteryRogueSystem/ts/mr/system/tasks/STask";
  import { DFlavorEffect } from "MysteryRogueSystem/ts/mr/data/DFlavorEffect";
  export interface SDisplayFlavorEffectOptions {
      messageFormatArgs: unknown[];
      motionObjectEntity?: LEntity;
  }
  export enum SHandleCommandResult {
      Resolved = 0,
      Rejected = 1
  }
  export class HandleActivityCommand {
      _thenFunc: (() => SHandleCommandResult) | undefined;
      _catchFunc: (() => void) | undefined;
      then(func: () => SHandleCommandResult): this;
      catch(func: () => void): this;
  }
  /**
   *
   * 基本的な使い方
   * ----------
   *
   * 次のようにすることで、 Task を積むことができる。
   * ```
   * ctx.post(...);
   * ctx.post(...);
   * ctx.post(...);
   * ```
   *
   * post の実行順序
   * ----------
   *
   * ```
   * ctx.post(_ => {      // A
   *   ctx.post(...);     // B
   * });
   * ctx.post(_ => {      // C
   *   ctx.post(...);     // D
   * });
   * ctx.post(...);       // E
   * ```
   *
   * この場合、まず [A, C, E] のような TaskList ができる。
   * これを実行した結果、次に [B, D] のような TaskList ができる。
   * 結果的に Task の実行順は A > C > E > B > D となる。
   *
   * このケースの場合、事前の Task の結果によって実行の可否を制御することはできない。
   * つまり一度 TaskList に積まれた Task は、必ず実行される。
   *
   * 条件を付けたい場合は次の then, catch を使用する。
   *
   * then, catch
   * ----------
   *
   * then, catch を使うことで、post した Task の成否に応じて実行する処理をチェーンできる。
   * ```
   * ctx.post(...)
   *   .then()        // 1つ目の post の処理が成功したら実行される
   *   .catch();      // 1つ目の post の処理が失敗したら実行される
   * ctx.post(...);   // 上記成否にかかわらず実行される。
   * ctx.post(...);
   * ```
   * then, catch の処理は、起点となる Task と同一の TaskList 上で実行される。
   * 例えば上記の場合、2つ目の post の前に実行される。
   *
   * then は新たな Task を生成して返すが、catch は this を返す。
   * メソッドチェーンを書きたい場合は、catch を先に書くのが無難。
   *
   * ```
   * ctx.post(A)
   *   .catch(A失敗)
   *   .then(B)
   *   .catch(B失敗)
   *   .then(C)
   * ```
   *
   * finally
   * ----------
   *
   * 成否にかかわらず、SubTaskChain の最後に必ず実行したい処理を finally で追加できる。
   * ```
   * ctx.post(onAnyAction)
   *     .then(...)
   *     .catch(...)
   *     .finally(_ => {
   *
   *     });
   * ```
   *
   * エラー時に実行される then と catch
   * ----------
   *
   * エラーした場合、
   * - 以降の then は呼ばれない。
   * - 以降の、直近の catch 1つが呼ばれる。
   *
   * ```
   * ctx.post(A)
   *   .catch(A失敗)
   *   .then(B)      // ここで失敗したら、
   *   .then(C)
   *   .catch(B失敗)  // この catch だけが実行される。
   *   .then(D)       // これは呼ばれない。
   *   .catch(失敗)   // これは呼ばれない。
   *
   * resolve と reject
   * ----------
   *
   * Promise 同様、実行関数は次の形が基本となる。
   *
   * ```
   * (c) => {
   *   if (成功) {
   *     c.resolve();
   *   }
   *   else {
   *     c.reject();
   *   }
   * }
   * ```
   *
   * デフォルトは resolve とする。 Behavior 側にコマンドハンドラが1つも無い場合はエラーにせず先に進みたい。
   * resolve() したら、その時点でチェインされている Task を Priority に設定する。
   * つまり、
   * ```
   * ctx.post(...)    // A
   * c.resolve();      // B(呼び出し元の then)
   * ctx.post(...)    // C
   * ```
   * このような場合、実行順は B > A > C となる。
   *
   * 順序通りにしたい場合、次のような postResolve を作るのもありかもしれない。（使うかわからないので未対応）
   * ```
   * ctx.post(...)    // A
   * ctx.postResolve(c);  // B(呼び出し元の then)
   * ctx.post(...)    // C
   * ```
   *
   * Behavior 側のコマンドハンドラ側の制限事項・注意点
   * ----------
   *
   * 誤用防止のため、resolve, reject は1度しか呼び出すことはできない。
   * コマンドハンドラは次のように Handled を返し、後続のコマンドハンドラの呼び出しを抑制しなければならない。
   * ```
   * onAnyAction(c) {
   *     if (...) {
   *         c.resolve();
   *         return Handled;
   *     }
   *     else {
   *         c.reject();
   *         return Handled;
   *     }
   *     else {
   *         return Pass;
   *     }
   * }
   * ```
   *
   * コマンドハンドラ側で Dialog 表示を伴う際の基本的な書き方は次のようになる。
   * ```
   * onAnyAction(c) {
   *     ctx.postDialog(..., _ => {
   *         if (...) {
   *             c.resolve();
   *         }
   *         else {
   *             c.reject();
   *         }
   *     });
   *     return Handled;
   * }
   * ```
   * resolve() や reject() は遅延実行の形になるが実行はされるので、 Handled を返すべきである。
   *
   *
   *
   */
  export class SCommandContext {
      private _sequelContext;
      private _visualAnimationWaiting;
      _recodingCommandList: STask[];
      private _nextPriorityTask;
      private _runningCommandList;
      private _afterChainCommandList;
      private _messageIndex;
      private _commandChainRunning;
      private __whenWaitingTasks;
      _subTaskChainStack: SSubTaskChain[];
      pushSubTaskChain(c: SSubTaskChain): void;
      popSubTaskChain(c: SSubTaskChain): void;
      get currentSubTaskChain(): SSubTaskChain | undefined;
      constructor(sequelContext: SSequelContext);
      clear(): void;
      random(): LRandom;
      checkOpenDialogRequired(): boolean;
      callCommand(c: SSubTaskChain, entity: LEntity, cmd: SCommand): void;
      makeTask(action: TaskThenFunc): STask;
      makeCommandTask(entity: LEntity, cmd: SCommand): STask;
      postTask2(task: STask): STask;
      postTask(action: TaskThenFunc): STask;
      postCommandTask(entity: LEntity, cmd: SCommand): STask;
      whenAll(tasks: STask[]): STask;
      postConsumeActionToken(entity: LEntity, tokenType: LActionTokenConsumeType): void;
      postActivity(srcActivity: LActivity, withPreprocess?: boolean): SActivityContext;
      private attemptConsumeActionToken;
      callSymbol<TSym extends symbol>(target: LEntity, sender: LEntity, subject: SEffectSubject, args: any, symbol: TSym): SCommandResponse;
      post<TSym extends symbol>(target: LEntity, sender: LEntity, subject: SEffectSubject, args: any, symbol: TSym, result?: CommandResultCallback): STask;
      postCall(func: () => void): STask;
      findReactorEntityInBlock(block: LBlock, actionId: number): LEntity | undefined;
      openDialog(causeEntity: LEntity, dialogModel: SDialog, afterChain: boolean): SDialog;
      displayFlavorEffect(entity: LEntity, flavorEffect: DFlavorEffect | undefined, options: SDisplayFlavorEffectOptions): void;
      postSequel(entity: LEntity, sequelId: number, targetX?: number, targetY?: number, args?: any): SMotionSequel;
      postAnimation(entity: LEntity, animationId: number, wait: boolean): void;
      postFloatingAnimation(entity: LEntity, mx: number, my: number, rmmzAnimationId: number, wait: boolean): void;
      postBalloon(entity: LEntity, balloonId: number, wait: boolean): void;
      postWaitSequel(): void;
      postWait(entity: LEntity, waitCount: number): void;
      postEmitEffect(entity: LEntity, actionId: DActionId, subject: LEntity, target: LEntity, dir: number): void;
      postDestroy(entity: LEntity): void;
      postMessage(text: string): void;
      postEffectResult(entity?: LEntity | undefined): void;
      /**
       * フロア移動
       * @param entity
       * @param floorId
       * @param x
       * @param y
       * @param d
       */
      postTransferFloor(entity: LEntity, floorId: LFloorId, x?: number, y?: number, d?: number): void;
      postSkipPart(entity: LEntity): void;
      visualAnimationWaiting(): boolean;
      clearVisualAnimationWaiting(): void;
      isRunning(): boolean;
      isRecordingListEmpty(): boolean;
      isEmpty(): boolean;
      _processCommand(): void;
      _submit(): void;
      _setNextPriorityTask(task: STask): void;
      dumpCommands(): void;
      private pushRecodingCommandList;
      private pushAfterChainCommandList;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SCommon' {
  export enum SStepPhase {
      RunStarting = 0,
      PhaseStarting = 1,
      StepStarting = 2,
      MainProcess = 3,
      MainProcessClosing = 4,
      AfterProcess = 5,
      AfterProcessClosing = 6,
      StepClosing = 7,
      PhaseClosing = 8,
      RunClosing = 9,
      Closed = 10
  }
  export enum SWarehouseDialogResult {
      Succeeded = 0,
      SucceededAsMuch = 1,
      Cancel = -1,
      FullyCanceled = -2
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SDebugHelpers' {
  import { LEntity } from "ts/mr/lively/LEntity";
  export class SDebugHelpers {
      static setHP(entity: LEntity, value: number): void;
      static setFP(entity: LEntity, value: number): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SDialog' {
  import { LFloorId } from "ts/mr/lively/LFloorId";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { SDialogContext } from "MysteryRogueSystem/ts/mr/system/SDialogContext";
  export enum SDialogAction {
      None = 0,
      Submit = 1,
      Cancel = 2,
      CloseAllSubDialogs = 3
  }
  export interface SDialogResult {
      action: SDialogAction;
      selectedItems: LEntity[];
  }
  export type SDialogResultCallback = (dialog: SDialog) => void;
  export type LDialogResultCallback = (result: any) => void;
  /**
   * GameDialog
   *
   * Dialog と名前がついているが、必ずしも UI を持つものではない。
   * 名前通り、エンドユーザーとの「対話」のためのインターフェイスを実装する。
   *
   * MVVM ライクな実装にしているが、これはユニットテスト可能にするため。
   *
   * また基本的にすべての LDialog の派生と VDialog の派生はペアとなっている。
   * これはいずれの Dialog も Main/Sub 両方で使用できるようにするため。
   * これによって再利用がしやすくなる。例えば壺や倉庫にアイテムを入れるときのアイテム選択や、イベントリストからのアイテム選択。
   *
   * [2021/5/11] Dialog は System モジュールに持っていくべき？
   * ----------
   * セーブデータに保存しない、ということになる。
   * Dialog の状態を保存できなくなるので、Dialog を開いている時のセーブは基本的に禁止になる。
   * 例えば Dialog からのイベント実行でセーブ画面を呼び出すようなことは禁止。
   *
   * Object に持っていく場合はこれと併せて CommandContext の保存も必要になってくる。
   * ただそうすると想定外の領域にもどんどん保存の必要性が出てくるので、ここは制限付きにしておくのがベターかも。
   */
  export class SDialog {
      _resultCallback: SDialogResultCallback | undefined;
      _resultCallbackVisual: LDialogResultCallback | undefined;
      _dialogResult: SDialogResult;
      _openedFloorId: LFloorId;
      constructor();
      onUpdate(context: SDialogContext): void;
      isVisualIntegration(): boolean;
      then<T extends SDialog>(func: (dialog: T) => void): void;
      submit(): void;
      cancel(): void;
      closeAllSubDialogs(): void;
      private _closeSelfAndSubDialogs;
      get dialogResult(): SDialogResult;
      get resultAction(): SDialogAction;
      get isSubmitted(): boolean;
      /**
       * SubDialog を開く。
       *
       * onResult が呼ばれる時点で、dialog はスタックから取り除かれている。
       */
      openSubDialog<T extends SDialog>(dialog: T, onResult?: ((model: T) => boolean | void) | undefined): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SDialogContext' {
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { LActivity } from "ts/mr/lively/activities/LActivity";
  import { SDialog } from "MysteryRogueSystem/ts/mr/system/SDialog";
  export class SDialogContext {
      private _commandContext;
      private _causeEntity;
      private _dialogs;
      constructor(cctx: SCommandContext);
      open(dialog: SDialog): void;
      private pop;
      dialogs(): readonly SDialog[];
      activeDialog(): SDialog;
      causeEntity(): LEntity | undefined;
      commandContext(): SCommandContext;
      postActivity(activity: LActivity): void;
      _closeDialog(dialog: SDialog): void;
      /**
       * 移動後のアイテム拾いや矢弾の装備など、ターンを消費しないが、一度コマンドチェーンを実行したいときに使う。
       */
      setCauseEntity(value: LEntity): void;
      _hasDialogModel(): boolean;
      _update(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SEffectApplyer' {
  import { DEntityCategoryId, DSkillId, DSubComponentEffectTargetKey, DElementId, DParameterId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DEffect, DEffectSet, DOtherEffectQualifying, DParamBuff, DParameterQualifying } from "MysteryRogueSystem/ts/mr/data/DEffect";
  import { LBattlerBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LBattlerBehavior";
  import { LEffectResult } from "MysteryRogueSystem/ts/mr/lively/LEffectResult";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LRandom } from "MysteryRogueSystem/ts/mr/lively/LRandom";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SEffectIncidentType } from "MysteryRogueSystem/ts/mr/system/SEffectContext";
  import { DSpecialEffectRef } from "MysteryRogueSystem/ts/mr/data/DSpecialEffect";
  export class SEffect {
      private _fact;
      private _data;
      private _targetModifier;
      private _hitType;
      private _successRate;
      constructor(fact: SEffectorFact, effect: DEffect);
      fact(): SEffectorFact;
      subject(): LEntity;
      data(): DEffect;
      targetModifier(): SEffectModifier;
      isCertainHit(): boolean;
      isPhysical(): boolean;
      isMagical(): boolean;
      hitRate(): number;
      evaRate(target: LEntity): number;
      criRate(target: LEntity): number;
      lukEffectRate(target: LEntity): number;
  }
  export interface SSubEffect {
      subTargetKey: DSubComponentEffectTargetKey;
      effect: SEffect;
  }
  export class SEffectorFact {
      private _subject;
      private _subjectEffects;
      private _subjectBattlerBehavior;
      private _effectors;
      private _effects;
      private _subEffects;
      private _selfModifier;
      private _succeededSelfModifier;
      private _incidentType;
      private _incidentEntityKind;
      private _item;
      private _sourceSkill;
      private _direction;
      private _genericEffectRate;
      constructor(subject: LEntity, effects: DEffectSet, incidentType: SEffectIncidentType, dir: number);
      withIncidentEntityKind(value: DEntityCategoryId): this;
      withItem(item: LEntity): this;
      withSkill(skill: DSkillId): this;
      subject(): LEntity;
      subjectBehavior(): LBattlerBehavior | undefined;
      effectSet(): DEffectSet;
      subEffects(): SSubEffect[];
      incidentType(): SEffectIncidentType;
      incidentEntityKind(): DEntityCategoryId;
      item(): LEntity | undefined;
      sourceSkill(): DSkillId | undefined;
      direction(): number;
      selfModifier(): SEffectModifier;
      succeededSelfModifier(): SEffectModifier | undefined;
      addEffector(entity: LEntity): void;
      genericEffectRate(): number;
      effects(): readonly SEffect[];
  }
  export enum SParameterEffectApplyType {
      None = 0,
      Damage = 1,
      Recover = 2
  }
  export class SParameterEffect {
      paramId: DParameterId;
      qualifying: DParameterQualifying;
      elementIds: DElementId[];
      formula: string;
      /** IDataSkill.damage.type  */
      applyType: SParameterEffectApplyType;
      isDrain: boolean;
      /** 分散度 */
      variance: number;
      fixedDamage: number | undefined;
      private _valid;
      constructor(data: DParameterQualifying);
      isRecover(): boolean;
      get isValid(): boolean;
      set isValid(value: boolean);
      evalConditions(target: LEntity): void;
      private meetsConditions;
  }
  export class SEffectModifier {
      private _data;
      private _parameterEffects2;
      constructor(subject: LEntity, q: DEffect);
      hasParamDamage(): boolean;
      parameterEffects2(): readonly SParameterEffect[];
      otherEffectQualifyings(): DOtherEffectQualifying[];
      effectBehaviors(): DSpecialEffectRef[];
      specialEffectQualifyings(): IDataEffect[];
      buffQualifying(): DParamBuff[];
  }
  /**
   * 成否判定後、実際にパラメータやステートに変化を与える
   */
  export class SEffectApplyer {
      private _effect;
      private _rand;
      constructor(effect: SEffect, rand: LRandom);
      apply(cctx: SCommandContext, modifier: SEffectModifier, target: LEntity): void;
      private makeDamageValue;
      private elemetedRecoverRate;
      private evalDamageFormula;
      private calcElementRate;
      private elementsMaxRate;
      private applyCritical;
      private applyVariance;
      private applyGuard;
      private applyProficiency;
      private applyDamageRate;
      private getRacePointRate;
      private applyRaceRate;
      private executeDamage;
      gainDrainedParam(paramEffect: SParameterEffect, value: number): void;
      applyItemEffect(cctx: SCommandContext, target: LEntity, effect: IDataEffect, result: LEffectResult): void;
      applyOtherEffect(cctx: SCommandContext, targetEntity: LEntity, effect: DOtherEffectQualifying, result: LEffectResult): void;
      private applyItemUserEffect;
      private itemEffectAddState;
      private itemEffectAddNormalState;
      private addState;
      private removeStatesByDamage;
      private itemEffectRemoveState;
      private itemEffectSpecial;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SEffectContext' {
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { LRandom } from "ts/mr/lively/LRandom";
  import { SEffect, SEffectorFact } from "MysteryRogueSystem/ts/mr/system/SEffectApplyer";
  import { STask } from "MysteryRogueSystem/ts/mr/system/tasks/STask";
  export enum SEffectIncidentType {
      /** 直接攻撃 (ヤリなど、隣接していない場合もあり得る) */
      DirectAttack = 0,
      /** 間接攻撃 (矢など) */
      IndirectAttack = 1
  }
  export class SEffectSubject {
      private _entity;
      constructor(entity: LEntity);
      entity(): LEntity;
  }
  /**
   * ダメージや状態異常、バフの適用など、パラメータ操作に関わる一連の処理を行う。
   *
   * - インスタンスは1度のコマンドチェーンで複数個作られることもある。(3方向同時攻撃など)
   *   複数対象への攻撃中、途中でパラメータ変動を伴うフィードバックを受ける可能性もあるため、
   *   複数のダメージ適用でひとつのインスタンスを使いまわすのは禁止。
   *   また LLVM の Pass のように、関係者で REEffectContext を持ちまわって加工しながら Effect を積んでいく使い方になるが、
   *   状態異常をダメージに変換するようなエネミーを設計するときには Effector 側が積んだ Effect を変更することになる。
   *   そのためインスタンスは別にしないと、同時攻撃で他の攻撃対象に影響が出てしまうことがある。
   * - インスタンスは Command に乗せて持ち回り、コマンドチェーン内で必ず Apply する。外には出ない。(そうしないと Attr に保存するような事態になるので)
   *
   * 戦闘不能について
   * ----------
   * ツクールの仕様にできるだけ寄せてみる。ツクールの仕様は…
   * - 戦闘不能ステートID は Game_Battler.deathStateId() で取得 (1)
   * - Game_Battler.refresh() で、HP が 0 であれば deathState が追加される。
   * - Game_BattlerBase.addNewState() で、で、deathState が追加されたら die() が呼ばれ HP 0 になる。
   * - Game_Battler.removeState() で、deathState が取り除かれたら revivie() が呼ばれ HP 1 になる。
   * - refresh() はダメージ適用や装備変更など様々なタイミングで呼び出される。
   *   - Game_Action.apply() > executeHpDamage() > Game_Battler.gainHp() > setHp() > refresh() 等。
   *
   *
   *
   * [2020/11/11] 複数ターゲットへの攻撃をひとつの EffectContext にまとめるべき？
   * ----------
   * 分けた場合、1つの対象への処理が終わったすぐ後に、フィードバックの処理を始めることができる。
   * 例えば、3体まとめて攻撃するとき、1体目に攻撃したときに反撃をもらい倒れてしまったとき、後続を攻撃するか、といった具合。
   * …でもこのケースだと EffectContext の中で戦闘不能を判断できるか。やる・やらないは別として。
   *
   * とにかく一度に複数対象へのダメージ適用を「中断」する可能性があるか？ということ。
   * そうかんがえると「ほとんど無い」
   * EffectContext 自体が複数対象へのダメージ適用をサポートしたとしても、
   * もしそのような中断がやりたければひとつずつインスタンス作って addTarget すればいいだけなので、まとめる方向で作ってよさそう。
   */
  export class SEffectContext {
      private _effectorFact;
      private _rand;
      constructor(subject: SEffectorFact, rand: LRandom);
      effectorFact(): SEffectorFact;
      applyWithWorth(cctx: SCommandContext, targets: LEntity[]): STask;
      selectEffects(effectList: SEffect[], rand: LRandom): SEffect[];
      selectEffect(effectList: SEffect[], rand: LRandom): SEffect | undefined;
      private findAnimationEntity;
      private applyWithHitTest;
      private judgeHits;
      private static judgeCertainHits;
      private testApply;
      private testLifeAndDeath;
      private applyCore;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SEmittorPerformer' {
  import { DEffectFieldScope } from "ts/mr/data/DEffect";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { DSkillId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { DEmittor } from "MysteryRogueSystem/ts/mr/data/DEmittor";
  import { LBlock } from "MysteryRogueSystem/ts/mr/lively/LBlock";
  export type SOnPerformedFunc = (targets: LEntity[]) => void;
  export class SEmittorPerformer {
      private _subject;
      /** 発動者 */
      private _performer;
      /** スキルとして発動する場合のスキルID. スキルではない場合 0. */
      private _skillId;
      /** 発動する効果 */
      private _emittor;
      /** 発動元となったアイテム (杖など) */
      private _itemEntity;
      /** Emittor がアイテムを対象とする場合、その対象となるアイテム */
      private _selectedTargetItems;
      /** 対象に効果を適用する際の基準となる向き。ノックバック方向等に使用する。0 の場合、performer の向きを採用する。 */
      private _effectDirection;
      private _projectilePriorityEffectSet;
      private _onPerformed;
      private constructor();
      static makeWithSkill(subject: LEntity, performer: LEntity, skillId: DSkillId): SEmittorPerformer;
      static makeWithEmitor(subject: LEntity, performer: LEntity, emittor: DEmittor): SEmittorPerformer;
      setSkillId(value: DSkillId): this;
      setEmittor(value: DEmittor): this;
      setItemEntity(value: LEntity): this;
      setSelectedTargetItems(value: LEntity[]): this;
      setDffectDirection(value: number): this;
      setProjectilePriorityEffectSet(value: DEmittor): this;
      perform(cctx: SCommandContext, onPerformed?: SOnPerformedFunc | undefined): void;
      /**
       * スキル発動
       *
       * 単純にスキルを発動する。地形や相手の状態による成否はこの中で判断する。
       */
      private performeSkill;
      private canPayParamCost;
      private payParamCost;
      private canPaySkillCost;
      private paySkillCost;
      private raiseSkillEmitted;
      private onPerformed;
      /**
       *
       * @param cctx
       * @param performer
       * @param emittor
       * @param itemData 杖など
       */
      private performeEffect;
      private performeEffect_StraightProjectile;
      private applyEffect;
      getTargetInBlock(block: LBlock, scope: DEffectFieldScope): LEntity[];
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SEntityFactory' {
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { DEntity, DEntityId, DEntityCreateInfo } from "ts/mr/data/DEntity";
  import { DItemDataId } from "ts/mr/data/DItem";
  import { DPrefab } from "ts/mr/data/DPrefab";
  import { DTroop } from "ts/mr/data/DTroop";
  import { DStateId } from "ts/mr/data/DState";
  import { LFloorId } from "ts/mr/lively/LFloorId";
  export class SEntityFactory {
      static newActor(entityId: DEntityId): LEntity;
      private static setupCommon;
      static buildActor(e: LEntity): void;
      static buildMonster(e: LEntity, enemyEntityData: DEntity): void;
      static buildItem(e: LEntity): void;
      static buildTrap(e: LEntity, itemId: DItemDataId): void;
      static newBasicExitPoint(): LEntity;
      static buildEntryPoint(e: LEntity): void;
      static buildExitPoint(e: LEntity): void;
      static buildOrnament(e: LEntity, prefab: DPrefab): void;
      static newEntity(createInfo: DEntityCreateInfo, floorId?: LFloorId): LEntity;
      static buildEntity(entity: LEntity): void;
      static spawnTroopAndMembers(troop: DTroop, mx: number, my: number, stateIds: DStateId[]): LEntity[];
      static setupDirectly_Item(entity: LEntity, entityData: DEntity): void;
      static setupDirectly_Enemy(entity: LEntity, entityData: DEntity): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SEventContext' {
  import { LBehavior } from "ts/mr/lively/behaviors/LBehavior";
  export class SEventContext {
      subscribe(b: LBehavior, s: Symbol): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SFormulaOperand' {
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  /**
   * [ダメージ計算式] の a や b といった項を表すクラス。
   */
  export class SFormulaOperand {
      private _entity;
      constructor();
      entity(): LEntity;
      wrap(entity: LEntity | undefined): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SGameManager' {
  /**
   */
  export class SGameManager {
      static createSystemObjects(): void;
      static createGameObjects(): void;
      static setupNewGame(): void;
      static performFloorTransfer(): void;
      static makeSaveContentsCore(): any;
      static loadSaveContentsCore(contents: any): void;
      static makeSaveContents(): any;
      static loadGameObjects(contents: any): void;
      static loadGame(contents: any, withPlayback: boolean): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SGroundRules' {
  import { LEntity } from "ts/mr/lively/LEntity";
  /**
   * ゲーム進行中の重要なタイミングで、各種オブジェクトの状態を調整するクラス。
   * タイトルや難易度ごとに調整できるように独立させておく。
   *
   * 例えばハードなルールではダンジョン内で倒れたときに持ち物をすべてロストするが、
   * イージーモードでは装備品は残す、といった変化に対応できるようにする。
   */
  export class SGroundRules {
      onEntityLandLeaved(entity: LEntity): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SImmediatelyCommandExecuteScheduler' {
  /**
   * ターン制御や Sequel の再生を伴わずに Command だけ実行する Scheduler。
   *
   * stepSimulation() 実行時に、Command が溜まっているばあは即時すべて実行する。
   *
   * RMMZ 側の制御に置かれたセーフティエリアマップ (拠点マップ) から、
   * プラグインコマンドなどを通して Entity へ Command を送るときに使う。
   * - アイテムの増減
   * - ステータスの増減
   * ...等。
   */
  export class SImmediatelyCommandExecuteScheduler {
      stepSimulation(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SIntegration' {
  import { DEventId } from "ts/mr/data/predefineds/DBasicEvents";
  import { LandExitResult } from "ts/mr/data/MRData";
  import { FMap } from "ts/mr/floorgen/FMapData";
  import { LBlock } from "ts/mr/lively/LBlock";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { LMap } from "ts/mr/lively/LMap";
  import { SSequelSet } from "ts/mr/system/SSequel";
  import { SDialog } from "MysteryRogueSystem/ts/mr/system/SDialog";
  import { SDialogContext } from "MysteryRogueSystem/ts/mr/system/SDialogContext";
  export abstract class SIntegration {
      abstract onEventPublished(eventId: DEventId, args: any, handled: boolean): void;
      /**
       * REシステム内から、 RMMZ マップを移動する必要があるときに呼び出される。
       * (ゲームオーバー時に拠点フロアへ戻るときなど)
       */
      abstract onReserveTransferMap(mapId: number, x: number, y: number, d: number): void;
      /**
       *
       */
      abstract onEntityLocated(entity: LEntity): void;
      abstract onLocateRmmzEvent(eventId: number, x: number, y: number): void;
      abstract onLoadFixedMapData(map: FMap): void;
      abstract onLoadFixedMapEvents(): void;
      abstract onUpdateBlock(block: LBlock): void;
      protected abstract onRefreshGameMap(map: LMap): void;
      protected abstract onFlushEffectResult(entity: LEntity): void;
      protected abstract onFlushSequelSet(sequelSet: SSequelSet): void;
      protected abstract onCheckVisualSequelRunning(): boolean;
      /** Dialog が開かれたとき。 */
      protected abstract onOpenDialog(model: SDialog): void;
      protected abstract onUpdateDialog(context: SDialogContext): void;
      /** Dialog が閉じられたとき。 */
      protected abstract onDialogClosed(context: SDialogContext, dialog: SDialog): void;
      /** Entity が Map 上に出現したとき。 */
      protected abstract onEntityEnteredMap(entity: LEntity): void;
      /** Entity が Map から離れたとき。 */
      protected abstract onEntityLeavedMap(entity: LEntity): void;
      protected abstract onEntityReEnterMap(entity: LEntity): void;
      abstract onSetLandExitResult(result: LandExitResult): void;
      refreshGameMap(map: LMap): void;
      flushEffectResultOneEntity(entity: LEntity): void;
      flushEffectResult(): void;
      flushSequelSet(sequelSet: SSequelSet): void;
      checkVisualSequelRunning(): boolean;
      openDialog(model: SDialog): void;
      updateDialog(context: SDialogContext): void;
      dialogClosed(context: SDialogContext, dialog: SDialog): void;
      entityEnteredMap(entity: LEntity): void;
      entityLeavedMap(entity: LEntity): void;
      entityReEnterMap(entity: LEntity): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SMapManager' {
  import { LEntity } from "ts/mr/lively/LEntity";
  import { LMap } from "ts/mr/lively/LMap";
  import { FMap } from "ts/mr/floorgen/FMapData";
  import { LRandom } from "ts/mr/lively/LRandom";
  /**
   * LMap へのアイテムや敵の生成・配置など、ゲーム進行に伴う Map 上の変化を管理するクラス。
   */
  export class SMapManager {
      private _map;
      private _enemySpanwRate;
      private _enemySpawnCount;
      private _needRefreshVisual;
      private _exitPoint;
      constructor();
      get exitPoint(): LEntity;
      setMap(map: LMap): void;
      map(): LMap;
      rand(): LRandom;
      setupMap(initialMap: FMap): void;
      private setupRandomMap;
      private setupFixedMap;
      setupInitial(): void;
      buildStructurs(): void;
      requestRefreshVisual(): void;
      attemptRefreshVisual(): void;
      updateRound(): void;
      private enterEntitiesToCurrentMap;
      private findSpawnableBlockRandom;
      private spawnRandomEnemy;
      /** 出現テーブルからランダムに選択して Entity を作る */
      spawnEnemy(mx: number, my: number): LEntity[];
      /** 出現テーブルからランダムに選択して Item を作る */
      spawnItem(mx: number, my: number): LEntity | undefined;
      /** 出現テーブルからランダムに選択して Trap を作る */
      spawnTrap(mx: number, my: number): void;
      spawnTraps(count: number): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SMinimapData' {
  export class SMinimapData {
      private _width;
      private _height;
      private _data;
      private _tilemapResetNeeded;
      private _refreshNeeded;
      clear(): void;
      reset(width: number, height: number): void;
      width(): number;
      height(): number;
      data(): number[];
      setData(x: number, y: number, z: number, value: number): void;
      getData(x: number, y: number, z: number): number;
      isValid(x: number, y: number, z: number): boolean;
      isTilemapResetNeeded(): boolean;
      clearTilemapResetNeeded(): void;
      setTilemapResetNeeded(): void;
      setRefreshNeeded(): void;
      playerMarkerTileId(): number;
      itemMarkerTileId(): number;
      enemyMarkerTileId(): number;
      exitMarkerTileId(): number;
      refresh(): void;
      update(): void;
      private getDefiniteMarkerTileId;
      static _subtileToAutoTileTable: number[][];
      static _subtileToAutoTileTable_Wall: number[][];
      private getAutotileShape;
      private getSameKindTile;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SNavigationHelper' {
  import { LEntity } from "ts/mr/lively/LEntity";
  export class SNavigationHelper {
      /**
       * subject から見て target は可視であるか
       *
       * ミニマップ表示に使う。AIでは想定していない
       *
       * @deprecated SView.getEntityVisibility
       */
      static testVisibilityForMinimap(subject: LEntity, target: LEntity): boolean;
      private static isItem;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SRmmzHelpers' {
  import { FMap } from "ts/mr/floorgen/FMapData";
  import { DEntityCreateInfo, DEntitySpawner2 } from "ts/mr/data/DEntity";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  /**
   * RMMZ データ ($dataXXXX) に依存する処理。
   * これらは もともと rmmz フォルダ内 (RMMZIntegration 等) で定義していたが UnitTest でも使用する必要がでてきたため、
   * Visual レイヤーにアクセスする rmmz フォルダからは独立させたもの。
   */
  export class SRmmzHelpers {
      static readEntityMetadata(event: Game_Event, rmmzMapId: number): DEntitySpawner2 | undefined;
      static createEntitiesFromRmmzFixedMapEventData(rmmzMapId: number): void;
      static createEntityFromRmmzEvent(data: DEntityCreateInfo, eventId: number, x: number, y: number): LEntity;
      static getRegionId(x: number, y: number): number;
      static buildFixedMapData(map: FMap): void;
      private static getTileShape;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SSequel' {
  import { DSequel, DSequelId } from "ts/mr/data/DSequel";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  /**
   * Sequel
   *
   * Sequel 個別にデータを持たせたいときに利用予定 (継承よりはフィールドに持たせた方がいいかも)
   */
  export class SSequelUnit {
      private _entity;
      private _parallel;
      private _args;
      constructor(entity: LEntity, parallel: boolean, args: any | undefined);
      entity(): LEntity;
      isParallel(): boolean;
      args(): any | undefined;
  }
  export class SMotionSequel extends SSequelUnit {
      private _sequelId;
      private _startX;
      private _startY;
      private _targetX;
      private _targetY;
      private _relatedSequels;
      constructor(entity: LEntity, sequelId: DSequelId, targetX: number, targetY: number, args: any | undefined);
      sequelId(): DSequelId;
      data(): DSequel;
      setStartPosition(x: number, y: number): void;
      hasStartPosition(): boolean;
      startX(): number;
      startY(): number;
      targetX(): number;
      targetY(): number;
      isFluidSequence(): boolean;
      relatedSequels(): readonly SMotionSequel[];
      addRelatedSequels(value: SMotionSequel): void;
  }
  export class SAnumationSequel extends SSequelUnit {
      private _anumationlId;
      private _isWait;
      constructor(entity: LEntity, anumationlId: number, wait: boolean);
      anumationlId(): DSequelId;
      isWait(): boolean;
  }
  export class SFloatingAnumationSequel extends SSequelUnit {
      readonly anumationlId: number;
      readonly mx: number;
      readonly my: number;
      private _isWait;
      constructor(entity: LEntity, anumationlId: number, mx: number, my: number, wait: boolean);
      isWait(): boolean;
  }
  export class SBalloonSequel extends SSequelUnit {
      private _balloonId;
      private _isWait;
      constructor(entity: LEntity, balloonId: number, wait: boolean);
      balloonId(): DSequelId;
      isWait(): boolean;
  }
  export class SWaitSequel extends SSequelUnit {
      private _waitCount;
      constructor(entity: LEntity, waitCount: number);
      waitCount(): number;
  }
  /**
   * ある Entity に連続適用する Sequel のリスト。
   *
   * 倍速移動などで、複数の Sequel が追加されることがある。
   */
  export class SSequelClip {
      private _sequels;
      constructor(firstItem: SSequelUnit);
      sequels(): readonly SSequelUnit[];
      entity(): LEntity;
      isParallel(): boolean;
      hasMotionSeque(): boolean;
      add(sequel: SSequelUnit): void;
  }
  /**
   * 並列実行の単位。同時実行できる RESequelClip はまとめてひとつの SequelRun に属する。
   */
  export class SSequelRun {
      private _clips;
      constructor(firstItem: SSequelUnit);
      clips(): readonly SSequelClip[];
      isParallel(): boolean;
      hasMotionSeque(): boolean;
      add(sequel: SSequelUnit): void;
  }
  /**
   * 一連のコマンドチェーン内で発生した Sequel を、並列実行などを考慮して整理して保持する。
   * その後 Visual レイヤーに渡り、アニメーションが実行される。
   */
  export class SSequelSet {
      private _runs;
      private _allParallel;
      private _waitForAll;
      private _isEmpty;
      constructor();
      runs(): readonly SSequelRun[];
      isAllParallel(): boolean;
      isEmpty(): boolean;
      reset(): void;
      waitForAll(): void;
      isWaitForAll(): boolean;
      addSequel(sequel: SSequelUnit): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SSequelContext' {
  import { SSequelUnit } from "ts/mr/system/SSequel";
  export class SSequelContext {
      private _sequelSet;
      trapPerforming: boolean;
      clear(): void;
      isEmptySequelSet(): boolean;
      attemptFlush(force: boolean): void;
      addSequel(sequel: SSequelUnit): void;
      flushSequelSet(waitForAll: boolean): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SSoundManager' {
  export class SSoundManager {
      static playSystemSound(n: number): void;
      static playBgm(sound: IDataSound): void;
      static playSe(sound: IDataSound): void;
      static playEquip(): void;
      static playMiss(): void;
      static playPickItem(): void;
      static playLevelUp(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SStateFactory' {
  import { DStateId } from "ts/mr/data/DState";
  import { LState } from "ts/mr/lively/states/LState";
  export class SStateFactory {
      static newState(stateId: DStateId): LState;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/STurnContext' {
  /**
   * 手番に関係するタイミング通知を受けた処理を明確に定義するためのクラス。
   *
   *
   */
  export class STurnContext {
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/SView' {
  import { DPrefabActualImage } from "ts/mr/data/DPrefab";
  import { LNameView } from "MysteryRogueSystem/ts/mr/lively/internal";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  export interface TilemapViewInfo {
      visible: boolean;
      tilesetId: number | undefined;
  }
  export interface SEntityVisibility {
      visible: boolean;
      translucent: boolean;
      image?: DPrefabActualImage;
  }
  /**
   * 試験運用中。
   *
   * すべて Behavior で賄おうとしていたが、パフォーマンスの影響と複雑化を考慮し、
   * ボトムアップだけの方法ではなくトップダウンで固有の機能を実現する手段を入れてみる。
   */
  export class SView {
      static getLookNames(subject: LEntity, entity: LEntity): LNameView;
      static getTilemapView(): TilemapViewInfo;
      static getMinimapVisibility(entity: LEntity): SEntityVisibility;
      /**
       * subject から entity が可視であるか。
       *
       * 基本的にプレイヤーから見た視界の表示で使用する。
       * AI 用の視界判定処理とは微妙に異なるので注意。
       * 例えば、部屋の外であっても、一度通過したブロックにあるアイテムは可視である。
       *
       * ミニマップの処理とも微妙に違う点に注意。
       * 影無しフロアでは、ミニマップには表示されないが、タイルマップ上に表示されるものもある。
       * つまり、基本的にミニマップ表示判定よりもタイルマップ表示判定の方が強い。
       */
      static getEntityVisibility(entity: LEntity): SEntityVisibility;
      /** 見えなくなる条件をチェックする */
      private static checkEntityInvisible;
      /** 見える条件をチェックする */
      private static checkEntityVisible;
      private static isItem;
  }

}
declare module 'MysteryRogueSystem/ts/mr/system/tasks/STask' {
  import { SCommandResponse } from "MysteryRogueSystem/ts/mr/system/SCommand";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  export type MCEntryProc = () => SCommandResponse;
  export type TaskThenFunc = (c: SSubTaskChain) => STask | void;
  export type TaskCatchFunc = (c: SSubTaskChain) => void;
  export type TaskFinallyFunc = (c: SSubTaskChain) => void;
  export type CommandResultCallback = () => boolean;
  export enum STaskStatus {
      Created = 0,
      Pending = 1,
      Running = 2,
      Succeeded = 3,
      Rejected = 4
  }
  export class STask {
      _status: STaskStatus;
      _name: string;
      _entryFunc: MCEntryProc | undefined;
      _chainFunc: CommandResultCallback | undefined;
      _nextTask: STask | undefined;
      _subChain: SSubTaskChain | undefined;
      _thenFunc2: TaskThenFunc | undefined;
      _catchFunc: TaskCatchFunc | undefined;
      _finallyFunc: TaskFinallyFunc | undefined;
      _callMethod: STaskCallMethod;
      _whenWaitingTasks: STask[];
      _blockingTask: STask | undefined;
      constructor(name: string, entryFunc: MCEntryProc | undefined, chainFunc?: CommandResultCallback | undefined, prev?: STask | undefined);
      get isCompleted(): boolean;
      then(func: CommandResultCallback): STask;
      then2(func: TaskThenFunc): STask;
      thenTask(task: STask): STask;
      catch(func: TaskCatchFunc): this;
      finally(func: TaskFinallyFunc): STask;
      call(cctx: SCommandContext): void;
      prologueCalling(blockTask: STask | void): void;
      checkWaitingTasksStatus(): STaskStatus;
      private setNextPriorityTaskIfNeeded;
  }
  export enum STaskCallMethod {
      Default = 0,
      Then = 1,
      Catch = 2,
      When = 3
  }
  export class SSubTaskChain {
      private _ctx;
      private _firstTask;
      private _currentTask;
      private _error;
      private _errorHandled;
      private _postedMethod;
      private _postedChain;
      _holding: boolean;
      constructor(ctx: SCommandContext, first: STask);
      hold(): void;
      next(): void;
      reject(): void;
      private processOrPost;
      private processInternal;
      private nextInternal;
      private rejectInternal;
      private close;
  }

}
declare module 'MysteryRogueSystem/ts/mr/utility/UAction' {
  import { DRmmzEffectScope } from "ts/mr/data/DEffect";
  import { DSkill } from "ts/mr/data/DSkill";
  import { LGenerateDropItemCause } from "ts/mr/lively/internal";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { LEntityId } from "ts/mr/lively/LObject";
  import { DActionId, DBlockLayerKind } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { LInventoryBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LInventoryBehavior";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { STask } from "MysteryRogueSystem/ts/mr/system/tasks/STask";
  export interface LCandidateSkillAction {
      action: IDataAction;
      targets: LEntityId[];
  }
  export class UAction {
      private static StumbleTable;
      static postEffectSensed(cctx: SCommandContext, entity: LEntity): void;
      static postStepOnGround(cctx: SCommandContext, entity: LEntity): void;
      static postPreStepFeetProcess(cctx: SCommandContext, entity: LEntity): void;
      static postAttemptPerformStepFeetProcess(cctx: SCommandContext, entity: LEntity): void;
      static postFall(cctx: SCommandContext, entity: LEntity): void;
      /** @deprecated */
      static postPickItem(cctx: SCommandContext, self: LEntity, inventory: LInventoryBehavior, itemEntity: LEntity): STask;
      /**
       * entity を現在マップの指定位置へ落とす。"Fall" ではないため、これによって罠が発動したりすることは無い。
       */
      static postDropOrDestroy(cctx: SCommandContext, entity: LEntity, mx: number, my: number): void;
      /**
       * entity を現在位置から HomeLayer へ落とす。"Fall" ではないため、これによって罠が発動したりすることは無い。
       *
       */
      static postDropOrDestroyOnCurrentPos(cctx: SCommandContext, entity: LEntity, targetLayer: DBlockLayerKind): void;
      static postWarp(cctx: SCommandContext, entity: LEntity): void;
      /**
       * 転倒し、アイテムをばらまく。
       * ダメージは入らないので注意。
       * 罠や杖による転倒は微ダメージだが、モンスターのスキルで転倒したときはより大きいダメージが発生するケースもあるため、ここではダメージ処理は行わない。
       */
      static postStumble(cctx: SCommandContext, entity: LEntity, dir: number): void;
      /** 操作中 Unit 用の転倒時アイテムバラまき。インベントリからランダムに選択されたアイテムを、足元ではなく前方にバラまく。 */
      private static postStumbleForPlayer;
      private static postStumbleForNPC;
      static getDefenselessInventoryItems(entity: LEntity): readonly LEntity[];
      /**
       * item を actionId として使うとき、対象アイテムの選択が必要であるかを判断する。
       */
      static checkItemSelectionRequired(item: LEntity, actionId: DActionId): boolean;
      private static checkAdjacentDirectlyAttack;
      /**
       * スキルの効果範囲内にいる、有効な対象を取得する
       * @param performer
       * @param skill
       */
      static getSkillEffectiveTargets(performer: LEntity, skill: DSkill, checkFaction: boolean): LEntity[];
      static makeCandidateSkillActions(performer: LEntity, primaryTargetId: LEntityId): LCandidateSkillAction[];
      static testFactionMatch(performer: LEntity, target: LEntity, scope: DRmmzEffectScope): boolean;
      private static searchTargetEntities;
      /** skillAction の射程範囲内に、有効なターゲットが１つでも含まれているか確認する */
      static checkEntityWithinSkillActionRange(performer: LEntity, skill: DSkill, checkFaction: boolean, targets: LEntity[]): boolean;
      /** effect の射程範囲内に target が含まれているかを確認する */
      /**
       * self の視界内にいる敵対 Entity のうち、一番近いものを検索する。
       */
      static findInSightNearlyHostileEntity(self: LEntity): LEntity | undefined;
      /**
       * 正面に話しかけられる Entity がいれば返す。
       */
      static findTalkableFront(entity: LEntity): LEntity | undefined;
      static postDropItems(cctx: SCommandContext, entity: LEntity, cause: LGenerateDropItemCause): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/utility/UBlock' {
  import { LBlock } from "ts/mr/lively/LBlock";
  import { LMap } from "ts/mr/lively/LMap";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  /**
   * 様々な条件で Block を取得する方法を提供する。
   */
  export class UBlock {
      static pos(a1: any, a2: any): [number, number];
      /** 指定座標の周囲 4 Block を取得する */
      static adjacentBlocks4(map: LMap, x: number, y: number): LBlock[];
      static adjacentBlocks4(map: LMap, block: LBlock, _?: any): LBlock[];
      /** 指定座標の周囲 8 Block を取得する */
      static adjacentBlocks8XY(map: LMap, x: number, y: number): LBlock[];
      /** 指定 Block の周囲 8 Block を取得する */
      static getAdjacentBlocks8(map: LMap, block: LBlock): LBlock[];
      /** 指定した Entity にとって、この Block が浄化属性 (聖域の巻物) となるか */
      static checkPurifier(block: LBlock, entity: LEntity): boolean;
  }

}
declare module 'MysteryRogueSystem/ts/mr/utility/UCommon' {
  export interface SPoint {
      x: number;
      y: number;
  }

}
declare module 'MysteryRogueSystem/ts/mr/utility/UEffect' {
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LRandom } from "MysteryRogueSystem/ts/mr/lively/LRandom";
  import { SEffect } from "MysteryRogueSystem/ts/mr/system/SEffectApplyer";
  export class UResolvedApplyEffectTarget {
      target: LEntity;
      mainTarget: LEntity;
      candidateEffects: SEffect[];
      actualEffects: SEffect[];
      constructor(target: LEntity, mainTarget: LEntity);
  }
  export class UResolvedApplyEffects {
      targets: UResolvedApplyEffectTarget[];
      constructor();
      addCandidateTargetEffect(target: LEntity, mainTarget: LEntity, effect: SEffect): void;
  }
  /**
   * Effect 関係のヘルパー
   */
  export class UEffect {
      static resolveApplyEffects(allEffects: readonly SEffect[], targets: LEntity[], rand: LRandom): UResolvedApplyEffects;
      private static selectCandidateTargetEffects;
      private static resolveApplyEffectsSingleTarget;
      private static meetsCondition;
      private static selectEffect;
      static selectRating<T>(rand: LRandom, items: T[], rating: (item: T) => number): T | undefined;
      /**
       *
       * @param rand
       * @param items
       * @param excludeDiff この値以上離れているレーティングはそもそも採用しない
       * @param rating
       * @returns
       */
      static selectRatingForce<T>(rand: LRandom, items: T[], excludeDiff: number, rating: (item: T) => number): T;
  }

}
declare module 'MysteryRogueSystem/ts/mr/utility/UIdentify' {
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  import { DActionId } from "MysteryRogueSystem/ts/mr/data/DCommon";
  export class UIdentify {
      static identifyByTiming(cctx: SCommandContext, actor: LEntity, target: LEntity, actionId: DActionId, withMessage?: boolean): void;
      /**
       * 指定した Entity を識別する。
       */
      static identify(cctx: SCommandContext, target: LEntity, withMessage: boolean): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/utility/UInventory' {
  import { LInventoryBehavior } from "MysteryRogueSystem/ts/mr/lively/behaviors/LInventoryBehavior";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { SWarehouseDialogResult } from "MysteryRogueSystem/ts/mr/system/SCommon";
  import { STask } from "MysteryRogueSystem/ts/mr/system/tasks/STask";
  export interface SWarehouseActionResult {
      code: SWarehouseDialogResult;
      items: LEntity[];
  }
  export class UInventory {
      /**
       * Inventory のソート。
       *
       * NOTE: LEquipmentUserBehavior を使いたいが、LInventoryBehavior に実装してしまうと import の循環参照が発生するためこちらで実装する。
       */
      static sort(inventory: LInventoryBehavior): void;
      static makeMergedStackables(inventory: LInventoryBehavior): LEntity[];
      /**
       * [預ける]
       */
      static postStoreItemsToWarehouse(cctx: SCommandContext, user: LEntity, warehouse: LEntity, items: readonly LEntity[], outResult: SWarehouseActionResult): STask;
      /**
       * [引き出す]
       */
      static postWithdrawItemsToWarehouse(cctx: SCommandContext, user: LEntity, warehouse: LEntity, items: readonly LEntity[], outResult: SWarehouseActionResult): STask;
      /**
       * [売る]
       */
      static postSellItemsAndDestroy(cctx: SCommandContext, customer: LEntity, items: LEntity[]): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/utility/ULimitations' {
  export class ULimitations {
      static getItemCountInMap(): number;
      static isItemCountFullyInMap(): boolean;
      static getTrapCountInMap(): number;
      static getResidualsTrapCountInMap(): number;
  }

}
declare module 'MysteryRogueSystem/ts/mr/utility/UMovement' {
  import { LBlock } from "ts/mr/lively/LBlock";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { LMap, MovingMethod } from "ts/mr/lively/LMap";
  import { LRandom } from "ts/mr/lively/LRandom";
  import { SCommandContext } from "MysteryRogueSystem/ts/mr/system/SCommandContext";
  import { DBlockLayerKind } from "MysteryRogueSystem/ts/mr/data/DCommon";
  import { LRoom } from "MysteryRogueSystem/ts/mr/lively/LRoom";
  import { SPoint } from "MysteryRogueSystem/ts/mr/utility/UCommon";
  import { LFloorId } from "MysteryRogueSystem/ts/mr/lively/LFloorId";
  export class UMovement {
      private static readonly _edgeOffsetTable;
      private static readonly LHRuleOffsets;
      private static readonly way3Offsets;
      static directions: number[];
      static adjacent8Offsets: number[][];
      static distanceSq(x1: number, y1: number, x2: number, y2: number): number;
      /**
       * 向き反転
       */
      static reverseDir(d: number): number;
      /**
       * 斜め方向であるかを判断する
       */
      static isDiagonalMoving(d: number): boolean;
      /**
       * 2 つの Entity が隣接しているか確認する
       */
      static checkAdjacentEntities(entity1: LEntity, entity2: LEntity): boolean;
      /**
       * 2つの 座標 が隣接しているかどうか
       */
      static checkAdjacentPositions(x1: number, y1: number, x2: number, y2: number): boolean;
      /**
       * 2つの Entity が隣接しているかどうか
       */
      static checkEntityAdjacent(e1: LEntity, e2: LEntity): boolean;
      /**
       * 2つの Entity が直接隣接しているかどうか (壁角を挟んだ斜めは隣接とみなさない)
       */
      static checkDirectlyAdjacentEntity(e1: LEntity, e2: LEntity): boolean;
      /**
       * entity が指定方向(斜め)を向くとき、壁の角と交差しているかを確認する。
       */
      static checkDiagonalWallCornerCrossing(entity: LEntity, d: number): boolean;
      /**
       * entity が指定した方向に歩行移動できるかを確認する。
       */
      static checkPassageToDir(entity: LEntity, dir: number): boolean;
      /**
       * entity が指定した隣接位置へ移動できるかを確認する。
       */
      /**
       * entity が oldBlock から newBlock へ "歩行" 移動できるか判定する。
       *
       * 地形および Block 性質を判断材料とする点に注意。 (Block 種類及び Block 性質と、Entity 性質の確認)
       * 状態異常などによる移動制限は Behavior など他で行う。
       *
       * 移動可否は entity や Block の性質を考慮する。
       * 例えば entity が水路侵入可能であり、Block が水路であれば移動先候補になる。
       */
      static checkPassageBlockToBlock(entity: LEntity, oldBlock: LBlock, newBlock: LBlock, method: MovingMethod, layer?: DBlockLayerKind): boolean;
      /**
       * base が target を向く時の方向を計算する
       */
      static getLookAtDir(base: LEntity, target: LEntity): number;
      /**
       * base が target を向く時の方向を計算する
       */
      static getLookAtDirFromPos(baseX: number, baseY: number, targetX: number, targetY: number): number;
      /**
       * 重心を取得する
       */
      static getCenter(entities: LEntity[]): SPoint;
      /**
       * 重心を取得する
       */
      static getCenterOfRoom(room: LRoom): SPoint;
      /**
       * 方向 d から時計回りに、次の方向を求める
       */
      static getNextDirCW(d: number): number;
      /**
       * 方向 d に対する右手方向を求める
       */
      static getRightDir(d: number): number;
      /**
       * Entity に隣接する指定した方向にある Block を取得する。
       * @param entity
       * @param dir
       * @returns
       */
      static getAdjacentBlock(entity: LEntity, dir: number): LBlock;
      /**
       * Entity の正面の Block を取得する
       */
      static getFrontBlock(entity: LEntity): LBlock;
      /**
       * Entity の周囲 8 マスの Block を取得する。(有効座標のみ)
       */
      static getAdjacentBlocks(entity: LEntity): LBlock[];
      /**
       * Entity の周囲 8 マスの隣接 Entity を取得する。
       * layerKind を指定すると、そのレイヤーだけ取得する。
       * 足元は取得しない。
       * 単純に列挙するだけで、通行判定や攻撃可能判定は行わない。
       */
      static getAdjacentEntities(entity: LEntity, layerKind?: DBlockLayerKind): LEntity[];
      /**
       *
       */
      static getNextAdjacentEntityDirCW(entity: LEntity): number;
      /**
       * 左折の法則に従い、移動候補にできる Block を優先度順に取得する。
       */
      static getMovingCandidateBlockAsLHRule(entity: LEntity, dir: number): LBlock | undefined;
      /**
       * dir 方向の正面 3 Block を取得する。
       */
      static getWay3FrontBlocks(entity: LEntity, dir: number): LBlock[];
      /**
       * "移動" できる隣接 Block を取得する
       */
      static getMovableAdjacentTiles(entity: LEntity): LBlock[];
      private static AdjacentDirs;
      /** entity を配置できる直近の Block を選択する。 */
      static selectNearbyLocatableBlock(rand: LRandom, mx: number, my: number, layerKind: DBlockLayerKind, entity: LEntity): LBlock | undefined;
      static blockDistance(x1: number, y1: number, x2: number, y2: number): number;
      /**
       * 8(↑) 方向を基準としたローカル座標を、dir 方向に回転させたときのローカル座標を求める
       * @param localX
       * @param localY
       * @param dir
       *
       * 隣接ブロックや短い距離の扇形を変換するときなどで使用する。
       * 射程無限など広大な範囲をこれで変換するとパフォーマンスに影響が出るので、
       * そういったものは別途メソッドを用意すること。(TODO:)
       */
      static transformRotationBlock(localX: number, localY: number, dir: number): SPoint;
      /**
       * 8(↑) 方向を基準としたローカル座標を、dir 方向に回転させたときのローカル座標を求める。
       * （ローカル座標は、座標の代わりに向きを指定）
       */
      static rotatePositionByDir(localDir: number, dir: number): SPoint;
      static rotateDir(localDir: number, dir: number): number;
      static checkDashStopBlock(entity: LEntity): boolean;
      static moveEntity(cctx: SCommandContext, entity: LEntity, x: number, y: number, method: MovingMethod, toLayer: DBlockLayerKind): boolean;
      /**
       * Entity の位置設定
       *
       * - moveEntity() と異なり、移動可能判定を行わずに強制移動する。
       * - マップ生成時の Entity 配置や、ワープ移動などで使用する。
       * - Visual に対して位置合わせを通知するため、歩行などアニメーションを伴う移動での使用は禁止。
       * - 侵入判定を伴う。
       */
      static locateEntity(entity: LEntity, x: number, y: number, toLayer?: DBlockLayerKind): void;
      static locateEntityAtFloorMoved(entity: LEntity, floorId: LFloorId, x: number, y: number): void;
      static _postLocate(entity: LEntity, oldBlock: LBlock | undefined, newBlock: LBlock, map: LMap, cctx: SCommandContext | undefined): void;
      private static markPassed;
  }

}
declare module 'MysteryRogueSystem/ts/mr/utility/UName' {
  import { LEntity } from "ts/mr/lively/LEntity";
  export class UName {
      /**
       * [focus] から見た [entity] のユニット名。アイコンを伴わない。
       */
      static makeUnitName(entity: LEntity, viewSubject?: LEntity): string;
      /**
       * アイコンを伴う。識別状態によってテキストの色が変わる。
       */
      static makeNameAsItem(entity: LEntity, viewSubject?: LEntity): string;
  }

}
declare module 'MysteryRogueSystem/ts/mr/utility/UProperty' {
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  export class UProperty {
      static setValue(key: string, path: string, value: any): void;
      static getValue(key: string, path: string): any;
      static getValueFromEntity(entity: LEntity, path: string): any;
      private static getObject;
      static getValueByVariablePattern(pattern: string): unknown;
  }
  export enum UComponentType {
      Entity = 0,
      Param = 1,
      State = 2,
      Ability = 3
  }
  /**
   *
   * 書式:
   * ```
   * [componentType:][componentName.]propertyName
   * ```
   *
   * 将来的に、だが、例えば State の持続時間を指定したいときは、
   * - "State[睡眠]:turns", 20
   * State の持っている behabior のプロパティを指定したいときは、
   * - "State(睡眠):generic.xxxx", 20
   */
  export class UPropertyPath {
      componentType: UComponentType;
      element: string | undefined;
      behaviorName: string | undefined;
      propertyName: string | undefined;
      constructor(path: string);
      private parseComponentType;
  }

}
declare module 'MysteryRogueSystem/ts/mr/utility/USearch' {
  import { LBlock } from "MysteryRogueSystem/ts/mr/lively/LBlock";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { LRandom } from "MysteryRogueSystem/ts/mr/lively/LRandom";
  /**
   * 攻撃対象範囲などの検索ヘルパー
   */
  export class USearch {
      /**
       * 失明状態であるか (self は他を視認できないか)
       */
      static hasBlindness(self: LEntity): boolean;
      /**
       * 可視であるか
       */
      static isVisible(target: LEntity): boolean;
      /**
       * subject から見て target は可視であるか
       * ※視界内か、ではない点に注意
       */
      static isVisibleFromSubject(subject: LEntity, target: LEntity): boolean;
      /**
       * subject から見て、 target は視界内であるか。
       * ※可視であるか、ではない点に注意。この関数は地形や位置関係による視界チェックとなる。
       */
      static checkInSightEntity(subject: LEntity, target: LEntity): boolean;
      /**
       * subject から見て、 block は可視であるか
       * @param subject
       * @param block
       */
      static checkInSightBlockFromSubject(subject: LEntity, block: LBlock): boolean;
      /**
       * 指定された entity が中立的なアイテムか(=普通に誰でも拾うことができるか)
       */
      static isNeutralItem(entity: LEntity): boolean;
      /**
       * mx, my を中心として、length タイル分離れた位置を列挙する。
       * length=1 の場合は周囲 8 マス。
       * 外周のみ列挙するため、2マス範囲内を全て列挙したい場合は lengthに 1,2を与えて複数回この関数を呼び出すこと。
       * 列挙順は左上から時計回り。
       */
      static iterateAroundPositions(mx: number, my: number, length: number, func: (mx: number, my: number) => void): void;
      /**
       * iterateAroundPositions() を使用して、有効 Block を列挙する。
       */
      static iterateAroundBlocks(mx: number, my: number, length: number, withCenter: boolean, func: (block: LBlock) => void): void;
      /**
       * iterateAroundPositions() を使用して、範囲に含まれている全ての Entity を列挙する。
       */
      static iterateAroundEntities(mx: number, my: number, length: number, withCenter: boolean, func: (entity: LEntity) => void): void;
      static getFirstUnderFootEntity(entity: LEntity): LEntity | undefined;
      /**
       * Unit が出現可能な Block を選択する。
       */
      static selectUnitSpawnableBlock(rand: LRandom): LBlock | null;
      /**
       * 指定した Entity が、scope 範囲内に含まれているかを確認する
       */
      /**
       * entity の視界内にある最も後に出現したアイテムを探す
       */
      static findLatestItemInVisibilityBlocks(entity: LEntity): LEntity | undefined;
      /**
       * 指定した向きへまっすぐ向かったとき、最初にぶつかる壁を取得する。
       * (mx,my) は含まない。
       */
      static findFirstWallInDirection(mx: number, my: number, dir: number): LBlock;
      static getUniqueActorByKey(key: string): LEntity;
      static getEntityByKeyPattern(keyPattern: string): LEntity;
  }

}
declare module 'MysteryRogueSystem/ts/mr/utility/USpawner' {
  import { DEntity } from "ts/mr/data/DEntity";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { LFloorId } from "ts/mr/lively/LFloorId";
  import { LRandom } from "MysteryRogueSystem/ts/mr/lively/LRandom";
  export class USpawner {
      static spawnSingleEntity(entityKey: string, mx: number, my: number): LEntity;
      static getEnemiesFromSpawnTable(floorId: LFloorId): DEntity[];
      /**
       * 指定したフロアの出現テーブルから、アイテムを作成する。
       * 作成したアイテムはマップ上に出現していない。
       */
      static createItemFromSpawnTable(floorId: LFloorId, rand: LRandom): LEntity | undefined;
      /**
       * 指定したフロアの出現テーブルから、罠を作成する。
       * 作成したアイテムはマップ上に出現していない。
       */
      static createTrapFromSpawnTable(floorId: LFloorId, rand: LRandom): LEntity | undefined;
      static createItemFromSpawnTableOrDefault(floorId: LFloorId, rand: LRandom): LEntity;
  }

}
declare module 'MysteryRogueSystem/ts/mr/utility/UState' {
  import { LStateLevelType } from "ts/mr/data/DEffect";
  import { DState, DStateId } from "ts/mr/data/DState";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { LState } from "ts/mr/lively/states/LState";
  export interface StateAddition {
      stateId: DStateId;
      level: number;
      levelType: LStateLevelType;
  }
  export class UState {
      private static effect;
      /**
       * ステート追加・削除のメイン処理
       *
       * ステートには能力値の変化を与えるものや、現在の能力値によって自動付加されるものがある。
       * 例えばステートをまとめて追加する場合、ひとつ追加するたびに自動付加の判定を行うと、
       * 想定外のステート追加が一瞬発生してすぐ削除されるなど予測しづらい副作用を伴うことがある。
       *
       * そのため一度にまとめて追加する場合はまず先にすべてのステートを評価し、
       * 本当に消すべきもの・残すべきもの・追加するべきものを判断して必要な操作だけを行えるようにする。
       */
      static resolveStates(entity: LEntity, newStates: StateAddition[], removeStateIds: DStateId[]): LState[];
      private static selectEffectIndex;
      private static meetsConditions;
      private static checkRemoveAtActualParam;
      static attemptRemoveStateAtFloorTransfer(entity: LEntity): void;
      static meetsApplyConditions(state: DState, target: LEntity): boolean;
  }

}
declare module 'MysteryRogueSystem/ts/mr/utility/UTransfer' {
  import { LandExitResult } from "ts/mr/data/MRData";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  export class UTransfer {
      /**
       * RMMZ コアスクリプト側からの マップ(と Player Entity) 遷移。
       * ニューゲーム時や [場所移動] イベントなどで使用する。
       */
      static transterRmmzDirectly(newMapId: number, newX: number, newY: number): void;
      /**
       * entity を今いる Land から抜けさせ、ExitMap へ移動させる。
       */
      static exitLand(cctx: SCommandContext, entity: LEntity, result: LandExitResult): void;
      static proceedFloorForwardForPlayer(interpreter?: Game_Interpreter | undefined): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/animation/VAnimation' {
  import { TEasing } from "MysteryRogueSystem/ts/mr/view/animation/VEasing";
  /** アニメーションの繰り返し方法 */
  export enum VAnimationWrapMode {
      /** 繰り返しを行わず、1度だけ再生します。 */
      Once = 0,
      /** 最後まで再生された後、先頭に戻ってループします。 */
      Loop = 1,
      /** 最後まで再生された後、逆方向に戻ってループします。 */
      Alternate = 2
  }
  export class VAnimationCurve {
      private _wrapMode;
      constructor();
      /** 指定した時間における値を評価します。*/
      evaluate(time: number): number;
      /** アニメーションの終端の時間を取得します。 */
      lastFrameTime(): number;
      /** アニメーションの繰り返しの動作を取得します。 */
      wrapMode(): VAnimationWrapMode;
      /** アニメーションの繰り返しの動作を設定します。(default: Once) */
      setWrapMode(mode: VAnimationWrapMode): void;
      protected onEvaluate(time: number): number;
      protected onGetLastFrameTime(): number;
      private calculateLocalTime;
  }
  export class VEasingAnimationCurve extends VAnimationCurve {
      _startValue: number;
      _targetValue: number;
      _duration: number;
      _func: TEasing;
      constructor(startValue: number, targetValue: number, duration: number, func: TEasing);
      protected onEvaluate(time: number): number;
      protected onGetLastFrameTime(): number;
  }
  export enum VKeyFrameTangentMode {
      /** 線形補間 */
      Linear = 0,
      /** 接線 (速度) を使用した補間 (エルミートスプライン) */
      Tangent = 1,
      /** キーフレームの値を通過するなめらかな補間 (Catmull-Rom) */
      Auto = 2,
      /** 補間なし */
      Constant = 3
  }
  export interface VKeyFrame {
      /** 時間 */
      time: number;
      /** 値 */
      value: number;
      /** 前のキーフレームとの補間方法 */
      leftTangentMode: VKeyFrameTangentMode;
      /** 前のキーフレームからこのキーフレームに近づくときの接線 */
      leftTangent: number;
      /** 次のキーフレームとの補間方法 */
      rightTangentMode: VKeyFrameTangentMode;
      /** このキーフレームから次のキーフレームに向かうときの接線 */
      rightTangent: number;
  }
  export class VKeyFrameAnimationCurve extends VAnimationCurve {
      private _keyFrames;
      private _defaultValue;
      constructor();
      addKeyFrame(keyFrame: VKeyFrame): void;
      addFrame(time: number, value: number, rightTangentMode?: VKeyFrameTangentMode, tangent?: number): this;
      onEvaluate(time: number): number;
      onGetLastFrameTime(): number;
      private findKeyFrameIndex;
      private hermite;
      private catmullRom;
  }
  export class VAnimationInstance {
      key: string;
      curve: VAnimationCurve;
      setter: (v: number) => void;
      time: number;
      _then: (() => void) | undefined;
      constructor(/*container: PIXI.Container,*/ key: string, curve: VAnimationCurve, setter: (v: number) => void);
      update(elapsedTime: number): void;
      isFinished(): boolean;
      then(func: () => void): void;
  }
  export class VAnimation {
      private static _containers;
      static start(container: PIXI.Container, key: string, curve: VAnimationCurve, setter: (v: number) => void, timeOffset?: number): VAnimationInstance;
      /**
       * start に対してこちらは現在値を始点とした相対的なアニメーションを表現するのに使用する。
       */
      static startAt(container: PIXI.Container, key: string, start: number, target: number, duration: number, curve: TEasing, setter: (v: number) => void, timeOffset?: number): VAnimationInstance;
      static add(container_: PIXI.Container, key: string, instance: VAnimationInstance): void;
      static stop(container_: PIXI.Container, key: string): void;
      static stopAll(container_: PIXI.Container): void;
      static update(): void;
      private static refresh;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/animation/VEasing' {
  export type TEasing = (time: number) => number;
  export interface IEasingMap {
      linear: TEasing;
      quadratic: TEasing;
      cubic: TEasing;
      elastic: TEasing;
      inQuad: TEasing;
      outQuad: TEasing;
      inOutQuad: TEasing;
      inCubic: TEasing;
      outCubic: TEasing;
      inOutCubic: TEasing;
      inQuart: TEasing;
      outQuart: TEasing;
      inOutQuart: TEasing;
      inQuint: TEasing;
      outQuint: TEasing;
      inOutQuint: TEasing;
      inSine: TEasing;
      outSine: TEasing;
      inOutSine: TEasing;
      inExpo: TEasing;
      outExpo: TEasing;
      inOutExpo: TEasing;
      inCirc: TEasing;
      outCirc: TEasing;
      inOutCirc: TEasing;
  }
  export const easing: IEasingMap;

}
declare module 'MysteryRogueSystem/ts/mr/view/dialogs/REDialogVisual' {
  import { SDialog } from "ts/mr/system/SDialog";
  import { SDialogContext } from "ts/mr/system/SDialogContext";
  import { VDialog } from "MysteryRogueSystem/ts/mr/view/dialogs/VDialog";
  export type DialogResultCallback = (dialog: any) => void;
  /**
   * SceneManager と同じく、スタックで Sub Dialog を管理するクラス。
   *
   * SceneManager でメニュー表示などを実装すると、ウィンドウが表示されたときには Scene_Map の表示情報はすべて破棄されている。
   * そのため、ウィンドウを表示したままキャラクターをアニメーションさせることができない。
   *
   * このクラスはその対策として、Scene_Map 内でウィンドウの遷移管理を行う。
   */
  export class REDialogVisualNavigator {
      _subDialogs: VDialog[];
      _scene: VDialog | undefined;
      _nextScene: VDialog | undefined;
      _destroyList: VDialog[];
      constructor();
      isEmpty(): boolean;
      _openDialog(dialog: VDialog): void;
      markCloseDialog(context: SDialogContext, model: SDialog): void;
      private push;
      private pop;
      clear2(): void;
      update(context: SDialogContext): void;
      private changeScene;
      private updateScene;
      lateUpdate(): void;
      private destryDialogs;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/dialogs/REEventExecutionDialogVisual' {
  import { SEventExecutionDialog } from "ts/mr/system/dialogs/SEventExecutionDialog";
  import { VDialog } from "MysteryRogueSystem/ts/mr/view/dialogs/VDialog";
  export class REEventExecutionDialogVisual extends VDialog {
      private _model;
      constructor(model: SEventExecutionDialog);
      onCreate(): void;
      onUpdate(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/dialogs/VDetailsDialog' {
  import { VDialog } from "MysteryRogueSystem/ts/mr/view/dialogs/VDialog";
  import { SDetailsDialog } from "ts/mr/system/dialogs/SDetailsDialog";
  export class VDetailsDialog extends VDialog {
      private _model;
      private _window;
      constructor(model: SDetailsDialog);
      onCreate(): void;
      onUpdate(): void;
      private handleClose;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/dialogs/VDialog' {
  import { SDialog } from "ts/mr/system/SDialog";
  import { REDialogVisualNavigator } from "MysteryRogueSystem/ts/mr/view/dialogs/REDialogVisual";
  import { SDialogContext } from "ts/mr/system/SDialogContext";
  import { SCommandContext } from "ts/mr/system/SCommandContext";
  export class VDialog {
      private _baseModel;
      _created: boolean;
      _started: boolean;
      _navigator: REDialogVisualNavigator | undefined;
      _windows: Window_Base[];
      private _activeWindow;
      _closing: boolean;
      protected constructor(model: SDialog);
      get model(): SDialog;
      protected dialogContext(): SDialogContext;
      protected commandContext(): SCommandContext;
      /** @deprecated */
      protected openSubDialog<T extends SDialog>(dialog: T, onResult: (model: T) => boolean): void;
      protected submit(): void;
      protected cancel(): void;
      protected closeAllSubDialogs(): void;
      onCreate(): void;
      onStart(): void;
      onUpdate(): void;
      onClose(): void;
      onStop(): void;
      onDestroy(): void;
      protected addWindow(window: Window_Base): void;
      private _removeWindow;
      protected activateWindow(window: Window_Base): void;
      _destroy(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/dialogs/VFeetDialog' {
  import { SFeetDialog } from "ts/mr/system/dialogs/SFeetDialog";
  import { VDialog } from "MysteryRogueSystem/ts/mr/view/dialogs/VDialog";
  import { VFlexCommandWindow } from "MysteryRogueSystem/ts/mr/view/windows/VFlexCommandWindow";
  import { VEntityCaptionWindow } from "MysteryRogueSystem/ts/mr/view/windows/VEntityCaptionWindow";
  /**
   * [足元]
   */
  export class VFeetDialog extends VDialog {
      _model: SFeetDialog;
      _entityNameWindow: VEntityCaptionWindow;
      _commandWindow: VFlexCommandWindow;
      constructor(model: SFeetDialog);
      private handleDetails;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/dialogs/VItemListDialog' {
  import { SItemListDialog } from "ts/mr/system/dialogs/SItemListDialog";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { VFlexCommandWindow } from "MysteryRogueSystem/ts/mr/view/windows/VFlexCommandWindow";
  import { VItemListDialogBase } from "MysteryRogueSystem/ts/mr/view/dialogs/VItemListDialogBase";
  export class VItemListDialog extends VItemListDialogBase {
      private _model;
      /**
       *
       * @param actorEntity
       * @param inventory
       *
       * actorEntity はアイテム使用者。
       * 必ずしも Inventory を持っている Entity ではない点に注意。
       * 足元に置いてある壺の中を覗いたときは、actorEntity は Player となる。
       */
      constructor(model: SItemListDialog);
      onCreate(): void;
      onUpdate(): void;
      onSelectedItemsChanged(items: LEntity[]): void;
      onMakeCommandList(window: VFlexCommandWindow): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/dialogs/VItemListDialogBase' {
  import { LInventoryBehavior } from "ts/mr/lively/behaviors/LInventoryBehavior";
  import { LEntity } from "ts/mr/lively/LEntity";
  import { SDialog } from "ts/mr/system/SDialog";
  import { VFlexCommandWindow } from "MysteryRogueSystem/ts/mr/view/windows/VFlexCommandWindow";
  import { VItemListWindow } from "MysteryRogueSystem/ts/mr/view/windows/VItemListWindow";
  import { VDialog } from "MysteryRogueSystem/ts/mr/view/dialogs/VDialog";
  export enum VItemListMode {
      Use = 0,
      Selection = 1
  }
  export class VItemListDialogBase extends VDialog {
      private _inventory;
      private _itemListWindow;
      private _commandWindow;
      private _mode;
      constructor(inventory: LInventoryBehavior, model: SDialog, mode: VItemListMode);
      get itemListWindow(): VItemListWindow;
      get commandWindow(): VFlexCommandWindow;
      onCreate(): void;
      onUpdate(): void;
      protected onSelectedItemsChanged(items: LEntity[]): void;
      protected onSelectionSubmit(): void;
      protected onMakeCommandList(window: VFlexCommandWindow): void;
      protected activateCommandWindow(): void;
      private handleItemSubmit;
      private handleItemCancel;
      private handleCommandCancel;
      private handleNickname;
      private handleDetails;
      private activateItemWindow;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/dialogs/VItemSelectionDialog' {
  import { VItemListDialogBase } from "MysteryRogueSystem/ts/mr/view/dialogs/VItemListDialogBase";
  import { SItemSelectionDialog } from "ts/mr/system/dialogs/SItemSelectionDialog";
  export class VItemSelectionDialog extends VItemListDialogBase {
      private _model;
      /**
       *
       * @param actorEntity
       * @param inventory
       *
       * actorEntity はアイテム使用者。
       * 必ずしも Inventory を持っている Entity ではない点に注意。
       * 足元に置いてある壺の中を覗いたときは、actorEntity は Player となる。
       */
      constructor(model: SItemSelectionDialog);
      onCreate(): void;
      onUpdate(): void;
      onSelectionSubmit(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/dialogs/VItemSellDialog' {
  import { VFlexCommandWindow } from "MysteryRogueSystem/ts/mr/view/windows/VFlexCommandWindow";
  import { VItemListDialogBase } from "MysteryRogueSystem/ts/mr/view/dialogs/VItemListDialogBase";
  import { SItemSellDialog } from "ts/mr/system/dialogs/SItemSellDialog";
  export class VItemSellDialog extends VItemListDialogBase {
      private _model;
      constructor(model: SItemSellDialog);
      protected onMakeCommandList(window: VFlexCommandWindow): void;
      private handleSell;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/dialogs/VManualActionDialogVisual' {
  import { SManualActionDialog } from "ts/mr/system/dialogs/SManualDecisionDialog";
  import { VDialog } from "MysteryRogueSystem/ts/mr/view/dialogs/VDialog";
  export class VManualActionDialogVisual extends VDialog {
      private readonly MovingInputInterval;
      private _model;
      private _updateMode;
      private _waitCount;
      private _directionButtonPresseCount;
      private _moveButtonPresseCount;
      private _movingInputWaitCount;
      private _crossDiagonalCount;
      constructor(model: SManualActionDialog);
      private actionButton;
      private shortcutButton;
      private dashButton;
      private directionButton;
      private isOffDirectionButton;
      private isDashButtonPressed;
      private isMoveButtonPressed;
      onStop(): void;
      onUpdate(): void;
      private updateInput;
      private updateNormal;
      private endDirectionSelecting;
      private updateDirSelecting;
      private updateDiagonalMoving;
      private attemptMoveEntity;
      private attemptFrontAction;
      private attemptShortcutAction;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/dialogs/VMenuDialog' {
  import { SMainMenuDialog } from "ts/mr/system/dialogs/SMainMenuDialog";
  import { VMenuCommandWindow } from "MysteryRogueSystem/ts/mr/view/windows/VMenuCommandWindow";
  import { VDialog } from "MysteryRogueSystem/ts/mr/view/dialogs/VDialog";
  import { VMainStatusWindow } from "MysteryRogueSystem/ts/mr/view/windows/VMainStatusWindow";
  export class VMainMenuDialog extends VDialog {
      _model: SMainMenuDialog;
      _commandWindow: VMenuCommandWindow | undefined;
      _statusWindow: VMainStatusWindow;
      constructor(model: SMainMenuDialog);
      onCreate(): void;
      onStart(): void;
      private handleItem;
      private handleFeet;
      private handleSave;
      private handleSuspend;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/dialogs/VNicknameDialog' {
  import { VDialog } from "MysteryRogueSystem/ts/mr/view/dialogs/VDialog";
  import { SNicknameDialog } from "ts/mr/system/dialogs/SNicknameDialog";
  import { VNicknameEditWindow } from "MysteryRogueSystem/ts/mr/view/windows/VNicknameEditWindow";
  import { VNicknameInputWindow } from "MysteryRogueSystem/ts/mr/view/windows/VNicknameInputWindow";
  /**
   * 未識別アイテムの名前付け
   */
  export class VNicknameDialog extends VDialog {
      _model: SNicknameDialog;
      _editWindow: VNicknameEditWindow;
      _inputWindow: VNicknameInputWindow;
      constructor(model: SNicknameDialog);
      private editWindowRect;
      private inputWindowRect;
      private handleInputOk;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/dialogs/VWarehouseDialog' {

}
declare module 'MysteryRogueSystem/ts/mr/view/dialogs/VWarehouseStoreDialog' {
  import { SWarehouseStoreDialog } from "ts/mr/system/dialogs/SWarehouseStoreDialog";
  import { VFlexCommandWindow } from "MysteryRogueSystem/ts/mr/view/windows/VFlexCommandWindow";
  import { VItemListDialogBase } from "MysteryRogueSystem/ts/mr/view/dialogs/VItemListDialogBase";
  export class VWarehouseStoreDialog extends VItemListDialogBase {
      _model: SWarehouseStoreDialog;
      private _capacityWindow;
      constructor(model: SWarehouseStoreDialog);
      onMakeCommandList(window: VFlexCommandWindow): void;
      private handleStore;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/dialogs/VWarehouseWithdrawDialog' {
  import { SWarehouseWithdrawDialog } from "ts/mr/system/dialogs/SWarehouseWithdrawDialog";
  import { VFlexCommandWindow } from "MysteryRogueSystem/ts/mr/view/windows/VFlexCommandWindow";
  import { VItemListDialogBase } from "MysteryRogueSystem/ts/mr/view/dialogs/VItemListDialogBase";
  export class VWarehouseWithdrawDialog extends VItemListDialogBase {
      private _model;
      private _capacityWindow;
      constructor(model: SWarehouseWithdrawDialog);
      protected onMakeCommandList(window: VFlexCommandWindow): void;
      private handleWithdraw;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/MRView' {
  import { VMapEditor } from "ts/mr/rmmz/VMapEditor";
  import { REEntityVisualSet } from "MysteryRogueSystem/ts/mr/view/REEntityVisualSet";
  import { MRVisualExtension } from "MysteryRogueSystem/ts/mr/view/MRVisualExtension";
  import { REVisual_Manager } from "MysteryRogueSystem/ts/mr/view/REVisual_Manager";
  import { VMapGuideGrid } from "MysteryRogueSystem/ts/mr/view/VMapGuideGrid";
  import { VMessageWindowSet } from "MysteryRogueSystem/ts/mr/view/VMessageWindowSet";
  import { VSpriteSet } from "MysteryRogueSystem/ts/mr/view/VSpriteSet";
  import { VChallengeResultWindow } from "MysteryRogueSystem/ts/mr/view/windows/VChallengeResultWindow";
  /**
   * REシステムと RMMZ の橋渡しを行うモジュールのルートクラス。
   *
   * Game_XXXX モジュールと連携する必要があるため、インスタンスの寿命はグローバル (NewGame のたびに生成)
   *
   * 普通のプラグインであれば Scene_Map を拡張してそこに持たせるべきな情報もこちらに持たせているが、
   * これは他プラグインとの競合対策や Scene_Map の拡張による複雑化防止のため。
   */
  export class MRView {
      static ext: MRVisualExtension;
      static manager: REVisual_Manager | undefined;
      static mapBuilder: VMapEditor | undefined;
      static scene: Scene_Map;
      static entityVisualSet: REEntityVisualSet | undefined;
      static spriteset: Spriteset_Map | undefined;
      static _challengeResultWindow: VChallengeResultWindow;
      static _messageWindowSet: VMessageWindowSet;
      static spriteSet2: VSpriteSet | undefined;
      static guideGrid: VMapGuideGrid | undefined;
      static _syncCamera: boolean;
      static _playerPosRefreshNeed: boolean;
      static initialize(): void;
      static onSceneChanged(scene: Scene_Map): void;
      static finalize(): void;
      static update(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/MRVisualExtension' {
  export class MRVisualExtension {
      onMapVisualSetup(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/REEntityVisualSet' {
  import { LEntity } from "ts/mr/lively/LEntity";
  import { REVisualSequelManager } from "MysteryRogueSystem/ts/mr/view/REVisualSequelManager";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  /**
   * EntityVisual の管理クラス。
   *
   * Spriteset_Map と同じように、Scene_Map の生成・破棄に合わせて Sprite の表示状態を制御する。
   * 実際にこのクラスが Sprite を生成するものではない点に注意。
   *
   * なお、Spriteset_Map は SceneManager.onBeforeSceneStart() からの Scene(PIXI.Stage) の destory により破棄される。
   */
  export class REEntityVisualSet {
      private _visualEntities;
      private _sequelManager;
      constructor();
      resetVisuals(): void;
      entityVisuals(): REVisual_Entity[];
      ternimate(): void;
      update(): void;
      sequelManager(): REVisualSequelManager;
      findEntityVisualByEntity(entity: LEntity): REVisual_Entity | undefined;
      getEntityVisualByEntity(entity: LEntity): REVisual_Entity;
      findEntityVisualByRMMZEventId(rmmzEventId: number): REVisual_Entity | undefined;
      visualRunning(): boolean;
      reserveDeleteVisual(entity: LEntity): void;
      private deleteVisuals;
      private detachVisual;
      private handleFlushSequelSet;
      createVisual2(entity: LEntity): void;
      private createVisual;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/REVisualSequel' {
  import { REVisualSequelContext } from "MysteryRogueSystem/ts/mr/view/REVisualSequelContext";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  export abstract class REVisualSequel {
      abstract onUpdate(visual: REVisual_Entity, context: REVisualSequelContext): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/REVisualSequelContext' {
  import { Vector2 } from "ts/mr/math/Vector2";
  import { SSequelUnit, SSequelClip } from "ts/mr/system/SSequel";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  export class REVisualSequelContext {
      private _entityVisual;
      private _clip;
      private _currentClip;
      private _frameCount;
      private _timeScale;
      private _cuurentFinished;
      private _cancellationLocked;
      private _currentSequel;
      private _currentVisualSequel;
      private _startPosition;
      private _currentIdleSequelId;
      private _animationWaiting;
      private _balloonWaiting;
      private _waitFrameCount;
      constructor(entityVisual: REVisual_Entity);
      sequel(): SSequelUnit;
      frameCount(): number;
      timeScale(): number;
      isDashing(): boolean;
      /** Sequel 開始時の Visual の position */
      startPosition(): Vector2;
      finished(): boolean;
      isCancellationLocked(): boolean;
      private isAnimationWaintng;
      isFrameWaiting(): boolean;
      isLogicalCompleted2(): boolean;
      isLogicalCompleted(globalWaiting: boolean): boolean;
      lockCamera(): void;
      unlockCamera(): void;
      unlockCancellation(): void;
      startAnimation(rmmzAnimationId: number): void;
      end(): void;
      _start(clip: SSequelClip): void;
      _next(): void;
      private _startSequel;
      private _startAnimation;
      private _startFloatingAnimation;
      private _startBalloon;
      private _startWaitSequel;
      _update(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/REVisualSequelManager' {
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  import { SSequelSet } from "MysteryRogueSystem/ts/mr/system/SSequel";
  import { REEntityVisualSet } from "MysteryRogueSystem/ts/mr/view/REEntityVisualSet";
  export class REVisualSequelManager {
      private _entityVisualSet;
      private _activeSequelSet;
      private _currentSequelRun;
      private _runningVisuals;
      constructor(entityVisualSet: REEntityVisualSet);
      setup(sequelSet: SSequelSet): void;
      update(): void;
      postUpdate(): void;
      onFinishedAllSequels(): void;
      isRunning(): boolean;
      removeVisual(visual: REVisual_Entity): void;
      private isLogicalCompleted;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/REVisual_Entity' {
  import { DSequelId } from "ts/mr/data/DSequel";
  import { Vector2 } from "ts/mr/math/Vector2";
  import { REVisualSequelContext } from "ts/mr/view/REVisualSequelContext";
  import { LEntity } from "MysteryRogueSystem/ts/mr/lively/LEntity";
  import { SEntityVisibility } from "ts/mr/system/SView";
  import { DPrefabActualImage } from "ts/mr/data/DPrefab";
  /**
   * Entity の「見た目」を表現するためのクラス。
   *
   * RMMZ 向けのこのクラスの実装では、直接 Sprite を出したりするわけではない点に注意。
   * Mnager からのインスタンス生成と同時に、動的に Game_Event が生成され、このクラスはその Game_Event を操作する。
   */
  export class REVisual_Entity {
      private _entity;
      private _rmmzEventId;
      private _rmmzSpriteIndex;
      private _sequelContext;
      private _initialUpdate;
      private _position;
      private _visibilityOpacityStart;
      private _visibilityOpacityTarget;
      private _visibilityFrame;
      private _prevVisibility;
      private _visibility;
      private _actualImage;
      private _sequelOpacity;
      reservedDestroy: boolean;
      visualTransparent: boolean;
      constructor(entity: LEntity, rmmzEventId: number);
      entity(): LEntity;
      rmmzEventId(): number;
      rmmzEvent(): Game_Event;
      rmmzSpriteIndex(): number;
      rmmzSprite(): Sprite_Character | undefined;
      getRmmzSprite(): Sprite_Character;
      isVisible(): boolean;
      position(): Vector2;
      x(): number;
      y(): number;
      setX(value: number): void;
      setY(value: number): void;
      setPosition(value: Vector2): void;
      resetPosition(): void;
      sequelContext(): REVisualSequelContext;
      getIdleSequelId(): DSequelId;
      _setSpriteIndex(value: number): void;
      actualImage(): DPrefabActualImage;
      setOpacity(value: number): void;
      private imageOverriden;
      _update(): void;
      private updateOpacity;
      getCharacterImage(entity: LEntity, visibility: SEntityVisibility): DPrefabActualImage | undefined;
      private getActualOpacity;
      showEffectResult(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/REVisual_Manager' {
  import { Vector2 } from "ts/mr/math/Vector2";
  import { REDialogVisualNavigator } from "ts/mr/view/dialogs/REDialogVisual";
  import { REVisualSequel } from "ts/mr/view/REVisualSequel";
  import { DSequelId } from "ts/mr/data/DSequel";
  import { SDialog } from "ts/mr/system/SDialog";
  /**
   */
  export class REVisual_Manager {
      private _tileSize;
      private _visualSequelFactory;
      readonly dialogNavigator: REDialogVisualNavigator;
      constructor();
      tileSize(): Vector2;
      _finalize(): void;
      createVisualSequel(sequelId: DSequelId): REVisualSequel;
      openDialog(model: SDialog): void;
      startFloatingAnimation(animationId: number, mx: number, my: number): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/sequels/AttackSequel' {
  import { REVisualSequel } from "MysteryRogueSystem/ts/mr/view/REVisualSequel";
  import { REVisualSequelContext } from "MysteryRogueSystem/ts/mr/view/REVisualSequelContext";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  export class VAttackSequel extends REVisualSequel {
      onUpdate(visual: REVisual_Entity, context: REVisualSequelContext): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/sequels/VAsleepSequel' {
  import { REVisualSequel } from "MysteryRogueSystem/ts/mr/view/REVisualSequel";
  import { REVisualSequelContext } from "MysteryRogueSystem/ts/mr/view/REVisualSequelContext";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  export class VAsleepSequel extends REVisualSequel {
      onUpdate(visual: REVisual_Entity, context: REVisualSequelContext): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/sequels/VBlowMoveSequel' {
  import { REVisualSequel } from "MysteryRogueSystem/ts/mr/view/REVisualSequel";
  import { REVisualSequelContext } from "MysteryRogueSystem/ts/mr/view/REVisualSequelContext";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  /**
   * 吹き飛ばされ移動。
   * 矢を撃つのとは別なので注意。
   */
  export class VBlowMoveSequel extends REVisualSequel {
      onUpdate(visual: REVisual_Entity, context: REVisualSequelContext): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/sequels/VCollapseSequel' {
  import { REVisualSequel } from "MysteryRogueSystem/ts/mr/view/REVisualSequel";
  import { REVisualSequelContext } from "MysteryRogueSystem/ts/mr/view/REVisualSequelContext";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  export class VCollapseSequel extends REVisualSequel {
      onUpdate(visual: REVisual_Entity, context: REVisualSequelContext): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/sequels/VCommonStoppedSequel' {
  import { REVisualSequel } from "MysteryRogueSystem/ts/mr/view/REVisualSequel";
  import { REVisualSequelContext } from "MysteryRogueSystem/ts/mr/view/REVisualSequelContext";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  export class VCommonStoppedSequel extends REVisualSequel {
      onUpdate(visual: REVisual_Entity, context: REVisualSequelContext): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/sequels/VDownSequel' {
  import { REVisualSequel } from "MysteryRogueSystem/ts/mr/view/REVisualSequel";
  import { REVisualSequelContext } from "MysteryRogueSystem/ts/mr/view/REVisualSequelContext";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  export class VDownSequel extends REVisualSequel {
      onUpdate(visual: REVisual_Entity, context: REVisualSequelContext): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/sequels/VDropSequel' {
  import { REVisualSequel } from "MysteryRogueSystem/ts/mr/view/REVisualSequel";
  import { REVisualSequelContext } from "MysteryRogueSystem/ts/mr/view/REVisualSequelContext";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  export class VDropSequel extends REVisualSequel {
      onUpdate(visual: REVisual_Entity, context: REVisualSequelContext): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/sequels/VEarthquake2Sequel' {
  import { REVisualSequel } from "MysteryRogueSystem/ts/mr/view/REVisualSequel";
  import { REVisualSequelContext } from "MysteryRogueSystem/ts/mr/view/REVisualSequelContext";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  export class VEarthquake2Sequel extends REVisualSequel {
      onUpdate(visual: REVisual_Entity, context: REVisualSequelContext): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/sequels/VEscapeSequel' {
  import { REVisualSequel } from "MysteryRogueSystem/ts/mr/view/REVisualSequel";
  import { REVisualSequelContext } from "MysteryRogueSystem/ts/mr/view/REVisualSequelContext";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  export class VEscapeSequel extends REVisualSequel {
      onUpdate(visual: REVisual_Entity, context: REVisualSequelContext): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/sequels/VExplosionSequel' {
  import { REVisualSequelContext } from "MysteryRogueSystem/ts/mr/view/REVisualSequelContext";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  export class VExplosionSequel {
      onUpdate(visual: REVisual_Entity, context: REVisualSequelContext): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/sequels/VIdleSequel' {
  import { REVisualSequel } from "MysteryRogueSystem/ts/mr/view/REVisualSequel";
  import { REVisualSequelContext } from "MysteryRogueSystem/ts/mr/view/REVisualSequelContext";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  export class VIdleSequel extends REVisualSequel {
      onUpdate(visual: REVisual_Entity, context: REVisualSequelContext): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/sequels/VJumpSequel' {
  import { REVisualSequel } from "MysteryRogueSystem/ts/mr/view/REVisualSequel";
  import { REVisualSequelContext } from "MysteryRogueSystem/ts/mr/view/REVisualSequelContext";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  export class VJumpSequel extends REVisualSequel {
      private _moveSpeed;
      private _jumpPeak;
      private _jumpCount;
      private _realX;
      private _realY;
      onUpdate(visual: REVisual_Entity, context: REVisualSequelContext): void;
      private jump;
      private jumpHeight;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/sequels/VMoveSequel' {
  import { REVisualSequel } from "MysteryRogueSystem/ts/mr/view/REVisualSequel";
  import { REVisualSequelContext } from "MysteryRogueSystem/ts/mr/view/REVisualSequelContext";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  /**
   * 倍速移動など、1ターンに複数ブロックを移動する場合、その数だけ Sequel が生成される。
   * そうしないと、途中で立ち寄ったブロックを補完するようなアニメーションが表現できない。
   */
  export class REVisualSequel_Move extends REVisualSequel {
      private _curveX;
      private _curveY;
      onUpdate(visual: REVisual_Entity, context: REVisualSequelContext): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/sequels/VSequelHelper' {
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  export class VSequelHelper {
      static updateStepAnimPattern(visual: REVisual_Entity): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/sequels/VStumbleSequel' {
  import { REVisualSequel } from "MysteryRogueSystem/ts/mr/view/REVisualSequel";
  import { REVisualSequelContext } from "MysteryRogueSystem/ts/mr/view/REVisualSequelContext";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  export class VStumbleSequel extends REVisualSequel {
      private static RotationSignTable;
      private _curve;
      constructor();
      onUpdate(visual: REVisual_Entity, context: REVisualSequelContext): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/sequels/VUseItemSequel' {
  import { REVisualSequel } from "MysteryRogueSystem/ts/mr/view/REVisualSequel";
  import { REVisualSequelContext } from "MysteryRogueSystem/ts/mr/view/REVisualSequelContext";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  export class VUseItemSequel extends REVisualSequel {
      private _itemSprite;
      private _itemVisual;
      private _baseX;
      private _baseY;
      onUpdate(visual: REVisual_Entity, context: REVisualSequelContext): void;
      private findItemVisual;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/sequels/VWarpSequel' {
  import { REVisualSequel } from "MysteryRogueSystem/ts/mr/view/REVisualSequel";
  import { REVisualSequelContext } from "MysteryRogueSystem/ts/mr/view/REVisualSequelContext";
  import { REVisual_Entity } from "MysteryRogueSystem/ts/mr/view/REVisual_Entity";
  export class VWarpSequel extends REVisualSequel {
      onUpdate(visual: REVisual_Entity, context: REVisualSequelContext): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/sprites/VFloatingAnimationSprite' {
  export class VFloatingAnimationTargetSprite extends Sprite {
      animationSprite: Sprite_AnimationMV | Sprite_Animation | undefined;
      get isPlaying(): boolean;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/ui/VUICommon' {
  export interface VUIPoint {
      x: number;
      y: number;
  }
  export interface VUISize {
      width: number;
      height: number;
  }
  export interface VUIRect {
      x: number;
      y: number;
      width: number;
      height: number;
  }
  export interface VUIThickness {
      top: number;
      right: number;
      bottom: number;
      left: number;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/ui/VUIElement' {
  import { VUIRect, VUIThickness } from "MysteryRogueSystem/ts/mr/view/ui/VUICommon";
  export class VLayout {
      static makeGridRect(gx: number, gy: number, gw: number, gh: number): Rectangle;
      static calcGridWidth(xs: number): number;
      static calcGridHeight(xs: number): number;
      static calcGridX(xs: number): number;
      static calcGridY(xs: number): number;
      static clamp(value: number, min: number, max: number): number;
      static makeOffset(rect: VUIRect, x_: number, y_: number): VUIRect;
      /** 指定した矩形が収まるようにこの矩形を拡張します。 */
      static inflateIncludes(self: VUIRect, rect: VUIRect): VUIRect;
  }
  export class VUIElement {
      private _margin;
      private _padding;
      private _desiredWidth;
      private _desiredHeight;
      private _actualRect;
      row: number;
      col: number;
      rowSpan: number;
      colSpan: number;
      x: number;
      y: number;
      opacity: number;
      constructor();
      protected calcContentOuter(): VUIThickness;
      margin(top: number, right?: number, bottom?: number, left?: number): this;
      getMargin(): VUIThickness;
      padding(): VUIThickness;
      setGrid(col: number, row: number, colSpan?: number, rowSpan?: number): this;
      setOpacity(value: number): this;
      addTo(container: VUIContainer): this;
      protected setDesiredSize(width: number, height: number): void;
      desiredWidth(): number;
      desiredHeight(): number;
      measure(context: Window_Base): void;
      arrange(finalArea: VUIRect): VUIRect;
      protected arrangeOverride(finalArea: VUIRect): VUIRect;
      protected setActualRect(rect: VUIRect): void;
      actualRect(): VUIRect;
      draw(context: Window_Base): void;
  }
  export class VUITextElement extends VUIElement {
      private _text;
      private _color;
      constructor(text: string);
      setText(value: string): this;
      setColor(value: string): this;
      measure(context: Window_Base): void;
      draw(context: Window_Base): void;
  }
  export class VUIContainer extends VUIElement {
      private _children;
      constructor();
      addChild(element: VUIElement): VUIElement;
      children(): readonly VUIElement[];
      draw(context: Window_Base): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/ui/VUIGridLayout' {
  import { VUIRect } from "MysteryRogueSystem/ts/mr/view/ui/VUICommon";
  import { VUIContainer } from "MysteryRogueSystem/ts/mr/view/ui/VUIElement";
  enum VUIGridLayoutLengthType {
      /** 子要素のサイズに合わせる */
      Auto = 0,
      /** サイズを直接指定する */
      Direct = 1,
      /** レイアウト後、残りの領域を使う */
      Ratio = 2
  }
  enum VUIGridLayoutRule {
      Box = 0,
      VerticalFlow = 1,
      HorizontalFlow = 2
  }
  class VUIGridLayoutDefinitionData {
      type: VUIGridLayoutLengthType;
      size: number;
      minSize: number;
      maxSize: number;
      desiredSize: number;
      actualOffset: number;
      actualSize: number;
      constructor(type: VUIGridLayoutLengthType);
      getAvailableDesiredSize(): number;
      GetRatioSize(): number;
      AdjustActualSize(): void;
  }
  export class VUIGridLayout extends VUIContainer {
      m_rowDefinitions: VUIGridLayoutDefinitionData[];
      m_columnDefinitions: VUIGridLayoutDefinitionData[];
      m_rule: VUIGridLayoutRule;
      constructor();
      private GetDefaultRowLengthType;
      private GetDefaultColumnLengthType;
      private PrepareDefinitions;
      measure(context: Window_Base): void;
      arrangeOverride(finalArea: VUIRect): VUIRect;
  }
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/view/ui/Window_Base' {
  import { VUIContainer } from "MysteryRogueSystem/ts/mr/view/ui/VUIElement";
  global {
      interface Window_Base {
          _root_RE: VUIContainer | undefined;
      }
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/VCharacterSpriteSet' {
  /**
   *
   */
  export class VCharacterSpriteSet {
      private _parent;
      private _owner;
      private _sprites;
      private _revisionNumber;
      constructor(parent: Spriteset_Map, owner: Sprite_Character);
      update(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/VDirectionArrow' {
  export class VDirectionArrow extends Sprite {
      private _sprites;
      private _bitmap;
      private _x;
      private _y;
      private _dir;
      private _crossDiagonal;
      constructor();
      private setPosition;
      setDirection(d: number): void;
      setCrossDiagonal(d: boolean): void;
      update(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/VHelper' {
  export class VHelper {
      static setIconFrame(sprite: Sprite, iconIndex: number): void;
      static toScreenX(mx: number): number;
      static toScreenY(my: number, center?: boolean): number;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/VHudWindow' {
  export class VHudWindow extends Window_Base {
      static readonly HeaderHeight = 70;
      constructor();
      private refresh;
      update(): void;
      private drawFloorNumber;
      private drawLevel;
      private drawHpFp;
      private drawGold;
      private paramTitleColor;
      private expGugeColor;
      private hpGaugeFullyColor;
      private fpGaugeColor;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/VMapGuideGrid' {
  export class VMapGuideGrid {
      private _mapData;
      private _mapWidth;
      private _mapHeight;
      private _visible;
      private _mapdataRevision;
      private _entityDir;
      setVisible(v: boolean): void;
      isVisible(): boolean;
      update(): void;
      readMapData(x: number, y: number): number;
      private setMapData;
      private refresh;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/VMessageWindowSet' {
  import { VFloorNameWindow } from "MysteryRogueSystem/ts/mr/view/windows/VFloorNameWindow";
  /**
   * Scene_Message 相当の機能。
   *
   * Scene_Map をオーバーライドして実装すると他プラグインと衝突するための名前調整など小細工が要ることが多いので、こちらにまとめている。
   */
  export class VMessageWindowSet {
      private _scene;
      private _hudSpriteSet;
      private _logWindow;
      private _shadowBitmap;
      private _shadowSprite;
      private _fadeDuration;
      private _fadeOpacity;
      private _fadeSign;
      _floorNameWindow: VFloorNameWindow;
      constructor(scene: Scene_Map);
      private messageWindowRect;
      attemptStartDisplayFloorName(): void;
      private startFadeIn;
      update(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/VSpriteSet' {
  import { VDirectionArrow } from "MysteryRogueSystem/ts/mr/view/VDirectionArrow";
  export class VSpriteSet {
      private _spritesetMap;
      private _visibilityShadow;
      private _minimapTilemap;
      private _directionArrow;
      private _initialUpdate;
      constructor(spritesetMap: Spriteset_Map);
      destroy(): void;
      get spritesetMap(): Spriteset_Map;
      directionArrow(): VDirectionArrow;
      update(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/VVisibilityShadow' {
  export class VVisibilityShadow {
      private _spritesetMap;
      private _visibilityShadowBitmap;
      private _visibilityShadowInnerSprites;
      private _visibilityShadowOuterSprites;
      private _mx1;
      private _my1;
      private _mx2;
      private _my2;
      private _inRoom;
      private _mx1Animation;
      private _my1Animation;
      private _mx2Animation;
      private _my2Animation;
      constructor(spritesetMap: Spriteset_Map);
      _update(): void;
      private animateVisibleAreaRect;
      private updateVisibleAreaRect;
      private createVisibilityShadowPart;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/windows/VChallengeResultWindow' {
  export class VChallengeResultWindow extends Window_Base {
      _text: string;
      constructor();
      update(): void;
      refresh(): void;
      private drawActorNameAndLevel;
      private drawScore;
      private drawPlaytime;
      private drawResultSummary;
      private drawParam;
      private _drawItem;
      private playtimeText;
      private isTriggered;
      drawItem(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/windows/VDetailsWindow' {
  import { SDetailsDialog } from "ts/mr/system/dialogs/SDetailsDialog";
  export class VDetailsWindow extends Window_Base {
      private _dialog;
      onClose: (() => void) | undefined;
      constructor(dialog: SDetailsDialog);
      private isOpenAndActive;
      update(): void;
      close(): void;
      refresh(): void;
      private isTriggered;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/windows/VEntityCaptionWindow' {
  import { LEntity } from "ts/mr/lively/LEntity";
  export class VEntityCaptionWindow extends Window_Base {
      private _entity;
      static getDefaultRect(): Rectangle;
      constructor(entity: LEntity);
      setEntity(entity: LEntity): void;
      refresh(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/windows/VFlexCommandWindow' {
  import { DActionId } from "ts/mr/data/DCommon";
  import { SDialogCommand } from "ts/mr/system/dialogs/SDialogCommand";
  export type ActionCommandHandler = (actionId: DActionId) => void;
  export type SystemCommandHandler = (commandId: string) => void;
  export interface CommandInfo {
      actionId: DActionId;
      displayText: string;
      commandId: string;
      actionHandler: ActionCommandHandler | undefined;
      systemHandler: SystemCommandHandler | undefined;
  }
  /**
   * - [説明] など、Sub Dialog を開く Command
   * - [投げる] [置く] など、特定の Entity に対する Action の Command
   * - [あずける] など、システム的な Command
   *
   * add**() で追加し終わったら refresh() すること。
   */
  export class VFlexCommandWindow extends Window_Command {
      private _commands;
      constructor(rect: Rectangle);
      setupFromCommandList(commands: SDialogCommand[]): void;
      addActionCommand(actionId: DActionId, displayName: string | undefined, commandId: string, handler: ActionCommandHandler): void;
      addSystemCommand(text: string, commandId: string, systemHandler: SystemCommandHandler): void;
      clear(): void;
      fitHeight(): void;
      makeCommandList(): void;
      processOk(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/windows/VFloorNameWindow' {
  /**
   */
  export class VFloorNameWindow extends Window_Base {
      private _showCount;
      constructor(rect: Rectangle);
      open(): void;
      close(): void;
      isEffectRunning(): boolean;
      showCount(): number;
      update(): void;
      private updateFadeIn;
      private updateFadeOut;
      private refresh;
      private drawBackground;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/windows/VItemListWindow' {
  import { LEquipmentUserBehavior } from "ts/mr/lively/behaviors/LEquipmentUserBehavior";
  import { LInventoryBehavior } from "ts/mr/lively/behaviors/LInventoryBehavior";
  import { LEntity } from "ts/mr/lively/LEntity";
  export class VItemListWindowItem {
      entity: LEntity;
      selectedIndex: number | undefined;
      constructor(item: LEntity);
  }
  export enum VItemListPriceTag {
      None = 0,
      SellingPrice = 1,
      PurchasePrice = 2
  }
  /**
   */
  export class VItemListWindow extends Window_Selectable {
      private _inventory;
      private _equipmentUser;
      private _items;
      private _pagenationEnabled;
      private _currentPageIndex;
      private _leftArrowSprite;
      private _rightArrowSprite;
      multipleSelectionEnabled: boolean;
      priceTag: VItemListPriceTag;
      constructor(rect: Rectangle);
      get itemsParPage(): number;
      get maxPageCount(): number;
      getActualPriceTag(item: LEntity): VItemListPriceTag;
      setInventory(inventory: LInventoryBehavior): void;
      refreshItems(): void;
      setEquipmentUser(equipmentUser: LEquipmentUserBehavior): void;
      selectedItem(): LEntity;
      isMultipleSelecting(): boolean;
      getSelectedItems(): LEntity[];
      maxCols(): number;
      maxItems(): number;
      isCurrentItemEnabled(): boolean;
      refresh(): void;
      drawAllItems(): void;
      drawItem(index: number): void;
      update(): void;
      cursorRight(wrap: boolean): void;
      cursorLeft(wrap: boolean): void;
      private toggleItemSelection;
      private correctSelectedIndex;
      private numberWidth;
      private itemAt;
      private drawEntityItemName;
      private createPagenationArrowSprites;
      private refreshPagenationArrows;
      private updatePagenationArrows;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/windows/VMainStatusWindow' {
  import { LEntity } from "ts/mr/lively/LEntity";
  export class VMainStatusWindow extends Window_Base {
      private _entity;
      onClose: (() => void) | undefined;
      private _layout;
      private _curve2;
      private _curve1;
      private _opacityCurve;
      private _initialY;
      private _weaponText;
      private _weaponValue;
      private _shieldText;
      private _shieldValue;
      private _fpText;
      private _fpValue;
      private _powText;
      private _powValue;
      private _expText;
      private _expValue;
      private _nextexpText;
      private _nextexpValue;
      private _invalidateLayout;
      private _invalidateDraw;
      constructor(rect: Rectangle);
      setEntity(entity: LEntity): void;
      private invalidate;
      destroy(): void;
      update(): void;
      close(): void;
      layout(): void;
      refresh(): void;
      private draw;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/windows/VMenuCommandWindow' {
  /**
   */
  export class VMenuCommandWindow extends Window_Command {
      constructor(rect: Rectangle);
      makeCommandList(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/windows/VMessageLogWindow' {
  import { LMessageHistory } from "ts/mr/lively/LMessageHistory";
  interface TextLineState {
      text: string;
      index: number;
      x: number;
      y: number;
      width: number;
      height: number;
      startX: number;
      startY: number;
      rtl: boolean;
      buffer: string;
      drawing: boolean;
      outputWidth: number;
      outputHeight: number;
      sprite: Sprite;
      scrollStartY: number;
  }
  /**
   */
  export class VMessageLogWindow extends Window_Base {
      private _message;
      private _waitCount;
      private _autoScroll;
      private _autoScrollCount;
      private _autoScrollCountMax;
      private _maxLines;
      private _autoCloseCount;
      private _autoCloseCountMax;
      private _lineSpriteCache;
      private _textLines;
      constructor(message: LMessageHistory, rect: Rectangle);
      private initMembers;
      private maxLines;
      update(): void;
      private checkToNotClose;
      private doesContinue;
      private updateWait;
      private updateLoading;
      private updateInput;
      private updateAutoScroll;
      private startNewMessageAndScroll;
      private newLineX;
      private canScrollStart;
      private terminateMessage;
      private onEndOfText;
      processControlCharacter(textState: TextLineState, c: string): void;
      private isEndOfText;
      processEscapeCharacter(code: string, textState: TextLineState): void;
      flushTextState(textState: TextLineState): void;
      processDrawIcon(iconIndex: number, textState: TextLineState): void;
      private startWait;
      private updateAutoClose;
      private acquireLineSprite;
      private releaseLineSprite;
  }
  export {};

}
declare module 'MysteryRogueSystem/ts/mr/view/windows/VNicknameEditWindow' {
  import { LEntity } from "ts/mr/lively/LEntity";
  export class VNicknameEditWindow extends Window_NameEdit {
      constructor(rect: Rectangle);
      setupFromEntity(entity: LEntity): void;
      refresh(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/windows/VNicknameInputWindow' {
  /**
   */
  export class VNicknameInputWindow extends Window_NameInput {
      constructor(rect: Rectangle);
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/windows/VWarehouseMenuCommandWindow' {
  /**
   */
  export class VWarehouseMenuCommandWindow extends Window_Command {
      constructor(rect: Rectangle);
      makeCommandList(): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/windows/VWindowHelper' {
  import { LEquipmentUserBehavior } from "ts/mr/lively/behaviors/LEquipmentUserBehavior";
  import { LEntity } from "ts/mr/lively/LEntity";
  export class VWindowHelper {
      static DefaultPadding: number;
      static LineHeight: number;
      static calcWindowHeight(numLines: number, selectable: boolean): number;
      static calcWindowSizeFromClinetSize(width: number, height: number): number[];
      static calcOuterPadding(window: Window_Base): number[];
      static drawEntityItemName(window: Window_Base, item: LEntity, x: number, y: number, width: number, equipmentUser: LEquipmentUserBehavior | undefined): void;
  }

}
declare module 'MysteryRogueSystem/ts/mr/view/windows/Window_Location' {
  /**
   */
  export class Window_Location extends Window_Command {
      _text: string;
      constructor(rect: Rectangle);
      refresh(): void;
  }

}
declare module 'MysteryRogueSystem' {
  import main = require('MysteryRogueSystem/ts/main');
  export = main;
}